//   Ordt 171103.01 autogenerated file 
//   Input: NVDLA_CFGROM.rdl
//   Parms: opendla.parms
//   Date: Sat Feb 29 19:31:08 CET 2020
//

#include "ordt_pio_common.hpp"
#include "ordt_pio.hpp"

// ------------------ ordt_addr_elem methods ------------------

ordt_addr_elem::ordt_addr_elem(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : m_startaddress(_m_startaddress),
    m_endaddress(_m_endaddress) {
}

bool  ordt_addr_elem::containsAddress(const uint64_t &addr) {
  return ((addr >= m_startaddress) && (addr <= m_endaddress));
}

bool  ordt_addr_elem::isBelowAddress(const uint64_t &addr) {
  return (addr > m_endaddress);
}

bool  ordt_addr_elem::isAboveAddress(const uint64_t &addr) {
  return (addr < m_startaddress);
}

bool  ordt_addr_elem::hasStartAddress(const uint64_t &addr) {
  return (addr == m_startaddress);
}

void  ordt_addr_elem::update_child_ptrs() {
}

// ------------------ ordt_regset methods ------------------

ordt_addr_elem*  ordt_regset::findAddrElem(const uint64_t &addr) {
  int lo = 0;
  int hi = m_children.size()-1;
  int mid = 0;
  while (lo <= hi) {
     mid = (lo + hi) / 2;
     if (m_children[mid]->containsAddress(addr)) {
        //outElem = m_children[mid];
        return m_children[mid];
     }
     else if (m_children[mid]->isAboveAddress(addr))
        hi = mid - 1;
     else
        lo = mid + 1;
  }
  return nullptr;
}

ordt_regset::ordt_regset(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_addr_elem(_m_startaddress, _m_endaddress) {
}

int  ordt_regset::write(const uint64_t &addr, const ordt_data &wdata) {
     if (this->containsAddress(addr)) {
        childElem = this->findAddrElem(addr);
        if (childElem != nullptr) { return childElem->write(addr, wdata); }
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in regset\n";
  #endif
     return 8;
}

int  ordt_regset::read(const uint64_t &addr, ordt_data &rdata) {
     if (this->containsAddress(addr)) {
        childElem = this->findAddrElem(addr);
        if (childElem != nullptr) { return childElem->read(addr, rdata); }
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in regset\n";
  #endif
     rdata.clear();
     return 8;
}

// ------------------ ordt_reg methods ------------------

ordt_reg::ordt_reg(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_addr_elem(_m_startaddress, _m_endaddress) {
}

ordt_reg::ordt_reg(const ordt_reg &_old)
  : ordt_addr_elem(_old),
    m_mutex() {
}

void  ordt_reg::write(const ordt_data &wdata) {
}

int  ordt_reg::write(const uint64_t &addr, const ordt_data &wdata) {
     return 0;
}

void  ordt_reg::read(ordt_data &rdata) {
}

int  ordt_reg::read(const uint64_t &addr, ordt_data &rdata) {
     return 0;
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_HW_VERSION methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_HW_VERSION::ordt_rg_NVDLA_CFGROM_CFGROM_HW_VERSION(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    HW_VERSION(0, 32, 0x10001, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_HW_VERSION::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_HW_VERSION at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_HW_VERSION\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_HW_VERSION::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  HW_VERSION.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_HW_VERSION::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_HW_VERSION at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_HW_VERSION\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_HW_VERSION::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  HW_VERSION.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_GLB_DESC methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_GLB_DESC::ordt_rg_NVDLA_CFGROM_CFGROM_GLB_DESC(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    GLB_DESC(0, 32, 0x1, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_GLB_DESC::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_GLB_DESC at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_GLB_DESC\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_GLB_DESC::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  GLB_DESC.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_GLB_DESC::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_GLB_DESC at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_GLB_DESC\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_GLB_DESC::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  GLB_DESC.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CIF_DESC methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CIF_DESC::ordt_rg_NVDLA_CFGROM_CFGROM_CIF_DESC(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CIF_DESC(0, 32, 0x180002, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_DESC::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_DESC at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_DESC\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_DESC::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CIF_DESC.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_DESC::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_DESC at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_DESC\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_DESC::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CIF_DESC.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CIF_CAP_INCOMPAT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CIF_CAP_INCOMPAT::ordt_rg_NVDLA_CFGROM_CFGROM_CIF_CAP_INCOMPAT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CIF_CAP_INCOMPAT(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_CAP_INCOMPAT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_CAP_INCOMPAT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_CAP_INCOMPAT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_CAP_INCOMPAT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CIF_CAP_INCOMPAT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_CAP_INCOMPAT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_CAP_INCOMPAT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_CAP_INCOMPAT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_CAP_INCOMPAT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CIF_CAP_INCOMPAT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CIF_CAP_COMPAT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CIF_CAP_COMPAT::ordt_rg_NVDLA_CFGROM_CFGROM_CIF_CAP_COMPAT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CIF_CAP_COMPAT(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_CAP_COMPAT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_CAP_COMPAT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_CAP_COMPAT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_CAP_COMPAT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CIF_CAP_COMPAT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_CAP_COMPAT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_CAP_COMPAT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_CAP_COMPAT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_CAP_COMPAT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CIF_CAP_COMPAT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_WIDTH methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_WIDTH::ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_WIDTH(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CIF_BASE_WIDTH(0, 8, 0x8, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_WIDTH::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_WIDTH at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_WIDTH\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_WIDTH::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CIF_BASE_WIDTH.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_WIDTH::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_WIDTH at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_WIDTH\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_WIDTH::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CIF_BASE_WIDTH.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_LATENCY methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_LATENCY::ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_LATENCY(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CIF_BASE_LATENCY(0, 32, 0x32, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_LATENCY::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_LATENCY at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_LATENCY\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_LATENCY::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CIF_BASE_LATENCY.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_LATENCY::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_LATENCY at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_LATENCY\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_LATENCY::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CIF_BASE_LATENCY.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_BURST_LENGTH_MAX methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_BURST_LENGTH_MAX::ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_BURST_LENGTH_MAX(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    BASE_BURST_LENGTH_MAX(5, 27, 0x4, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_BURST_LENGTH_MAX::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_BURST_LENGTH_MAX at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_BURST_LENGTH_MAX\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_BURST_LENGTH_MAX::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  BASE_BURST_LENGTH_MAX.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_BURST_LENGTH_MAX::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_BURST_LENGTH_MAX at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_BURST_LENGTH_MAX\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_BURST_LENGTH_MAX::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  BASE_BURST_LENGTH_MAX.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_MEM_ADDR_WIDTH methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_MEM_ADDR_WIDTH::ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_MEM_ADDR_WIDTH(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CIF_BASE_MEM_ADDR_WIDTH(5, 27, 0x20, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_MEM_ADDR_WIDTH::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_MEM_ADDR_WIDTH at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_MEM_ADDR_WIDTH\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_MEM_ADDR_WIDTH::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CIF_BASE_MEM_ADDR_WIDTH.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_MEM_ADDR_WIDTH::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_MEM_ADDR_WIDTH at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_MEM_ADDR_WIDTH\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CIF_BASE_MEM_ADDR_WIDTH::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CIF_BASE_MEM_ADDR_WIDTH.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_DESC methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_DESC::ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_DESC(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CDMA_DESC(0, 32, 0x340003, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_DESC::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_DESC at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_DESC\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_DESC::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CDMA_DESC.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_DESC::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_DESC at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_DESC\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_DESC::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CDMA_DESC.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_CAP_INCOMPAT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_CAP_INCOMPAT::ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_CAP_INCOMPAT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CDMA_CAP_INCOMPAT(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_CAP_INCOMPAT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_CAP_INCOMPAT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_CAP_INCOMPAT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_CAP_INCOMPAT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CDMA_CAP_INCOMPAT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_CAP_INCOMPAT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_CAP_INCOMPAT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_CAP_INCOMPAT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_CAP_INCOMPAT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CDMA_CAP_INCOMPAT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_CAP_COMPAT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_CAP_COMPAT::ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_CAP_COMPAT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CDMA_CAP_COMPAT(0, 32, 0x10, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_CAP_COMPAT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_CAP_COMPAT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_CAP_COMPAT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_CAP_COMPAT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CDMA_CAP_COMPAT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_CAP_COMPAT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_CAP_COMPAT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_CAP_COMPAT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_CAP_COMPAT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CDMA_CAP_COMPAT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_FEATURE_TYPES methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_FEATURE_TYPES::ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_FEATURE_TYPES(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CDMA_BASE_FEATURE_TYPES(0, 12, 0x10, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_FEATURE_TYPES::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_FEATURE_TYPES at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_FEATURE_TYPES\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_FEATURE_TYPES::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CDMA_BASE_FEATURE_TYPES.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_FEATURE_TYPES::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_FEATURE_TYPES at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_FEATURE_TYPES\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_FEATURE_TYPES::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CDMA_BASE_FEATURE_TYPES.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_WEIGHT_TYPES methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_WEIGHT_TYPES::ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_WEIGHT_TYPES(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CDMA_BASE_WEIGHT_TYPES(0, 12, 0x10, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_WEIGHT_TYPES::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_WEIGHT_TYPES at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_WEIGHT_TYPES\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_WEIGHT_TYPES::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CDMA_BASE_WEIGHT_TYPES.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_WEIGHT_TYPES::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_WEIGHT_TYPES at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_WEIGHT_TYPES\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_WEIGHT_TYPES::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CDMA_BASE_WEIGHT_TYPES.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_C methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_C::ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_C(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CDMA_BASE_ATOMIC_C(0, 32, 0x8, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_C::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_C at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_C\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_C::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CDMA_BASE_ATOMIC_C.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_C::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_C at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_C\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_C::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CDMA_BASE_ATOMIC_C.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_K methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_K::ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_K(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CDMA_BASE_ATOMIC_K(0, 32, 0x8, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_K::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_K at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_K\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_K::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CDMA_BASE_ATOMIC_K.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_K::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_K at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_K\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_K::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CDMA_BASE_ATOMIC_K.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_M methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_M::ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_M(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CDMA_BASE_ATOMIC_M(0, 32, 0x8, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_M::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_M at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_M\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_M::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CDMA_BASE_ATOMIC_M.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_M::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_M at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_M\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_ATOMIC_M::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CDMA_BASE_ATOMIC_M.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_NUM methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_NUM::ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_NUM(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CDMA_BASE_CBUF_BANK_NUM(0, 32, 0x20, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_NUM::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_NUM at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_NUM\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_NUM::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CDMA_BASE_CBUF_BANK_NUM.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_NUM::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_NUM at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_NUM\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_NUM::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CDMA_BASE_CBUF_BANK_NUM.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_WIDTH methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_WIDTH::ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_WIDTH(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CDMA_BASE_CBUF_BANK_WIDTH(0, 32, 0x8, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_WIDTH::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_WIDTH at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_WIDTH\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_WIDTH::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CDMA_BASE_CBUF_BANK_WIDTH.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_WIDTH::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_WIDTH at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_WIDTH\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_WIDTH::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CDMA_BASE_CBUF_BANK_WIDTH.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_DEPTH methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_DEPTH::ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_DEPTH(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CDMA_BASE_CBUF_BANK_DEPTH(0, 32, 0x200, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_DEPTH::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_DEPTH at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_DEPTH\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_DEPTH::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CDMA_BASE_CBUF_BANK_DEPTH.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_DEPTH::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_DEPTH at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_DEPTH\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_BASE_CBUF_BANK_DEPTH::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CDMA_BASE_CBUF_BANK_DEPTH.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_MULTI_BATCH_MAX methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_MULTI_BATCH_MAX::ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_MULTI_BATCH_MAX(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CDMA_MULTI_BATCH_MAX(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_MULTI_BATCH_MAX::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_MULTI_BATCH_MAX at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_MULTI_BATCH_MAX\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_MULTI_BATCH_MAX::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CDMA_MULTI_BATCH_MAX.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_MULTI_BATCH_MAX::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_MULTI_BATCH_MAX at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_MULTI_BATCH_MAX\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_MULTI_BATCH_MAX::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CDMA_MULTI_BATCH_MAX.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_IMAGE_IN_FORMATS_PACKED methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_IMAGE_IN_FORMATS_PACKED::ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_IMAGE_IN_FORMATS_PACKED(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CDMA_IMAGE_IN_FORMATS_PACKED(0, 32, 0xcfff001, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_IMAGE_IN_FORMATS_PACKED::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_IMAGE_IN_FORMATS_PACKED at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_IMAGE_IN_FORMATS_PACKED\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_IMAGE_IN_FORMATS_PACKED::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CDMA_IMAGE_IN_FORMATS_PACKED.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_IMAGE_IN_FORMATS_PACKED::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_IMAGE_IN_FORMATS_PACKED at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_IMAGE_IN_FORMATS_PACKED\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_IMAGE_IN_FORMATS_PACKED::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CDMA_IMAGE_IN_FORMATS_PACKED.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_IMAGE_IN_FORMATS_SEMI methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_IMAGE_IN_FORMATS_SEMI::ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_IMAGE_IN_FORMATS_SEMI(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CDMA_IMAGE_IN_FORMATS_SEMI(0, 32, 0x3, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_IMAGE_IN_FORMATS_SEMI::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_IMAGE_IN_FORMATS_SEMI at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_IMAGE_IN_FORMATS_SEMI\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_IMAGE_IN_FORMATS_SEMI::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CDMA_IMAGE_IN_FORMATS_SEMI.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_IMAGE_IN_FORMATS_SEMI::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_IMAGE_IN_FORMATS_SEMI at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_IMAGE_IN_FORMATS_SEMI\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDMA_IMAGE_IN_FORMATS_SEMI::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CDMA_IMAGE_IN_FORMATS_SEMI.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_DESC methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_DESC::ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_DESC(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CBUF_DESC(0, 32, 0x180004, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_DESC::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_DESC at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_DESC\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_DESC::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CBUF_DESC.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_DESC::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_DESC at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_DESC\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_DESC::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CBUF_DESC.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_CAP_INCOMPAT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_CAP_INCOMPAT::ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_CAP_INCOMPAT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CBUF_CAP_INCOMPAT(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_CAP_INCOMPAT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_CAP_INCOMPAT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_CAP_INCOMPAT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_CAP_INCOMPAT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CBUF_CAP_INCOMPAT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_CAP_INCOMPAT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_CAP_INCOMPAT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_CAP_INCOMPAT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_CAP_INCOMPAT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CBUF_CAP_INCOMPAT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_CAP_COMPAT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_CAP_COMPAT::ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_CAP_COMPAT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CBUF_CAP_COMPAT(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_CAP_COMPAT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_CAP_COMPAT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_CAP_COMPAT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_CAP_COMPAT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CBUF_CAP_COMPAT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_CAP_COMPAT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_CAP_COMPAT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_CAP_COMPAT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_CAP_COMPAT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CBUF_CAP_COMPAT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_NUM methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_NUM::ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_NUM(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CBUF_BASE_CBUF_BANK_NUM(0, 32, 0x20, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_NUM::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_NUM at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_NUM\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_NUM::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CBUF_BASE_CBUF_BANK_NUM.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_NUM::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_NUM at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_NUM\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_NUM::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CBUF_BASE_CBUF_BANK_NUM.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_WIDTH methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_WIDTH::ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_WIDTH(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CBUF_BASE_CBUF_BANK_WIDTH(0, 32, 0x8, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_WIDTH::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_WIDTH at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_WIDTH\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_WIDTH::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CBUF_BASE_CBUF_BANK_WIDTH.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_WIDTH::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_WIDTH at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_WIDTH\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_WIDTH::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CBUF_BASE_CBUF_BANK_WIDTH.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_DEPTH methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_DEPTH::ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_DEPTH(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CBUF_BASE_CBUF_BANK_DEPTH(0, 32, 0x200, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_DEPTH::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_DEPTH at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_DEPTH\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_DEPTH::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CBUF_BASE_CBUF_BANK_DEPTH.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_DEPTH::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_DEPTH at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_DEPTH\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CBUF_BANK_DEPTH::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CBUF_BASE_CBUF_BANK_DEPTH.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CDMA_ID methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CDMA_ID::ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CDMA_ID(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CBUF_BASE_CDMA_ID(0, 32, 0x3, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CDMA_ID::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CDMA_ID at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CDMA_ID\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CDMA_ID::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CBUF_BASE_CDMA_ID.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CDMA_ID::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CDMA_ID at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CDMA_ID\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CBUF_BASE_CDMA_ID::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CBUF_BASE_CDMA_ID.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CSC_DESC methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CSC_DESC::ordt_rg_NVDLA_CFGROM_CFGROM_CSC_DESC(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CSC_DESC(0, 32, 0x300005, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_DESC::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_DESC at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_DESC\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_DESC::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CSC_DESC.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_DESC::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_DESC at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_DESC\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_DESC::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CSC_DESC.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CSC_CAP_INCOMPAT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CSC_CAP_INCOMPAT::ordt_rg_NVDLA_CFGROM_CFGROM_CSC_CAP_INCOMPAT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CSC_CAP_INCOMPAT(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_CAP_INCOMPAT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_CAP_INCOMPAT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_CAP_INCOMPAT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_CAP_INCOMPAT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CSC_CAP_INCOMPAT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_CAP_INCOMPAT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_CAP_INCOMPAT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_CAP_INCOMPAT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_CAP_INCOMPAT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CSC_CAP_INCOMPAT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CSC_CAP_COMPAT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CSC_CAP_COMPAT::ordt_rg_NVDLA_CFGROM_CFGROM_CSC_CAP_COMPAT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CSC_CAP_COMPAT(0, 32, 0x10, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_CAP_COMPAT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_CAP_COMPAT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_CAP_COMPAT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_CAP_COMPAT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CSC_CAP_COMPAT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_CAP_COMPAT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_CAP_COMPAT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_CAP_COMPAT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_CAP_COMPAT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CSC_CAP_COMPAT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_FEATURE_TYPES methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_FEATURE_TYPES::ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_FEATURE_TYPES(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CSC_BASE_FEATURE_TYPES(0, 12, 0x10, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_FEATURE_TYPES::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_FEATURE_TYPES at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_FEATURE_TYPES\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_FEATURE_TYPES::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CSC_BASE_FEATURE_TYPES.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_FEATURE_TYPES::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_FEATURE_TYPES at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_FEATURE_TYPES\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_FEATURE_TYPES::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CSC_BASE_FEATURE_TYPES.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_WEIGHT_TYPES methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_WEIGHT_TYPES::ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_WEIGHT_TYPES(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CSC_BASE_WEIGHT_TYPES(0, 12, 0x10, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_WEIGHT_TYPES::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_WEIGHT_TYPES at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_WEIGHT_TYPES\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_WEIGHT_TYPES::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CSC_BASE_WEIGHT_TYPES.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_WEIGHT_TYPES::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_WEIGHT_TYPES at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_WEIGHT_TYPES\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_WEIGHT_TYPES::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CSC_BASE_WEIGHT_TYPES.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_C methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_C::ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_C(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CSC_BASE_ATOMIC_C(0, 32, 0x8, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_C::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_C at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_C\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_C::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CSC_BASE_ATOMIC_C.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_C::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_C at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_C\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_C::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CSC_BASE_ATOMIC_C.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_K methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_K::ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_K(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CSC_BASE_ATOMIC_K(0, 32, 0x8, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_K::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_K at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_K\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_K::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CSC_BASE_ATOMIC_K.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_K::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_K at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_K\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_K::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CSC_BASE_ATOMIC_K.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_M methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_M::ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_M(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CSC_BASE_ATOMIC_M(0, 32, 0x8, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_M::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_M at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_M\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_M::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CSC_BASE_ATOMIC_M.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_M::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_M at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_M\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_ATOMIC_M::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CSC_BASE_ATOMIC_M.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_NUM methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_NUM::ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_NUM(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CSC_BASE_CBUF_BANK_NUM(0, 32, 0x20, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_NUM::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_NUM at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_NUM\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_NUM::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CSC_BASE_CBUF_BANK_NUM.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_NUM::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_NUM at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_NUM\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_NUM::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CSC_BASE_CBUF_BANK_NUM.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_WIDTH methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_WIDTH::ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_WIDTH(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CSC_BASE_CBUF_BANK_WIDTH(0, 32, 0x8, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_WIDTH::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_WIDTH at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_WIDTH\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_WIDTH::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CSC_BASE_CBUF_BANK_WIDTH.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_WIDTH::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_WIDTH at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_WIDTH\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_WIDTH::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CSC_BASE_CBUF_BANK_WIDTH.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_DEPTH methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_DEPTH::ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_DEPTH(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CSC_BASE_CBUF_BANK_DEPTH(0, 32, 0x200, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_DEPTH::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_DEPTH at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_DEPTH\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_DEPTH::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CSC_BASE_CBUF_BANK_DEPTH.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_DEPTH::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_DEPTH at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_DEPTH\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CBUF_BANK_DEPTH::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CSC_BASE_CBUF_BANK_DEPTH.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CDMA_ID methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CDMA_ID::ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CDMA_ID(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CSC_BASE_CDMA_ID(0, 32, 0x3, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CDMA_ID::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CDMA_ID at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CDMA_ID\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CDMA_ID::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CSC_BASE_CDMA_ID.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CDMA_ID::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CDMA_ID at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CDMA_ID\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_BASE_CDMA_ID::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CSC_BASE_CDMA_ID.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CSC_MULTI_BATCH_MAX methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CSC_MULTI_BATCH_MAX::ordt_rg_NVDLA_CFGROM_CFGROM_CSC_MULTI_BATCH_MAX(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CSC_MULTI_BATCH_MAX(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_MULTI_BATCH_MAX::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_MULTI_BATCH_MAX at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_MULTI_BATCH_MAX\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_MULTI_BATCH_MAX::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CSC_MULTI_BATCH_MAX.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_MULTI_BATCH_MAX::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_MULTI_BATCH_MAX at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CSC_MULTI_BATCH_MAX\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CSC_MULTI_BATCH_MAX::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CSC_MULTI_BATCH_MAX.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_DESC methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_DESC::ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_DESC(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CMAC_A_DESC(0, 32, 0x1c0006, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_DESC::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_DESC at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_DESC\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_DESC::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CMAC_A_DESC.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_DESC::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_DESC at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_DESC\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_DESC::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CMAC_A_DESC.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_CAP_INCOMPAT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_CAP_INCOMPAT::ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_CAP_INCOMPAT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CMAC_A_CAP_INCOMPAT(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_CAP_INCOMPAT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_CAP_INCOMPAT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_CAP_INCOMPAT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_CAP_INCOMPAT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CMAC_A_CAP_INCOMPAT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_CAP_INCOMPAT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_CAP_INCOMPAT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_CAP_INCOMPAT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_CAP_INCOMPAT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CMAC_A_CAP_INCOMPAT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_CAP_COMPAT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_CAP_COMPAT::ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_CAP_COMPAT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CMAC_A_CAP_COMPAT(0, 32, 0x10, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_CAP_COMPAT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_CAP_COMPAT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_CAP_COMPAT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_CAP_COMPAT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CMAC_A_CAP_COMPAT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_CAP_COMPAT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_CAP_COMPAT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_CAP_COMPAT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_CAP_COMPAT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CMAC_A_CAP_COMPAT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_FEATURE_TYPES methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_FEATURE_TYPES::ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_FEATURE_TYPES(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CMAC_A_BASE_FEATURE_TYPES(0, 12, 0x10, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_FEATURE_TYPES::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_FEATURE_TYPES at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_FEATURE_TYPES\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_FEATURE_TYPES::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CMAC_A_BASE_FEATURE_TYPES.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_FEATURE_TYPES::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_FEATURE_TYPES at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_FEATURE_TYPES\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_FEATURE_TYPES::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CMAC_A_BASE_FEATURE_TYPES.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_WEIGHT_TYPES methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_WEIGHT_TYPES::ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_WEIGHT_TYPES(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CMAC_A_BASE_WEIGHT_TYPES(0, 12, 0x10, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_WEIGHT_TYPES::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_WEIGHT_TYPES at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_WEIGHT_TYPES\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_WEIGHT_TYPES::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CMAC_A_BASE_WEIGHT_TYPES.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_WEIGHT_TYPES::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_WEIGHT_TYPES at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_WEIGHT_TYPES\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_WEIGHT_TYPES::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CMAC_A_BASE_WEIGHT_TYPES.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_ATOMIC_C methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_ATOMIC_C::ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_ATOMIC_C(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CMAC_A_BASE_ATOMIC_C(0, 32, 0x8, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_ATOMIC_C::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_ATOMIC_C at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_ATOMIC_C\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_ATOMIC_C::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CMAC_A_BASE_ATOMIC_C.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_ATOMIC_C::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_ATOMIC_C at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_ATOMIC_C\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_ATOMIC_C::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CMAC_A_BASE_ATOMIC_C.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_ATOMIC_K methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_ATOMIC_K::ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_ATOMIC_K(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CMAC_A_BASE_ATOMIC_K(0, 32, 0x8, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_ATOMIC_K::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_ATOMIC_K at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_ATOMIC_K\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_ATOMIC_K::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CMAC_A_BASE_ATOMIC_K.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_ATOMIC_K::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_ATOMIC_K at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_ATOMIC_K\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_ATOMIC_K::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CMAC_A_BASE_ATOMIC_K.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_CDMA_ID methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_CDMA_ID::ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_CDMA_ID(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CMAC_A_BASE_CDMA_ID(0, 32, 0x3, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_CDMA_ID::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_CDMA_ID at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_CDMA_ID\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_CDMA_ID::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CMAC_A_BASE_CDMA_ID.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_CDMA_ID::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_CDMA_ID at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_CDMA_ID\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_A_BASE_CDMA_ID::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CMAC_A_BASE_CDMA_ID.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_DESC methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_DESC::ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_DESC(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CMAC_B_DESC(0, 32, 0x1c0006, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_DESC::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_DESC at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_DESC\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_DESC::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CMAC_B_DESC.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_DESC::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_DESC at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_DESC\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_DESC::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CMAC_B_DESC.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_CAP_INCOMPAT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_CAP_INCOMPAT::ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_CAP_INCOMPAT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CMAC_B_CAP_INCOMPAT(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_CAP_INCOMPAT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_CAP_INCOMPAT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_CAP_INCOMPAT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_CAP_INCOMPAT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CMAC_B_CAP_INCOMPAT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_CAP_INCOMPAT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_CAP_INCOMPAT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_CAP_INCOMPAT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_CAP_INCOMPAT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CMAC_B_CAP_INCOMPAT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_CAP_COMPAT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_CAP_COMPAT::ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_CAP_COMPAT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CMAC_B_CAP_COMPAT(0, 32, 0x10, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_CAP_COMPAT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_CAP_COMPAT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_CAP_COMPAT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_CAP_COMPAT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CMAC_B_CAP_COMPAT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_CAP_COMPAT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_CAP_COMPAT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_CAP_COMPAT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_CAP_COMPAT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CMAC_B_CAP_COMPAT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_FEATURE_TYPES methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_FEATURE_TYPES::ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_FEATURE_TYPES(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CMAC_B_BASE_FEATURE_TYPES(0, 12, 0x10, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_FEATURE_TYPES::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_FEATURE_TYPES at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_FEATURE_TYPES\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_FEATURE_TYPES::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CMAC_B_BASE_FEATURE_TYPES.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_FEATURE_TYPES::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_FEATURE_TYPES at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_FEATURE_TYPES\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_FEATURE_TYPES::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CMAC_B_BASE_FEATURE_TYPES.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_WEIGHT_TYPES methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_WEIGHT_TYPES::ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_WEIGHT_TYPES(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CMAC_B_BASE_WEIGHT_TYPES(0, 12, 0x10, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_WEIGHT_TYPES::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_WEIGHT_TYPES at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_WEIGHT_TYPES\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_WEIGHT_TYPES::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CMAC_B_BASE_WEIGHT_TYPES.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_WEIGHT_TYPES::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_WEIGHT_TYPES at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_WEIGHT_TYPES\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_WEIGHT_TYPES::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CMAC_B_BASE_WEIGHT_TYPES.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_ATOMIC_C methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_ATOMIC_C::ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_ATOMIC_C(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CMAC_B_BASE_ATOMIC_C(0, 32, 0x8, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_ATOMIC_C::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_ATOMIC_C at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_ATOMIC_C\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_ATOMIC_C::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CMAC_B_BASE_ATOMIC_C.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_ATOMIC_C::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_ATOMIC_C at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_ATOMIC_C\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_ATOMIC_C::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CMAC_B_BASE_ATOMIC_C.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_ATOMIC_K methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_ATOMIC_K::ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_ATOMIC_K(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CMAC_B_BASE_ATOMIC_K(0, 32, 0x8, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_ATOMIC_K::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_ATOMIC_K at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_ATOMIC_K\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_ATOMIC_K::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CMAC_B_BASE_ATOMIC_K.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_ATOMIC_K::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_ATOMIC_K at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_ATOMIC_K\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_ATOMIC_K::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CMAC_B_BASE_ATOMIC_K.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_CDMA_ID methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_CDMA_ID::ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_CDMA_ID(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CMAC_B_BASE_CDMA_ID(0, 32, 0x3, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_CDMA_ID::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_CDMA_ID at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_CDMA_ID\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_CDMA_ID::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CMAC_B_BASE_CDMA_ID.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_CDMA_ID::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_CDMA_ID at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_CDMA_ID\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CMAC_B_BASE_CDMA_ID::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CMAC_B_BASE_CDMA_ID.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CACC_DESC methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CACC_DESC::ordt_rg_NVDLA_CFGROM_CFGROM_CACC_DESC(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CACC_DESC(0, 32, 0x200007, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_DESC::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_DESC at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_DESC\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_DESC::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CACC_DESC.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_DESC::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_DESC at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_DESC\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_DESC::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CACC_DESC.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CACC_CAP_INCOMPAT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CACC_CAP_INCOMPAT::ordt_rg_NVDLA_CFGROM_CFGROM_CACC_CAP_INCOMPAT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CACC_CAP_INCOMPAT(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_CAP_INCOMPAT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_CAP_INCOMPAT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_CAP_INCOMPAT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_CAP_INCOMPAT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CACC_CAP_INCOMPAT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_CAP_INCOMPAT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_CAP_INCOMPAT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_CAP_INCOMPAT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_CAP_INCOMPAT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CACC_CAP_INCOMPAT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CACC_CAP_COMPAT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CACC_CAP_COMPAT::ordt_rg_NVDLA_CFGROM_CFGROM_CACC_CAP_COMPAT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CACC_CAP_COMPAT(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_CAP_COMPAT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_CAP_COMPAT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_CAP_COMPAT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_CAP_COMPAT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CACC_CAP_COMPAT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_CAP_COMPAT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_CAP_COMPAT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_CAP_COMPAT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_CAP_COMPAT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CACC_CAP_COMPAT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_FEATURE_TYPES methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_FEATURE_TYPES::ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_FEATURE_TYPES(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CACC_BASE_FEATURE_TYPES(0, 12, 0x10, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_FEATURE_TYPES::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_FEATURE_TYPES at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_FEATURE_TYPES\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_FEATURE_TYPES::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CACC_BASE_FEATURE_TYPES.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_FEATURE_TYPES::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_FEATURE_TYPES at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_FEATURE_TYPES\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_FEATURE_TYPES::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CACC_BASE_FEATURE_TYPES.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_WEIGHT_TYPES methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_WEIGHT_TYPES::ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_WEIGHT_TYPES(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CACC_BASE_WEIGHT_TYPES(0, 12, 0x10, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_WEIGHT_TYPES::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_WEIGHT_TYPES at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_WEIGHT_TYPES\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_WEIGHT_TYPES::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CACC_BASE_WEIGHT_TYPES.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_WEIGHT_TYPES::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_WEIGHT_TYPES at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_WEIGHT_TYPES\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_WEIGHT_TYPES::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CACC_BASE_WEIGHT_TYPES.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_ATOMIC_C methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_ATOMIC_C::ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_ATOMIC_C(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CACC_BASE_ATOMIC_C(0, 32, 0x8, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_ATOMIC_C::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_ATOMIC_C at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_ATOMIC_C\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_ATOMIC_C::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CACC_BASE_ATOMIC_C.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_ATOMIC_C::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_ATOMIC_C at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_ATOMIC_C\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_ATOMIC_C::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CACC_BASE_ATOMIC_C.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_ATOMIC_K methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_ATOMIC_K::ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_ATOMIC_K(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CACC_BASE_ATOMIC_K(0, 32, 0x8, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_ATOMIC_K::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_ATOMIC_K at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_ATOMIC_K\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_ATOMIC_K::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CACC_BASE_ATOMIC_K.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_ATOMIC_K::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_ATOMIC_K at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_ATOMIC_K\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_ATOMIC_K::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CACC_BASE_ATOMIC_K.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_CDMA_ID methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_CDMA_ID::ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_CDMA_ID(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CACC_BASE_CDMA_ID(0, 32, 0x3, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_CDMA_ID::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_CDMA_ID at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_CDMA_ID\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_CDMA_ID::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CACC_BASE_CDMA_ID.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_CDMA_ID::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_CDMA_ID at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_CDMA_ID\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_BASE_CDMA_ID::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CACC_BASE_CDMA_ID.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CACC_MULTI_BATCH_MAX methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CACC_MULTI_BATCH_MAX::ordt_rg_NVDLA_CFGROM_CFGROM_CACC_MULTI_BATCH_MAX(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CACC_MULTI_BATCH_MAX(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_MULTI_BATCH_MAX::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_MULTI_BATCH_MAX at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_MULTI_BATCH_MAX\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_MULTI_BATCH_MAX::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CACC_MULTI_BATCH_MAX.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_MULTI_BATCH_MAX::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_MULTI_BATCH_MAX at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CACC_MULTI_BATCH_MAX\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CACC_MULTI_BATCH_MAX::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CACC_MULTI_BATCH_MAX.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_DESC methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_DESC::ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_DESC(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    SDP_RDMA_DESC(0, 32, 0xe0008, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_DESC::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_DESC at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_DESC\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_DESC::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  SDP_RDMA_DESC.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_DESC::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_DESC at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_DESC\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_DESC::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  SDP_RDMA_DESC.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_CAP_INCOMPAT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_CAP_INCOMPAT::ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_CAP_INCOMPAT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    SDP_RDMA_CAP_INCOMPAT(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_CAP_INCOMPAT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_CAP_INCOMPAT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_CAP_INCOMPAT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_CAP_INCOMPAT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  SDP_RDMA_CAP_INCOMPAT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_CAP_INCOMPAT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_CAP_INCOMPAT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_CAP_INCOMPAT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_CAP_INCOMPAT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  SDP_RDMA_CAP_INCOMPAT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_CAP_COMPAT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_CAP_COMPAT::ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_CAP_COMPAT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    SDP_RDMA_CAP_COMPAT(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_CAP_COMPAT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_CAP_COMPAT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_CAP_COMPAT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_CAP_COMPAT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  SDP_RDMA_CAP_COMPAT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_CAP_COMPAT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_CAP_COMPAT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_CAP_COMPAT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_CAP_COMPAT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  SDP_RDMA_CAP_COMPAT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_BASE_ATOMIC_M methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_BASE_ATOMIC_M::ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_BASE_ATOMIC_M(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    SDP_RDMA_BASE_ATOMIC_M(0, 32, 0x8, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_BASE_ATOMIC_M::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_BASE_ATOMIC_M at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_BASE_ATOMIC_M\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_BASE_ATOMIC_M::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  SDP_RDMA_BASE_ATOMIC_M.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_BASE_ATOMIC_M::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_BASE_ATOMIC_M at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_BASE_ATOMIC_M\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_BASE_ATOMIC_M::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  SDP_RDMA_BASE_ATOMIC_M.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_BASE_SDP_ID methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_BASE_SDP_ID::ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_BASE_SDP_ID(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    SDP_RDMA_BASE_SDP_ID(0, 32, 0x9, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_BASE_SDP_ID::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_BASE_SDP_ID at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_BASE_SDP_ID\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_BASE_SDP_ID::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  SDP_RDMA_BASE_SDP_ID.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_BASE_SDP_ID::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_BASE_SDP_ID at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_BASE_SDP_ID\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_RDMA_BASE_SDP_ID::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  SDP_RDMA_BASE_SDP_ID.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_SDP_DESC methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_SDP_DESC::ordt_rg_NVDLA_CFGROM_CFGROM_SDP_DESC(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    SDP_DESC(0, 32, 0x200009, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_DESC::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_DESC at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_DESC\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_DESC::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  SDP_DESC.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_DESC::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_DESC at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_DESC\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_DESC::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  SDP_DESC.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_SDP_CAP_INCOMPAT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_SDP_CAP_INCOMPAT::ordt_rg_NVDLA_CFGROM_CFGROM_SDP_CAP_INCOMPAT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    SDP_CAP_INCOMPAT(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_CAP_INCOMPAT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_CAP_INCOMPAT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_CAP_INCOMPAT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_CAP_INCOMPAT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  SDP_CAP_INCOMPAT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_CAP_INCOMPAT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_CAP_INCOMPAT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_CAP_INCOMPAT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_CAP_INCOMPAT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  SDP_CAP_INCOMPAT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_SDP_CAP_COMPAT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_SDP_CAP_COMPAT::ordt_rg_NVDLA_CFGROM_CFGROM_SDP_CAP_COMPAT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    SDP_CAP_COMPAT(0, 32, 0x18, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_CAP_COMPAT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_CAP_COMPAT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_CAP_COMPAT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_CAP_COMPAT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  SDP_CAP_COMPAT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_CAP_COMPAT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_CAP_COMPAT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_CAP_COMPAT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_CAP_COMPAT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  SDP_CAP_COMPAT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_FEATURE_TYPES methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_FEATURE_TYPES::ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_FEATURE_TYPES(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    SDP_BASE_FEATURE_TYPES(0, 12, 0x10, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_FEATURE_TYPES::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_FEATURE_TYPES at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_FEATURE_TYPES\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_FEATURE_TYPES::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  SDP_BASE_FEATURE_TYPES.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_FEATURE_TYPES::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_FEATURE_TYPES at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_FEATURE_TYPES\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_FEATURE_TYPES::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  SDP_BASE_FEATURE_TYPES.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_WEIGHT_TYPES methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_WEIGHT_TYPES::ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_WEIGHT_TYPES(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    SDP_BASE_WEIGHT_TYPES(0, 12, 0x10, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_WEIGHT_TYPES::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_WEIGHT_TYPES at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_WEIGHT_TYPES\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_WEIGHT_TYPES::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  SDP_BASE_WEIGHT_TYPES.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_WEIGHT_TYPES::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_WEIGHT_TYPES at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_WEIGHT_TYPES\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_WEIGHT_TYPES::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  SDP_BASE_WEIGHT_TYPES.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_CDMA_ID methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_CDMA_ID::ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_CDMA_ID(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    SDP_BASE_CDMA_ID(0, 32, 0x3, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_CDMA_ID::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_CDMA_ID at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_CDMA_ID\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_CDMA_ID::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  SDP_BASE_CDMA_ID.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_CDMA_ID::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_CDMA_ID at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_CDMA_ID\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BASE_CDMA_ID::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  SDP_BASE_CDMA_ID.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_SDP_MULTI_BATCH_MAX methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_SDP_MULTI_BATCH_MAX::ordt_rg_NVDLA_CFGROM_CFGROM_SDP_MULTI_BATCH_MAX(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    SDP_MULTI_BATCH_MAX(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_MULTI_BATCH_MAX::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_MULTI_BATCH_MAX at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_MULTI_BATCH_MAX\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_MULTI_BATCH_MAX::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  SDP_MULTI_BATCH_MAX.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_MULTI_BATCH_MAX::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_MULTI_BATCH_MAX at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_MULTI_BATCH_MAX\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_MULTI_BATCH_MAX::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  SDP_MULTI_BATCH_MAX.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BS_THROUGHPUT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BS_THROUGHPUT::ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BS_THROUGHPUT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    SDP_BS_THROUGHPUT(0, 32, 0x1, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BS_THROUGHPUT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BS_THROUGHPUT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BS_THROUGHPUT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BS_THROUGHPUT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  SDP_BS_THROUGHPUT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BS_THROUGHPUT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BS_THROUGHPUT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BS_THROUGHPUT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BS_THROUGHPUT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  SDP_BS_THROUGHPUT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BN_THROUGHPUT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BN_THROUGHPUT::ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BN_THROUGHPUT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    SDP_BN_THROUGHPUT(0, 32, 0x1, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BN_THROUGHPUT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BN_THROUGHPUT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BN_THROUGHPUT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BN_THROUGHPUT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  SDP_BN_THROUGHPUT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BN_THROUGHPUT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BN_THROUGHPUT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BN_THROUGHPUT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_BN_THROUGHPUT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  SDP_BN_THROUGHPUT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_SDP_EW_THROUGHPUT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_SDP_EW_THROUGHPUT::ordt_rg_NVDLA_CFGROM_CFGROM_SDP_EW_THROUGHPUT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    SDP_EW_THROUGHPUT(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_EW_THROUGHPUT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_EW_THROUGHPUT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_EW_THROUGHPUT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_EW_THROUGHPUT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  SDP_EW_THROUGHPUT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_EW_THROUGHPUT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_EW_THROUGHPUT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_SDP_EW_THROUGHPUT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_SDP_EW_THROUGHPUT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  SDP_EW_THROUGHPUT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_DESC methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_DESC::ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_DESC(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    PDP_RDMA_DESC(0, 32, 0xe000a, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_DESC::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_DESC at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_DESC\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_DESC::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  PDP_RDMA_DESC.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_DESC::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_DESC at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_DESC\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_DESC::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  PDP_RDMA_DESC.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_CAP_INCOMPAT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_CAP_INCOMPAT::ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_CAP_INCOMPAT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    PDP_RDMA_CAP_INCOMPAT(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_CAP_INCOMPAT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_CAP_INCOMPAT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_CAP_INCOMPAT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_CAP_INCOMPAT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  PDP_RDMA_CAP_INCOMPAT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_CAP_INCOMPAT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_CAP_INCOMPAT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_CAP_INCOMPAT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_CAP_INCOMPAT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  PDP_RDMA_CAP_INCOMPAT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_CAP_COMPAT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_CAP_COMPAT::ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_CAP_COMPAT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    PDP_RDMA_CAP_COMPAT(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_CAP_COMPAT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_CAP_COMPAT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_CAP_COMPAT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_CAP_COMPAT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  PDP_RDMA_CAP_COMPAT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_CAP_COMPAT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_CAP_COMPAT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_CAP_COMPAT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_CAP_COMPAT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  PDP_RDMA_CAP_COMPAT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_BASE_ATOMIC_M methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_BASE_ATOMIC_M::ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_BASE_ATOMIC_M(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    PDP_RDMA_BASE_ATOMIC_M(0, 32, 0x8, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_BASE_ATOMIC_M::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_BASE_ATOMIC_M at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_BASE_ATOMIC_M\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_BASE_ATOMIC_M::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  PDP_RDMA_BASE_ATOMIC_M.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_BASE_ATOMIC_M::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_BASE_ATOMIC_M at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_BASE_ATOMIC_M\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_BASE_ATOMIC_M::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  PDP_RDMA_BASE_ATOMIC_M.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_BASE_PDP_ID methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_BASE_PDP_ID::ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_BASE_PDP_ID(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    PDP_RDMA_BASE_PDP_ID(0, 32, 0xb, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_BASE_PDP_ID::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_BASE_PDP_ID at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_BASE_PDP_ID\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_BASE_PDP_ID::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  PDP_RDMA_BASE_PDP_ID.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_BASE_PDP_ID::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_BASE_PDP_ID at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_BASE_PDP_ID\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_RDMA_BASE_PDP_ID::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  PDP_RDMA_BASE_PDP_ID.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_PDP_DESC methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_PDP_DESC::ordt_rg_NVDLA_CFGROM_CFGROM_PDP_DESC(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    PDP_DESC(0, 32, 0x10000b, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_DESC::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_DESC at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_DESC\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_DESC::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  PDP_DESC.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_DESC::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_DESC at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_DESC\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_DESC::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  PDP_DESC.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_PDP_CAP_INCOMPAT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_PDP_CAP_INCOMPAT::ordt_rg_NVDLA_CFGROM_CFGROM_PDP_CAP_INCOMPAT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    PDP_CAP_INCOMPAT(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_CAP_INCOMPAT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_CAP_INCOMPAT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_CAP_INCOMPAT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_CAP_INCOMPAT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  PDP_CAP_INCOMPAT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_CAP_INCOMPAT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_CAP_INCOMPAT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_CAP_INCOMPAT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_CAP_INCOMPAT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  PDP_CAP_INCOMPAT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_PDP_CAP_COMPAT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_PDP_CAP_COMPAT::ordt_rg_NVDLA_CFGROM_CFGROM_PDP_CAP_COMPAT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    PDP_CAP_COMPAT(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_CAP_COMPAT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_CAP_COMPAT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_CAP_COMPAT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_CAP_COMPAT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  PDP_CAP_COMPAT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_CAP_COMPAT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_CAP_COMPAT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_CAP_COMPAT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_CAP_COMPAT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  PDP_CAP_COMPAT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_PDP_BASE_FEATURE_TYPES methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_PDP_BASE_FEATURE_TYPES::ordt_rg_NVDLA_CFGROM_CFGROM_PDP_BASE_FEATURE_TYPES(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    PDP_BASE_FEATURE_TYPES(0, 12, 0x10, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_BASE_FEATURE_TYPES::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_BASE_FEATURE_TYPES at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_BASE_FEATURE_TYPES\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_BASE_FEATURE_TYPES::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  PDP_BASE_FEATURE_TYPES.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_BASE_FEATURE_TYPES::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_BASE_FEATURE_TYPES at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_BASE_FEATURE_TYPES\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_BASE_FEATURE_TYPES::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  PDP_BASE_FEATURE_TYPES.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_PDP_BASE_THROUGHPUT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_PDP_BASE_THROUGHPUT::ordt_rg_NVDLA_CFGROM_CFGROM_PDP_BASE_THROUGHPUT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    PDP_BASE_THROUGHPUT(0, 32, 0x1, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_BASE_THROUGHPUT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_BASE_THROUGHPUT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_BASE_THROUGHPUT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_BASE_THROUGHPUT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  PDP_BASE_THROUGHPUT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_BASE_THROUGHPUT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_BASE_THROUGHPUT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_PDP_BASE_THROUGHPUT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_PDP_BASE_THROUGHPUT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  PDP_BASE_THROUGHPUT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_DESC methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_DESC::ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_DESC(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CDP_RDMA_DESC(0, 32, 0xe000c, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_DESC::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_DESC at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_DESC\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_DESC::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CDP_RDMA_DESC.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_DESC::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_DESC at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_DESC\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_DESC::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CDP_RDMA_DESC.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_CAP_INCOMPAT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_CAP_INCOMPAT::ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_CAP_INCOMPAT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CDP_RDMA_CAP_INCOMPAT(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_CAP_INCOMPAT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_CAP_INCOMPAT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_CAP_INCOMPAT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_CAP_INCOMPAT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CDP_RDMA_CAP_INCOMPAT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_CAP_INCOMPAT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_CAP_INCOMPAT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_CAP_INCOMPAT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_CAP_INCOMPAT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CDP_RDMA_CAP_INCOMPAT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_CAP_COMPAT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_CAP_COMPAT::ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_CAP_COMPAT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CDP_RDMA_CAP_COMPAT(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_CAP_COMPAT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_CAP_COMPAT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_CAP_COMPAT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_CAP_COMPAT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CDP_RDMA_CAP_COMPAT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_CAP_COMPAT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_CAP_COMPAT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_CAP_COMPAT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_CAP_COMPAT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CDP_RDMA_CAP_COMPAT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_BASE_ATOMIC_M methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_BASE_ATOMIC_M::ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_BASE_ATOMIC_M(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CDP_RDMA_BASE_ATOMIC_M(0, 32, 0x8, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_BASE_ATOMIC_M::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_BASE_ATOMIC_M at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_BASE_ATOMIC_M\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_BASE_ATOMIC_M::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CDP_RDMA_BASE_ATOMIC_M.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_BASE_ATOMIC_M::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_BASE_ATOMIC_M at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_BASE_ATOMIC_M\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_BASE_ATOMIC_M::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CDP_RDMA_BASE_ATOMIC_M.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_BASE_CDP_ID methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_BASE_CDP_ID::ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_BASE_CDP_ID(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CDP_RDMA_BASE_CDP_ID(0, 32, 0xd, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_BASE_CDP_ID::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_BASE_CDP_ID at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_BASE_CDP_ID\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_BASE_CDP_ID::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CDP_RDMA_BASE_CDP_ID.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_BASE_CDP_ID::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_BASE_CDP_ID at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_BASE_CDP_ID\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_RDMA_BASE_CDP_ID::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CDP_RDMA_BASE_CDP_ID.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CDP_DESC methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CDP_DESC::ordt_rg_NVDLA_CFGROM_CFGROM_CDP_DESC(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CDP_DESC(0, 32, 0x10000d, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_DESC::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_DESC at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_DESC\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_DESC::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CDP_DESC.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_DESC::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_DESC at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_DESC\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_DESC::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CDP_DESC.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CDP_CAP_INCOMPAT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CDP_CAP_INCOMPAT::ordt_rg_NVDLA_CFGROM_CFGROM_CDP_CAP_INCOMPAT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CDP_CAP_INCOMPAT(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_CAP_INCOMPAT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_CAP_INCOMPAT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_CAP_INCOMPAT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_CAP_INCOMPAT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CDP_CAP_INCOMPAT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_CAP_INCOMPAT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_CAP_INCOMPAT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_CAP_INCOMPAT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_CAP_INCOMPAT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CDP_CAP_INCOMPAT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CDP_CAP_COMPAT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CDP_CAP_COMPAT::ordt_rg_NVDLA_CFGROM_CFGROM_CDP_CAP_COMPAT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CDP_CAP_COMPAT(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_CAP_COMPAT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_CAP_COMPAT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_CAP_COMPAT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_CAP_COMPAT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CDP_CAP_COMPAT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_CAP_COMPAT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_CAP_COMPAT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_CAP_COMPAT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_CAP_COMPAT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CDP_CAP_COMPAT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CDP_BASE_FEATURE_TYPES methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CDP_BASE_FEATURE_TYPES::ordt_rg_NVDLA_CFGROM_CFGROM_CDP_BASE_FEATURE_TYPES(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CDP_BASE_FEATURE_TYPES(0, 12, 0x10, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_BASE_FEATURE_TYPES::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_BASE_FEATURE_TYPES at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_BASE_FEATURE_TYPES\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_BASE_FEATURE_TYPES::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CDP_BASE_FEATURE_TYPES.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_BASE_FEATURE_TYPES::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_BASE_FEATURE_TYPES at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_BASE_FEATURE_TYPES\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_BASE_FEATURE_TYPES::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CDP_BASE_FEATURE_TYPES.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_CDP_BASE_THROUGHPUT methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_CDP_BASE_THROUGHPUT::ordt_rg_NVDLA_CFGROM_CFGROM_CDP_BASE_THROUGHPUT(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    CDP_BASE_THROUGHPUT(0, 32, 0x1, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_BASE_THROUGHPUT::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_BASE_THROUGHPUT at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_BASE_THROUGHPUT\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_BASE_THROUGHPUT::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  CDP_BASE_THROUGHPUT.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_BASE_THROUGHPUT::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_BASE_THROUGHPUT at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_CDP_BASE_THROUGHPUT\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_CDP_BASE_THROUGHPUT::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  CDP_BASE_THROUGHPUT.read(rdata);
}

// ------------------ ordt_rg_NVDLA_CFGROM_CFGROM_END_OF_LIST methods ------------------

ordt_rg_NVDLA_CFGROM_CFGROM_END_OF_LIST::ordt_rg_NVDLA_CFGROM_CFGROM_END_OF_LIST(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_reg(_m_startaddress, _m_endaddress),
    END_OF_LIST(0, 32, 0x0, r_std, w_none) {
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_END_OF_LIST::write(const uint64_t &addr, const ordt_data &wdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write of reg ordt_rg_NVDLA_CFGROM_CFGROM_END_OF_LIST at addr="<< addr << ", data=" << wdata.to_string() << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->write(wdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> write to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_END_OF_LIST\n";
  #endif
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_END_OF_LIST::write(const ordt_data &wdata) {
  std::lock_guard<std::mutex> m_guard(m_mutex);
  END_OF_LIST.write(wdata);
}

int  ordt_rg_NVDLA_CFGROM_CFGROM_END_OF_LIST::read(const uint64_t &addr, ordt_data &rdata) {
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read of reg ordt_rg_NVDLA_CFGROM_CFGROM_END_OF_LIST at addr="<< addr << "\n";
  #endif
     if (this->hasStartAddress(addr)) {
        this->read(rdata);
        return 0;
     }
  #ifdef ORDT_PIO_VERBOSE
     std::cout << "--> read to invalid address " << addr << " in reg ordt_rg_NVDLA_CFGROM_CFGROM_END_OF_LIST\n";
  #endif
     rdata.clear();
     return 8;
}

void  ordt_rg_NVDLA_CFGROM_CFGROM_END_OF_LIST::read(ordt_data &rdata) {
  rdata.clear();
  for (int widx=0; widx<((m_endaddress - m_startaddress + 1)/4); widx++) rdata.push_back(0);
  END_OF_LIST.read(rdata);
}

// ------------------ ordt_rset_NVDLA_CFGROM methods ------------------

ordt_rset_NVDLA_CFGROM::ordt_rset_NVDLA_CFGROM(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_regset(_m_startaddress, _m_endaddress),
    CFGROM_HW_VERSION(_m_startaddress + 0x0, _m_startaddress + 0x3),
    CFGROM_GLB_DESC(_m_startaddress + 0x4, _m_startaddress + 0x7),
    CFGROM_CIF_DESC(_m_startaddress + 0x8, _m_startaddress + 0xb),
    CFGROM_CIF_CAP_INCOMPAT(_m_startaddress + 0xc, _m_startaddress + 0xf),
    CFGROM_CIF_CAP_COMPAT(_m_startaddress + 0x10, _m_startaddress + 0x13),
    CFGROM_CIF_BASE_WIDTH(_m_startaddress + 0x14, _m_startaddress + 0x17),
    CFGROM_CIF_BASE_LATENCY(_m_startaddress + 0x18, _m_startaddress + 0x1b),
    CFGROM_CIF_BASE_BURST_LENGTH_MAX(_m_startaddress + 0x1c, _m_startaddress + 0x1f),
    CFGROM_CIF_BASE_MEM_ADDR_WIDTH(_m_startaddress + 0x20, _m_startaddress + 0x23),
    CFGROM_CDMA_DESC(_m_startaddress + 0x24, _m_startaddress + 0x27),
    CFGROM_CDMA_CAP_INCOMPAT(_m_startaddress + 0x28, _m_startaddress + 0x2b),
    CFGROM_CDMA_CAP_COMPAT(_m_startaddress + 0x2c, _m_startaddress + 0x2f),
    CFGROM_CDMA_BASE_FEATURE_TYPES(_m_startaddress + 0x30, _m_startaddress + 0x33),
    CFGROM_CDMA_BASE_WEIGHT_TYPES(_m_startaddress + 0x34, _m_startaddress + 0x37),
    CFGROM_CDMA_BASE_ATOMIC_C(_m_startaddress + 0x38, _m_startaddress + 0x3b),
    CFGROM_CDMA_BASE_ATOMIC_K(_m_startaddress + 0x3c, _m_startaddress + 0x3f),
    CFGROM_CDMA_BASE_ATOMIC_M(_m_startaddress + 0x40, _m_startaddress + 0x43),
    CFGROM_CDMA_BASE_CBUF_BANK_NUM(_m_startaddress + 0x44, _m_startaddress + 0x47),
    CFGROM_CDMA_BASE_CBUF_BANK_WIDTH(_m_startaddress + 0x48, _m_startaddress + 0x4b),
    CFGROM_CDMA_BASE_CBUF_BANK_DEPTH(_m_startaddress + 0x4c, _m_startaddress + 0x4f),
    CFGROM_CDMA_MULTI_BATCH_MAX(_m_startaddress + 0x50, _m_startaddress + 0x53),
    CFGROM_CDMA_IMAGE_IN_FORMATS_PACKED(_m_startaddress + 0x54, _m_startaddress + 0x57),
    CFGROM_CDMA_IMAGE_IN_FORMATS_SEMI(_m_startaddress + 0x58, _m_startaddress + 0x5b),
    CFGROM_CBUF_DESC(_m_startaddress + 0x5c, _m_startaddress + 0x5f),
    CFGROM_CBUF_CAP_INCOMPAT(_m_startaddress + 0x60, _m_startaddress + 0x63),
    CFGROM_CBUF_CAP_COMPAT(_m_startaddress + 0x64, _m_startaddress + 0x67),
    CFGROM_CBUF_BASE_CBUF_BANK_NUM(_m_startaddress + 0x68, _m_startaddress + 0x6b),
    CFGROM_CBUF_BASE_CBUF_BANK_WIDTH(_m_startaddress + 0x6c, _m_startaddress + 0x6f),
    CFGROM_CBUF_BASE_CBUF_BANK_DEPTH(_m_startaddress + 0x70, _m_startaddress + 0x73),
    CFGROM_CBUF_BASE_CDMA_ID(_m_startaddress + 0x74, _m_startaddress + 0x77),
    CFGROM_CSC_DESC(_m_startaddress + 0x78, _m_startaddress + 0x7b),
    CFGROM_CSC_CAP_INCOMPAT(_m_startaddress + 0x7c, _m_startaddress + 0x7f),
    CFGROM_CSC_CAP_COMPAT(_m_startaddress + 0x80, _m_startaddress + 0x83),
    CFGROM_CSC_BASE_FEATURE_TYPES(_m_startaddress + 0x84, _m_startaddress + 0x87),
    CFGROM_CSC_BASE_WEIGHT_TYPES(_m_startaddress + 0x88, _m_startaddress + 0x8b),
    CFGROM_CSC_BASE_ATOMIC_C(_m_startaddress + 0x8c, _m_startaddress + 0x8f),
    CFGROM_CSC_BASE_ATOMIC_K(_m_startaddress + 0x90, _m_startaddress + 0x93),
    CFGROM_CSC_BASE_ATOMIC_M(_m_startaddress + 0x94, _m_startaddress + 0x97),
    CFGROM_CSC_BASE_CBUF_BANK_NUM(_m_startaddress + 0x98, _m_startaddress + 0x9b),
    CFGROM_CSC_BASE_CBUF_BANK_WIDTH(_m_startaddress + 0x9c, _m_startaddress + 0x9f),
    CFGROM_CSC_BASE_CBUF_BANK_DEPTH(_m_startaddress + 0xa0, _m_startaddress + 0xa3),
    CFGROM_CSC_BASE_CDMA_ID(_m_startaddress + 0xa4, _m_startaddress + 0xa7),
    CFGROM_CSC_MULTI_BATCH_MAX(_m_startaddress + 0xa8, _m_startaddress + 0xab),
    CFGROM_CMAC_A_DESC(_m_startaddress + 0xac, _m_startaddress + 0xaf),
    CFGROM_CMAC_A_CAP_INCOMPAT(_m_startaddress + 0xb0, _m_startaddress + 0xb3),
    CFGROM_CMAC_A_CAP_COMPAT(_m_startaddress + 0xb4, _m_startaddress + 0xb7),
    CFGROM_CMAC_A_BASE_FEATURE_TYPES(_m_startaddress + 0xb8, _m_startaddress + 0xbb),
    CFGROM_CMAC_A_BASE_WEIGHT_TYPES(_m_startaddress + 0xbc, _m_startaddress + 0xbf),
    CFGROM_CMAC_A_BASE_ATOMIC_C(_m_startaddress + 0xc0, _m_startaddress + 0xc3),
    CFGROM_CMAC_A_BASE_ATOMIC_K(_m_startaddress + 0xc4, _m_startaddress + 0xc7),
    CFGROM_CMAC_A_BASE_CDMA_ID(_m_startaddress + 0xc8, _m_startaddress + 0xcb),
    CFGROM_CMAC_B_DESC(_m_startaddress + 0xcc, _m_startaddress + 0xcf),
    CFGROM_CMAC_B_CAP_INCOMPAT(_m_startaddress + 0xd0, _m_startaddress + 0xd3),
    CFGROM_CMAC_B_CAP_COMPAT(_m_startaddress + 0xd4, _m_startaddress + 0xd7),
    CFGROM_CMAC_B_BASE_FEATURE_TYPES(_m_startaddress + 0xd8, _m_startaddress + 0xdb),
    CFGROM_CMAC_B_BASE_WEIGHT_TYPES(_m_startaddress + 0xdc, _m_startaddress + 0xdf),
    CFGROM_CMAC_B_BASE_ATOMIC_C(_m_startaddress + 0xe0, _m_startaddress + 0xe3),
    CFGROM_CMAC_B_BASE_ATOMIC_K(_m_startaddress + 0xe4, _m_startaddress + 0xe7),
    CFGROM_CMAC_B_BASE_CDMA_ID(_m_startaddress + 0xe8, _m_startaddress + 0xeb),
    CFGROM_CACC_DESC(_m_startaddress + 0xec, _m_startaddress + 0xef),
    CFGROM_CACC_CAP_INCOMPAT(_m_startaddress + 0xf0, _m_startaddress + 0xf3),
    CFGROM_CACC_CAP_COMPAT(_m_startaddress + 0xf4, _m_startaddress + 0xf7),
    CFGROM_CACC_BASE_FEATURE_TYPES(_m_startaddress + 0xf8, _m_startaddress + 0xfb),
    CFGROM_CACC_BASE_WEIGHT_TYPES(_m_startaddress + 0xfc, _m_startaddress + 0xff),
    CFGROM_CACC_BASE_ATOMIC_C(_m_startaddress + 0x100, _m_startaddress + 0x103),
    CFGROM_CACC_BASE_ATOMIC_K(_m_startaddress + 0x104, _m_startaddress + 0x107),
    CFGROM_CACC_BASE_CDMA_ID(_m_startaddress + 0x108, _m_startaddress + 0x10b),
    CFGROM_CACC_MULTI_BATCH_MAX(_m_startaddress + 0x10c, _m_startaddress + 0x10f),
    CFGROM_SDP_RDMA_DESC(_m_startaddress + 0x110, _m_startaddress + 0x113),
    CFGROM_SDP_RDMA_CAP_INCOMPAT(_m_startaddress + 0x114, _m_startaddress + 0x117),
    CFGROM_SDP_RDMA_CAP_COMPAT(_m_startaddress + 0x118, _m_startaddress + 0x11b),
    CFGROM_SDP_RDMA_BASE_ATOMIC_M(_m_startaddress + 0x11c, _m_startaddress + 0x11f),
    CFGROM_SDP_RDMA_BASE_SDP_ID(_m_startaddress + 0x120, _m_startaddress + 0x123),
    CFGROM_SDP_DESC(_m_startaddress + 0x124, _m_startaddress + 0x127),
    CFGROM_SDP_CAP_INCOMPAT(_m_startaddress + 0x128, _m_startaddress + 0x12b),
    CFGROM_SDP_CAP_COMPAT(_m_startaddress + 0x12c, _m_startaddress + 0x12f),
    CFGROM_SDP_BASE_FEATURE_TYPES(_m_startaddress + 0x130, _m_startaddress + 0x133),
    CFGROM_SDP_BASE_WEIGHT_TYPES(_m_startaddress + 0x134, _m_startaddress + 0x137),
    CFGROM_SDP_BASE_CDMA_ID(_m_startaddress + 0x138, _m_startaddress + 0x13b),
    CFGROM_SDP_MULTI_BATCH_MAX(_m_startaddress + 0x13c, _m_startaddress + 0x13f),
    CFGROM_SDP_BS_THROUGHPUT(_m_startaddress + 0x140, _m_startaddress + 0x143),
    CFGROM_SDP_BN_THROUGHPUT(_m_startaddress + 0x144, _m_startaddress + 0x147),
    CFGROM_SDP_EW_THROUGHPUT(_m_startaddress + 0x148, _m_startaddress + 0x14b),
    CFGROM_PDP_RDMA_DESC(_m_startaddress + 0x14c, _m_startaddress + 0x14f),
    CFGROM_PDP_RDMA_CAP_INCOMPAT(_m_startaddress + 0x150, _m_startaddress + 0x153),
    CFGROM_PDP_RDMA_CAP_COMPAT(_m_startaddress + 0x154, _m_startaddress + 0x157),
    CFGROM_PDP_RDMA_BASE_ATOMIC_M(_m_startaddress + 0x158, _m_startaddress + 0x15b),
    CFGROM_PDP_RDMA_BASE_PDP_ID(_m_startaddress + 0x15c, _m_startaddress + 0x15f),
    CFGROM_PDP_DESC(_m_startaddress + 0x160, _m_startaddress + 0x163),
    CFGROM_PDP_CAP_INCOMPAT(_m_startaddress + 0x164, _m_startaddress + 0x167),
    CFGROM_PDP_CAP_COMPAT(_m_startaddress + 0x168, _m_startaddress + 0x16b),
    CFGROM_PDP_BASE_FEATURE_TYPES(_m_startaddress + 0x16c, _m_startaddress + 0x16f),
    CFGROM_PDP_BASE_THROUGHPUT(_m_startaddress + 0x170, _m_startaddress + 0x173),
    CFGROM_CDP_RDMA_DESC(_m_startaddress + 0x174, _m_startaddress + 0x177),
    CFGROM_CDP_RDMA_CAP_INCOMPAT(_m_startaddress + 0x178, _m_startaddress + 0x17b),
    CFGROM_CDP_RDMA_CAP_COMPAT(_m_startaddress + 0x17c, _m_startaddress + 0x17f),
    CFGROM_CDP_RDMA_BASE_ATOMIC_M(_m_startaddress + 0x180, _m_startaddress + 0x183),
    CFGROM_CDP_RDMA_BASE_CDP_ID(_m_startaddress + 0x184, _m_startaddress + 0x187),
    CFGROM_CDP_DESC(_m_startaddress + 0x188, _m_startaddress + 0x18b),
    CFGROM_CDP_CAP_INCOMPAT(_m_startaddress + 0x18c, _m_startaddress + 0x18f),
    CFGROM_CDP_CAP_COMPAT(_m_startaddress + 0x190, _m_startaddress + 0x193),
    CFGROM_CDP_BASE_FEATURE_TYPES(_m_startaddress + 0x194, _m_startaddress + 0x197),
    CFGROM_CDP_BASE_THROUGHPUT(_m_startaddress + 0x198, _m_startaddress + 0x19b),
    CFGROM_END_OF_LIST(_m_startaddress + 0x19c, _m_startaddress + 0x19f) {
  m_children.push_back(&CFGROM_HW_VERSION);
  m_children.push_back(&CFGROM_GLB_DESC);
  m_children.push_back(&CFGROM_CIF_DESC);
  m_children.push_back(&CFGROM_CIF_CAP_INCOMPAT);
  m_children.push_back(&CFGROM_CIF_CAP_COMPAT);
  m_children.push_back(&CFGROM_CIF_BASE_WIDTH);
  m_children.push_back(&CFGROM_CIF_BASE_LATENCY);
  m_children.push_back(&CFGROM_CIF_BASE_BURST_LENGTH_MAX);
  m_children.push_back(&CFGROM_CIF_BASE_MEM_ADDR_WIDTH);
  m_children.push_back(&CFGROM_CDMA_DESC);
  m_children.push_back(&CFGROM_CDMA_CAP_INCOMPAT);
  m_children.push_back(&CFGROM_CDMA_CAP_COMPAT);
  m_children.push_back(&CFGROM_CDMA_BASE_FEATURE_TYPES);
  m_children.push_back(&CFGROM_CDMA_BASE_WEIGHT_TYPES);
  m_children.push_back(&CFGROM_CDMA_BASE_ATOMIC_C);
  m_children.push_back(&CFGROM_CDMA_BASE_ATOMIC_K);
  m_children.push_back(&CFGROM_CDMA_BASE_ATOMIC_M);
  m_children.push_back(&CFGROM_CDMA_BASE_CBUF_BANK_NUM);
  m_children.push_back(&CFGROM_CDMA_BASE_CBUF_BANK_WIDTH);
  m_children.push_back(&CFGROM_CDMA_BASE_CBUF_BANK_DEPTH);
  m_children.push_back(&CFGROM_CDMA_MULTI_BATCH_MAX);
  m_children.push_back(&CFGROM_CDMA_IMAGE_IN_FORMATS_PACKED);
  m_children.push_back(&CFGROM_CDMA_IMAGE_IN_FORMATS_SEMI);
  m_children.push_back(&CFGROM_CBUF_DESC);
  m_children.push_back(&CFGROM_CBUF_CAP_INCOMPAT);
  m_children.push_back(&CFGROM_CBUF_CAP_COMPAT);
  m_children.push_back(&CFGROM_CBUF_BASE_CBUF_BANK_NUM);
  m_children.push_back(&CFGROM_CBUF_BASE_CBUF_BANK_WIDTH);
  m_children.push_back(&CFGROM_CBUF_BASE_CBUF_BANK_DEPTH);
  m_children.push_back(&CFGROM_CBUF_BASE_CDMA_ID);
  m_children.push_back(&CFGROM_CSC_DESC);
  m_children.push_back(&CFGROM_CSC_CAP_INCOMPAT);
  m_children.push_back(&CFGROM_CSC_CAP_COMPAT);
  m_children.push_back(&CFGROM_CSC_BASE_FEATURE_TYPES);
  m_children.push_back(&CFGROM_CSC_BASE_WEIGHT_TYPES);
  m_children.push_back(&CFGROM_CSC_BASE_ATOMIC_C);
  m_children.push_back(&CFGROM_CSC_BASE_ATOMIC_K);
  m_children.push_back(&CFGROM_CSC_BASE_ATOMIC_M);
  m_children.push_back(&CFGROM_CSC_BASE_CBUF_BANK_NUM);
  m_children.push_back(&CFGROM_CSC_BASE_CBUF_BANK_WIDTH);
  m_children.push_back(&CFGROM_CSC_BASE_CBUF_BANK_DEPTH);
  m_children.push_back(&CFGROM_CSC_BASE_CDMA_ID);
  m_children.push_back(&CFGROM_CSC_MULTI_BATCH_MAX);
  m_children.push_back(&CFGROM_CMAC_A_DESC);
  m_children.push_back(&CFGROM_CMAC_A_CAP_INCOMPAT);
  m_children.push_back(&CFGROM_CMAC_A_CAP_COMPAT);
  m_children.push_back(&CFGROM_CMAC_A_BASE_FEATURE_TYPES);
  m_children.push_back(&CFGROM_CMAC_A_BASE_WEIGHT_TYPES);
  m_children.push_back(&CFGROM_CMAC_A_BASE_ATOMIC_C);
  m_children.push_back(&CFGROM_CMAC_A_BASE_ATOMIC_K);
  m_children.push_back(&CFGROM_CMAC_A_BASE_CDMA_ID);
  m_children.push_back(&CFGROM_CMAC_B_DESC);
  m_children.push_back(&CFGROM_CMAC_B_CAP_INCOMPAT);
  m_children.push_back(&CFGROM_CMAC_B_CAP_COMPAT);
  m_children.push_back(&CFGROM_CMAC_B_BASE_FEATURE_TYPES);
  m_children.push_back(&CFGROM_CMAC_B_BASE_WEIGHT_TYPES);
  m_children.push_back(&CFGROM_CMAC_B_BASE_ATOMIC_C);
  m_children.push_back(&CFGROM_CMAC_B_BASE_ATOMIC_K);
  m_children.push_back(&CFGROM_CMAC_B_BASE_CDMA_ID);
  m_children.push_back(&CFGROM_CACC_DESC);
  m_children.push_back(&CFGROM_CACC_CAP_INCOMPAT);
  m_children.push_back(&CFGROM_CACC_CAP_COMPAT);
  m_children.push_back(&CFGROM_CACC_BASE_FEATURE_TYPES);
  m_children.push_back(&CFGROM_CACC_BASE_WEIGHT_TYPES);
  m_children.push_back(&CFGROM_CACC_BASE_ATOMIC_C);
  m_children.push_back(&CFGROM_CACC_BASE_ATOMIC_K);
  m_children.push_back(&CFGROM_CACC_BASE_CDMA_ID);
  m_children.push_back(&CFGROM_CACC_MULTI_BATCH_MAX);
  m_children.push_back(&CFGROM_SDP_RDMA_DESC);
  m_children.push_back(&CFGROM_SDP_RDMA_CAP_INCOMPAT);
  m_children.push_back(&CFGROM_SDP_RDMA_CAP_COMPAT);
  m_children.push_back(&CFGROM_SDP_RDMA_BASE_ATOMIC_M);
  m_children.push_back(&CFGROM_SDP_RDMA_BASE_SDP_ID);
  m_children.push_back(&CFGROM_SDP_DESC);
  m_children.push_back(&CFGROM_SDP_CAP_INCOMPAT);
  m_children.push_back(&CFGROM_SDP_CAP_COMPAT);
  m_children.push_back(&CFGROM_SDP_BASE_FEATURE_TYPES);
  m_children.push_back(&CFGROM_SDP_BASE_WEIGHT_TYPES);
  m_children.push_back(&CFGROM_SDP_BASE_CDMA_ID);
  m_children.push_back(&CFGROM_SDP_MULTI_BATCH_MAX);
  m_children.push_back(&CFGROM_SDP_BS_THROUGHPUT);
  m_children.push_back(&CFGROM_SDP_BN_THROUGHPUT);
  m_children.push_back(&CFGROM_SDP_EW_THROUGHPUT);
  m_children.push_back(&CFGROM_PDP_RDMA_DESC);
  m_children.push_back(&CFGROM_PDP_RDMA_CAP_INCOMPAT);
  m_children.push_back(&CFGROM_PDP_RDMA_CAP_COMPAT);
  m_children.push_back(&CFGROM_PDP_RDMA_BASE_ATOMIC_M);
  m_children.push_back(&CFGROM_PDP_RDMA_BASE_PDP_ID);
  m_children.push_back(&CFGROM_PDP_DESC);
  m_children.push_back(&CFGROM_PDP_CAP_INCOMPAT);
  m_children.push_back(&CFGROM_PDP_CAP_COMPAT);
  m_children.push_back(&CFGROM_PDP_BASE_FEATURE_TYPES);
  m_children.push_back(&CFGROM_PDP_BASE_THROUGHPUT);
  m_children.push_back(&CFGROM_CDP_RDMA_DESC);
  m_children.push_back(&CFGROM_CDP_RDMA_CAP_INCOMPAT);
  m_children.push_back(&CFGROM_CDP_RDMA_CAP_COMPAT);
  m_children.push_back(&CFGROM_CDP_RDMA_BASE_ATOMIC_M);
  m_children.push_back(&CFGROM_CDP_RDMA_BASE_CDP_ID);
  m_children.push_back(&CFGROM_CDP_DESC);
  m_children.push_back(&CFGROM_CDP_CAP_INCOMPAT);
  m_children.push_back(&CFGROM_CDP_CAP_COMPAT);
  m_children.push_back(&CFGROM_CDP_BASE_FEATURE_TYPES);
  m_children.push_back(&CFGROM_CDP_BASE_THROUGHPUT);
  m_children.push_back(&CFGROM_END_OF_LIST);
}

void  ordt_rset_NVDLA_CFGROM::update_child_ptrs() {
  m_children.clear();
  m_children.push_back(&CFGROM_HW_VERSION);
  m_children.push_back(&CFGROM_GLB_DESC);
  m_children.push_back(&CFGROM_CIF_DESC);
  m_children.push_back(&CFGROM_CIF_CAP_INCOMPAT);
  m_children.push_back(&CFGROM_CIF_CAP_COMPAT);
  m_children.push_back(&CFGROM_CIF_BASE_WIDTH);
  m_children.push_back(&CFGROM_CIF_BASE_LATENCY);
  m_children.push_back(&CFGROM_CIF_BASE_BURST_LENGTH_MAX);
  m_children.push_back(&CFGROM_CIF_BASE_MEM_ADDR_WIDTH);
  m_children.push_back(&CFGROM_CDMA_DESC);
  m_children.push_back(&CFGROM_CDMA_CAP_INCOMPAT);
  m_children.push_back(&CFGROM_CDMA_CAP_COMPAT);
  m_children.push_back(&CFGROM_CDMA_BASE_FEATURE_TYPES);
  m_children.push_back(&CFGROM_CDMA_BASE_WEIGHT_TYPES);
  m_children.push_back(&CFGROM_CDMA_BASE_ATOMIC_C);
  m_children.push_back(&CFGROM_CDMA_BASE_ATOMIC_K);
  m_children.push_back(&CFGROM_CDMA_BASE_ATOMIC_M);
  m_children.push_back(&CFGROM_CDMA_BASE_CBUF_BANK_NUM);
  m_children.push_back(&CFGROM_CDMA_BASE_CBUF_BANK_WIDTH);
  m_children.push_back(&CFGROM_CDMA_BASE_CBUF_BANK_DEPTH);
  m_children.push_back(&CFGROM_CDMA_MULTI_BATCH_MAX);
  m_children.push_back(&CFGROM_CDMA_IMAGE_IN_FORMATS_PACKED);
  m_children.push_back(&CFGROM_CDMA_IMAGE_IN_FORMATS_SEMI);
  m_children.push_back(&CFGROM_CBUF_DESC);
  m_children.push_back(&CFGROM_CBUF_CAP_INCOMPAT);
  m_children.push_back(&CFGROM_CBUF_CAP_COMPAT);
  m_children.push_back(&CFGROM_CBUF_BASE_CBUF_BANK_NUM);
  m_children.push_back(&CFGROM_CBUF_BASE_CBUF_BANK_WIDTH);
  m_children.push_back(&CFGROM_CBUF_BASE_CBUF_BANK_DEPTH);
  m_children.push_back(&CFGROM_CBUF_BASE_CDMA_ID);
  m_children.push_back(&CFGROM_CSC_DESC);
  m_children.push_back(&CFGROM_CSC_CAP_INCOMPAT);
  m_children.push_back(&CFGROM_CSC_CAP_COMPAT);
  m_children.push_back(&CFGROM_CSC_BASE_FEATURE_TYPES);
  m_children.push_back(&CFGROM_CSC_BASE_WEIGHT_TYPES);
  m_children.push_back(&CFGROM_CSC_BASE_ATOMIC_C);
  m_children.push_back(&CFGROM_CSC_BASE_ATOMIC_K);
  m_children.push_back(&CFGROM_CSC_BASE_ATOMIC_M);
  m_children.push_back(&CFGROM_CSC_BASE_CBUF_BANK_NUM);
  m_children.push_back(&CFGROM_CSC_BASE_CBUF_BANK_WIDTH);
  m_children.push_back(&CFGROM_CSC_BASE_CBUF_BANK_DEPTH);
  m_children.push_back(&CFGROM_CSC_BASE_CDMA_ID);
  m_children.push_back(&CFGROM_CSC_MULTI_BATCH_MAX);
  m_children.push_back(&CFGROM_CMAC_A_DESC);
  m_children.push_back(&CFGROM_CMAC_A_CAP_INCOMPAT);
  m_children.push_back(&CFGROM_CMAC_A_CAP_COMPAT);
  m_children.push_back(&CFGROM_CMAC_A_BASE_FEATURE_TYPES);
  m_children.push_back(&CFGROM_CMAC_A_BASE_WEIGHT_TYPES);
  m_children.push_back(&CFGROM_CMAC_A_BASE_ATOMIC_C);
  m_children.push_back(&CFGROM_CMAC_A_BASE_ATOMIC_K);
  m_children.push_back(&CFGROM_CMAC_A_BASE_CDMA_ID);
  m_children.push_back(&CFGROM_CMAC_B_DESC);
  m_children.push_back(&CFGROM_CMAC_B_CAP_INCOMPAT);
  m_children.push_back(&CFGROM_CMAC_B_CAP_COMPAT);
  m_children.push_back(&CFGROM_CMAC_B_BASE_FEATURE_TYPES);
  m_children.push_back(&CFGROM_CMAC_B_BASE_WEIGHT_TYPES);
  m_children.push_back(&CFGROM_CMAC_B_BASE_ATOMIC_C);
  m_children.push_back(&CFGROM_CMAC_B_BASE_ATOMIC_K);
  m_children.push_back(&CFGROM_CMAC_B_BASE_CDMA_ID);
  m_children.push_back(&CFGROM_CACC_DESC);
  m_children.push_back(&CFGROM_CACC_CAP_INCOMPAT);
  m_children.push_back(&CFGROM_CACC_CAP_COMPAT);
  m_children.push_back(&CFGROM_CACC_BASE_FEATURE_TYPES);
  m_children.push_back(&CFGROM_CACC_BASE_WEIGHT_TYPES);
  m_children.push_back(&CFGROM_CACC_BASE_ATOMIC_C);
  m_children.push_back(&CFGROM_CACC_BASE_ATOMIC_K);
  m_children.push_back(&CFGROM_CACC_BASE_CDMA_ID);
  m_children.push_back(&CFGROM_CACC_MULTI_BATCH_MAX);
  m_children.push_back(&CFGROM_SDP_RDMA_DESC);
  m_children.push_back(&CFGROM_SDP_RDMA_CAP_INCOMPAT);
  m_children.push_back(&CFGROM_SDP_RDMA_CAP_COMPAT);
  m_children.push_back(&CFGROM_SDP_RDMA_BASE_ATOMIC_M);
  m_children.push_back(&CFGROM_SDP_RDMA_BASE_SDP_ID);
  m_children.push_back(&CFGROM_SDP_DESC);
  m_children.push_back(&CFGROM_SDP_CAP_INCOMPAT);
  m_children.push_back(&CFGROM_SDP_CAP_COMPAT);
  m_children.push_back(&CFGROM_SDP_BASE_FEATURE_TYPES);
  m_children.push_back(&CFGROM_SDP_BASE_WEIGHT_TYPES);
  m_children.push_back(&CFGROM_SDP_BASE_CDMA_ID);
  m_children.push_back(&CFGROM_SDP_MULTI_BATCH_MAX);
  m_children.push_back(&CFGROM_SDP_BS_THROUGHPUT);
  m_children.push_back(&CFGROM_SDP_BN_THROUGHPUT);
  m_children.push_back(&CFGROM_SDP_EW_THROUGHPUT);
  m_children.push_back(&CFGROM_PDP_RDMA_DESC);
  m_children.push_back(&CFGROM_PDP_RDMA_CAP_INCOMPAT);
  m_children.push_back(&CFGROM_PDP_RDMA_CAP_COMPAT);
  m_children.push_back(&CFGROM_PDP_RDMA_BASE_ATOMIC_M);
  m_children.push_back(&CFGROM_PDP_RDMA_BASE_PDP_ID);
  m_children.push_back(&CFGROM_PDP_DESC);
  m_children.push_back(&CFGROM_PDP_CAP_INCOMPAT);
  m_children.push_back(&CFGROM_PDP_CAP_COMPAT);
  m_children.push_back(&CFGROM_PDP_BASE_FEATURE_TYPES);
  m_children.push_back(&CFGROM_PDP_BASE_THROUGHPUT);
  m_children.push_back(&CFGROM_CDP_RDMA_DESC);
  m_children.push_back(&CFGROM_CDP_RDMA_CAP_INCOMPAT);
  m_children.push_back(&CFGROM_CDP_RDMA_CAP_COMPAT);
  m_children.push_back(&CFGROM_CDP_RDMA_BASE_ATOMIC_M);
  m_children.push_back(&CFGROM_CDP_RDMA_BASE_CDP_ID);
  m_children.push_back(&CFGROM_CDP_DESC);
  m_children.push_back(&CFGROM_CDP_CAP_INCOMPAT);
  m_children.push_back(&CFGROM_CDP_CAP_COMPAT);
  m_children.push_back(&CFGROM_CDP_BASE_FEATURE_TYPES);
  m_children.push_back(&CFGROM_CDP_BASE_THROUGHPUT);
  m_children.push_back(&CFGROM_END_OF_LIST);
}

// ------------------ ordt_root methods ------------------

ordt_root::ordt_root()
  : ordt_root(0x0, 0x19f) {
}

ordt_root::ordt_root(uint64_t _m_startaddress, uint64_t _m_endaddress)
  : ordt_regset(_m_startaddress, _m_endaddress),
    NVDLA_CFGROM(_m_startaddress + 0x0, _m_startaddress + 0x1ff) {
  m_children.push_back(&NVDLA_CFGROM);
}

void  ordt_root::update_child_ptrs() {
  m_children.clear();
  m_children.push_back(&NVDLA_CFGROM);
}

