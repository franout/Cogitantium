// ================================================================
// NVDLA Open Source Project
//
// Copyright(c) 2016 - 2017 NVIDIA Corporation.  Licensed under the
// NVDLA Open Hardware License; Check "LICENSE" which comes with
// this distribution for more information.
// ================================================================

property spec_sw_default {
    type      = number;
    component = field;
};
property spec_access {
    type      = string;
    component = field;
};
property sw_default_mask {
    type      = number;
    component = field;
};
property reset_mask {
    type      = number;
    component = field;
};
regfile regs_NVDLA_CFGROM{
    default regwidth=32;
    reg {
        name = "CFGROM_HW_VERSION";
        desc = "";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x00010001;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } HW_VERSION[31:0];
    }CFGROM_HW_VERSION;

//Sub-Unit GLB 
    reg {
        name = "CFGROM_GLB_DESC";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } GLB_DESC[31:0];
        GLB_DESC->desc="";
    }CFGROM_GLB_DESC;

//Sub-Unit CIF
    reg {
        name = "CFGROM_CIF_DESC";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x00180002;
            reset_mask      = 0x7ffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CIF_DESC[31:0];
        CIF_DESC->desc="";
    }CFGROM_CIF_DESC;

    reg {
        name = "CFGROM_CIF_CAP_INCOMPAT";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CIF_CAP_INCOMPAT[31:0];
        CIF_CAP_INCOMPAT->desc="";
    }CFGROM_CIF_CAP_INCOMPAT;

    reg {
        name = "CFGROM_CIF_CAP_COMPAT";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CIF_CAP_COMPAT[31:0];
    }CFGROM_CIF_CAP_COMPAT;

    reg {
        name = "CFGROM_CIF_BASE_WIDTH";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x8;
            reset_mask      = 0xf;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CIF_BASE_WIDTH[7:0];
    }CFGROM_CIF_BASE_WIDTH;

    reg {
        name = "CFGROM_CIF_BASE_LATENCY";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x32;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CIF_BASE_LATENCY[31:0];
    }CFGROM_CIF_BASE_LATENCY;

    reg {
        name = "CFGROM_CIF_BASE_BURST_LENGTH_MAX";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x4;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BASE_BURST_LENGTH_MAX[31:5];
    }CFGROM_CIF_BASE_BURST_LENGTH_MAX;

    reg {
        name = "CFGROM_CIF_BASE_MEM_ADDR_WIDTH";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x20;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CIF_BASE_MEM_ADDR_WIDTH[31:5];
    }CFGROM_CIF_BASE_MEM_ADDR_WIDTH;

//Sub-Unit CDMA
    reg {
        name = "CFGROM_CDMA_DESC";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x00340003;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDMA_DESC[31:0];
    }CFGROM_CDMA_DESC;

    reg {
        name = "CFGROM_CDMA_CAP_INCOMPAT";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDMA_CAP_INCOMPAT[31:0];
    }CFGROM_CDMA_CAP_INCOMPAT;

    reg {
        name = "CFGROM_CDMA_CAP_COMPAT";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x10;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDMA_CAP_COMPAT[31:0];
    }CFGROM_CDMA_CAP_COMPAT;

    reg {
        name = "CFGROM_CDMA_BASE_FEATURE_TYPES";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x10;
            reset_mask      = 0xfff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDMA_BASE_FEATURE_TYPES[11:0];
    }CFGROM_CDMA_BASE_FEATURE_TYPES;

    reg {
        name = "CFGROM_CDMA_BASE_WEIGHT_TYPES";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rwt;
            reset           = 0x10;
            reset_mask      = 0xfff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDMA_BASE_WEIGHT_TYPES[11:0];
    }CFGROM_CDMA_BASE_WEIGHT_TYPES;

    reg {
        name = "CFGROM_CDMA_BASE_ATOMIC_C";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rwt;
            reset           = 0x8;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDMA_BASE_ATOMIC_C[31:0];
    }CFGROM_CDMA_BASE_ATOMIC_C;

    reg {
        name = "CFGROM_CDMA_BASE_ATOMIC_K";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x8;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDMA_BASE_ATOMIC_K[31:0];
    }CFGROM_CDMA_BASE_ATOMIC_K;

    reg {
        name = "CFGROM_CDMA_BASE_ATOMIC_M";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x8;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDMA_BASE_ATOMIC_M[31:0];
    }CFGROM_CDMA_BASE_ATOMIC_M;

    reg {
        name = "CFGROM_CDMA_BASE_CBUF_BANK_NUM";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x20;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDMA_BASE_CBUF_BANK_NUM[31:0];
    }CFGROM_CDMA_BASE_CBUF_BANK_NUM;

    reg {
        name = "CFGROM_CDMA_BASE_CBUF_BANK_WIDTH";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x8;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDMA_BASE_CBUF_BANK_WIDTH[31:0];
    }CFGROM_CDMA_BASE_CBUF_BANK_WIDTH;

    reg {
        name = "CFGROM_CDMA_BASE_CBUF_BANK_DEPTH";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x200;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDMA_BASE_CBUF_BANK_DEPTH[31:0];
    }CFGROM_CDMA_BASE_CBUF_BANK_DEPTH;

    reg {
        name = "CFGROM_CDMA_MULTI_BATCH_MAX";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDMA_MULTI_BATCH_MAX[31:0];
    }CFGROM_CDMA_MULTI_BATCH_MAX;

    reg {
        name = "CFGROM_CDMA_IMAGE_IN_FORMATS_PACKED";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0cfff001;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDMA_IMAGE_IN_FORMATS_PACKED[31:0];
    }CFGROM_CDMA_IMAGE_IN_FORMATS_PACKED;

    reg {
        name = "CFGROM_CDMA_IMAGE_IN_FORMATS_SEMI";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x3;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDMA_IMAGE_IN_FORMATS_SEMI[31:0];
    }CFGROM_CDMA_IMAGE_IN_FORMATS_SEMI;

//Sub-Unit CBUF
    reg {
        name = "CFGROM_CBUF_DESC";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x00180004;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CBUF_DESC[31:0];
    }CFGROM_CBUF_DESC;

    reg {
        name = "CFGROM_CBUF_CAP_INCOMPAT";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CBUF_CAP_INCOMPAT[31:0];
    }CFGROM_CBUF_CAP_INCOMPAT;

    reg {
        name = "CFGROM_CBUF_CAP_COMPAT";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CBUF_CAP_COMPAT[31:0];
    }CFGROM_CBUF_CAP_COMPAT;

    reg {
        name = "CFGROM_CBUF_BASE_CBUF_BANK_NUM";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x20;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CBUF_BASE_CBUF_BANK_NUM[31:0];
    }CFGROM_CBUF_BASE_CBUF_BANK_NUM;

    reg {
        name = "CFGROM_CBUF_BASE_CBUF_BANK_WIDTH";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x8;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CBUF_BASE_CBUF_BANK_WIDTH[31:0];
    }CFGROM_CBUF_BASE_CBUF_BANK_WIDTH;

    reg {
        name = "CFGROM_CBUF_BASE_CBUF_BANK_DEPTH";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x200;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CBUF_BASE_CBUF_BANK_DEPTH[31:0];
    }CFGROM_CBUF_BASE_CBUF_BANK_DEPTH;

    reg {
        name = "CFGROM_CBUF_BASE_CDMA_ID";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x3;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CBUF_BASE_CDMA_ID[31:0];
    }CFGROM_CBUF_BASE_CDMA_ID;

//Sub-Unit CSC
    reg {
        name = "CFGROM_CSC_DESC";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x00300005;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CSC_DESC[31:0];
    }CFGROM_CSC_DESC;

    reg {
        name = "CFGROM_CSC_CAP_INCOMPAT";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CSC_CAP_INCOMPAT[31:0];
    }CFGROM_CSC_CAP_INCOMPAT;

    reg {
        name = "CFGROM_CSC_CAP_COMPAT";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x10;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CSC_CAP_COMPAT[31:0];
    }CFGROM_CSC_CAP_COMPAT;

    reg {
        name = "CFGROM_CSC_BASE_FEATURE_TYPES";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x10;
            reset_mask      = 0xfff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CSC_BASE_FEATURE_TYPES[11:0];
    }CFGROM_CSC_BASE_FEATURE_TYPES;

    reg {
        name = "CFGROM_CSC_BASE_WEIGHT_TYPES";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rwt;
            reset           = 0x10;
            reset_mask      = 0xfff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CSC_BASE_WEIGHT_TYPES[11:0];
    }CFGROM_CSC_BASE_WEIGHT_TYPES;

    reg {
        name = "CFGROM_CSC_BASE_ATOMIC_C";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rwt;
            reset           = 0x8;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CSC_BASE_ATOMIC_C[31:0];
    }CFGROM_CSC_BASE_ATOMIC_C;

    reg {
        name = "CFGROM_CSC_BASE_ATOMIC_K";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x8;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CSC_BASE_ATOMIC_K[31:0];
    }CFGROM_CSC_BASE_ATOMIC_K;

    reg {
        name = "CFGROM_CSC_BASE_ATOMIC_M";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x8;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CSC_BASE_ATOMIC_M[31:0];
    }CFGROM_CSC_BASE_ATOMIC_M;

    reg {
        name = "CFGROM_CSC_BASE_CBUF_BANK_NUM";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x20;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CSC_BASE_CBUF_BANK_NUM[31:0];
    }CFGROM_CSC_BASE_CBUF_BANK_NUM;

    reg {
        name = "CFGROM_CSC_BASE_CBUF_BANK_WIDTH";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x8;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CSC_BASE_CBUF_BANK_WIDTH[31:0];
    }CFGROM_CSC_BASE_CBUF_BANK_WIDTH;

    reg {
        name = "CFGROM_CSC_BASE_CBUF_BANK_DEPTH";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x200;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CSC_BASE_CBUF_BANK_DEPTH[31:0];
    }CFGROM_CSC_BASE_CBUF_BANK_DEPTH;

    reg {
        name = "CFGROM_CSC_BASE_CDMA_ID";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x3;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CSC_BASE_CDMA_ID[31:0];
    }CFGROM_CSC_BASE_CDMA_ID;

    reg {
        name = "CFGROM_CSC_MULTI_BATCH_MAX";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CSC_MULTI_BATCH_MAX[31:0];
    }CFGROM_CSC_MULTI_BATCH_MAX;

//Sub-Unit CMAC_A
    reg {
        name = "CFGROM_CMAC_A_DESC";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x001c0006;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CMAC_A_DESC[31:0];
    }CFGROM_CMAC_A_DESC;

    reg {
        name = "CFGROM_CMAC_A_CAP_INCOMPAT";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CMAC_A_CAP_INCOMPAT[31:0];
    }CFGROM_CMAC_A_CAP_INCOMPAT;

    reg {
        name = "CFGROM_CMAC_A_CAP_COMPAT";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x10;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CMAC_A_CAP_COMPAT[31:0];
    }CFGROM_CMAC_A_CAP_COMPAT;

    reg {
        name = "CFGROM_CMAC_A_BASE_FEATURE_TYPES";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x10;
            reset_mask      = 0xfff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CMAC_A_BASE_FEATURE_TYPES[11:0];
    }CFGROM_CMAC_A_BASE_FEATURE_TYPES;

    reg {
        name = "CFGROM_CMAC_A_BASE_WEIGHT_TYPES";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rwt;
            reset           = 0x10;
            reset_mask      = 0xfff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CMAC_A_BASE_WEIGHT_TYPES[11:0];
    }CFGROM_CMAC_A_BASE_WEIGHT_TYPES;

    reg {
        name = "CFGROM_CMAC_A_BASE_ATOMIC_C";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rwt;
            reset           = 0x8;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CMAC_A_BASE_ATOMIC_C[31:0];
    }CFGROM_CMAC_A_BASE_ATOMIC_C;

    reg {
        name = "CFGROM_CMAC_A_BASE_ATOMIC_K";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x8;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CMAC_A_BASE_ATOMIC_K[31:0];
    }CFGROM_CMAC_A_BASE_ATOMIC_K;

    reg {
        name = "CFGROM_CMAC_A_BASE_CDMA_ID";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x3;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CMAC_A_BASE_CDMA_ID[31:0];
    }CFGROM_CMAC_A_BASE_CDMA_ID;

//Sub-Unit CMAC_B
    reg {
        name = "CFGROM_CMAC_B_DESC";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x001c0006;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CMAC_B_DESC[31:0];
    }CFGROM_CMAC_B_DESC;

    reg {
        name = "CFGROM_CMAC_B_CAP_INCOMPAT";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CMAC_B_CAP_INCOMPAT[31:0];
    }CFGROM_CMAC_B_CAP_INCOMPAT;

    reg {
        name = "CFGROM_CMAC_B_CAP_COMPAT";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x10;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CMAC_B_CAP_COMPAT[31:0];
    }CFGROM_CMAC_B_CAP_COMPAT;

    reg {
        name = "CFGROM_CMAC_B_BASE_FEATURE_TYPES";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x10;
            reset_mask      = 0xfff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CMAC_B_BASE_FEATURE_TYPES[11:0];
    }CFGROM_CMAC_B_BASE_FEATURE_TYPES;

    reg {
        name = "CFGROM_CMAC_B_BASE_WEIGHT_TYPES";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rwt;
            reset           = 0x10;
            reset_mask      = 0xfff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CMAC_B_BASE_WEIGHT_TYPES[11:0];
    }CFGROM_CMAC_B_BASE_WEIGHT_TYPES;

    reg {
        name = "CFGROM_CMAC_B_BASE_ATOMIC_C";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rwt;
            reset           = 0x8;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CMAC_B_BASE_ATOMIC_C[31:0];
    }CFGROM_CMAC_B_BASE_ATOMIC_C;

    reg {
        name = "CFGROM_CMAC_B_BASE_ATOMIC_K";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x8;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CMAC_B_BASE_ATOMIC_K[31:0];
    }CFGROM_CMAC_B_BASE_ATOMIC_K;

    reg {
        name = "CFGROM_CMAC_B_BASE_CDMA_ID";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x3;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CMAC_B_BASE_CDMA_ID[31:0];
    }CFGROM_CMAC_B_BASE_CDMA_ID;

//Sub-Unit CACC
    reg {
        name = "CFGROM_CACC_DESC";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x00200007;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CACC_DESC[31:0];
    }CFGROM_CACC_DESC;

    reg {
        name = "CFGROM_CACC_CAP_INCOMPAT";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CACC_CAP_INCOMPAT[31:0];
    }CFGROM_CACC_CAP_INCOMPAT;

    reg {
        name = "CFGROM_CACC_CAP_COMPAT";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CACC_CAP_COMPAT[31:0];
    }CFGROM_CACC_CAP_COMPAT;

    reg {
        name = "CFGROM_CACC_BASE_FEATURE_TYPES";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x10;
            reset_mask      = 0xfff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CACC_BASE_FEATURE_TYPES[11:0];
    }CFGROM_CACC_BASE_FEATURE_TYPES;

    reg {
        name = "CFGROM_CACC_BASE_WEIGHT_TYPES";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rwt;
            reset           = 0x10;
            reset_mask      = 0xfff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CACC_BASE_WEIGHT_TYPES[11:0];
    }CFGROM_CACC_BASE_WEIGHT_TYPES;

    reg {
        name = "CFGROM_CACC_BASE_ATOMIC_C";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rwt;
            reset           = 0x8;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CACC_BASE_ATOMIC_C[31:0];
    }CFGROM_CACC_BASE_ATOMIC_C;

    reg {
        name = "CFGROM_CACC_BASE_ATOMIC_K";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x8;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CACC_BASE_ATOMIC_K[31:0];
    }CFGROM_CACC_BASE_ATOMIC_K;

    reg {
        name = "CFGROM_CACC_BASE_CDMA_ID";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x3;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CACC_BASE_CDMA_ID[31:0];
    }CFGROM_CACC_BASE_CDMA_ID;

    reg {
        name = "CFGROM_CACC_MULTI_BATCH_MAX";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CACC_MULTI_BATCH_MAX[31:0];
    }CFGROM_CACC_MULTI_BATCH_MAX;

//Sub-Unit SDP_RDMA
    reg {
        name = "CFGROM_SDP_RDMA_DESC";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x000e0008;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SDP_RDMA_DESC[31:0];
    }CFGROM_SDP_RDMA_DESC;

    reg {
        name = "CFGROM_SDP_RDMA_CAP_INCOMPAT";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SDP_RDMA_CAP_INCOMPAT[31:0];
    }CFGROM_SDP_RDMA_CAP_INCOMPAT;

    reg {
        name = "CFGROM_SDP_RDMA_CAP_COMPAT";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SDP_RDMA_CAP_COMPAT[31:0];
    }CFGROM_SDP_RDMA_CAP_COMPAT;

    reg {
        name = "CFGROM_SDP_RDMA_BASE_ATOMIC_M";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x8;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SDP_RDMA_BASE_ATOMIC_M[31:0];
    }CFGROM_SDP_RDMA_BASE_ATOMIC_M;

    reg {
        name = "CFGROM_SDP_RDMA_BASE_SDP_ID";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x9;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SDP_RDMA_BASE_SDP_ID[31:0];
    }CFGROM_SDP_RDMA_BASE_SDP_ID;

//Sub-Unit SDP 
    reg {
        name = "CFGROM_SDP_DESC";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x00200009;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SDP_DESC[31:0];
    }CFGROM_SDP_DESC;

    reg {
        name = "CFGROM_SDP_CAP_INCOMPAT";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SDP_CAP_INCOMPAT[31:0];
    }CFGROM_SDP_CAP_INCOMPAT;

    reg {
        name = "CFGROM_SDP_CAP_COMPAT";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x18;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SDP_CAP_COMPAT[31:0];
    }CFGROM_SDP_CAP_COMPAT;

    reg {
        name = "CFGROM_SDP_BASE_FEATURE_TYPES";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x10;
            reset_mask      = 0xfff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SDP_BASE_FEATURE_TYPES[11:0];
    }CFGROM_SDP_BASE_FEATURE_TYPES;

    reg {
        name = "CFGROM_SDP_BASE_WEIGHT_TYPES";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rwt;
            reset           = 0x10;
            reset_mask      = 0xfff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SDP_BASE_WEIGHT_TYPES[11:0];
    }CFGROM_SDP_BASE_WEIGHT_TYPES;

    reg {
        name = "CFGROM_SDP_BASE_CDMA_ID";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x3;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SDP_BASE_CDMA_ID[31:0];
    }CFGROM_SDP_BASE_CDMA_ID;

    reg {
        name = "CFGROM_SDP_MULTI_BATCH_MAX";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SDP_MULTI_BATCH_MAX[31:0];
    }CFGROM_SDP_MULTI_BATCH_MAX;

    reg {
        name = "CFGROM_SDP_BS_THROUGHPUT";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x1;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SDP_BS_THROUGHPUT[31:0];
    }CFGROM_SDP_BS_THROUGHPUT;

    reg {
        name = "CFGROM_SDP_BN_THROUGHPUT";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x1;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SDP_BN_THROUGHPUT[31:0];
    }CFGROM_SDP_BN_THROUGHPUT;

    reg {
        name = "CFGROM_SDP_EW_THROUGHPUT";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SDP_EW_THROUGHPUT[31:0];
    }CFGROM_SDP_EW_THROUGHPUT;

//Sub-Unit PDP_RDMA
    reg {
        name = "CFGROM_PDP_RDMA_DESC";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x000e000a;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PDP_RDMA_DESC[31:0];
    }CFGROM_PDP_RDMA_DESC;

    reg {
        name = "CFGROM_PDP_RDMA_CAP_INCOMPAT";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PDP_RDMA_CAP_INCOMPAT[31:0];
    }CFGROM_PDP_RDMA_CAP_INCOMPAT;

    reg {
        name = "CFGROM_PDP_RDMA_CAP_COMPAT";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PDP_RDMA_CAP_COMPAT[31:0];
    }CFGROM_PDP_RDMA_CAP_COMPAT;

    reg {
        name = "CFGROM_PDP_RDMA_BASE_ATOMIC_M";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x8;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PDP_RDMA_BASE_ATOMIC_M[31:0];
    }CFGROM_PDP_RDMA_BASE_ATOMIC_M;

    reg {
        name = "CFGROM_PDP_RDMA_BASE_PDP_ID";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0xb;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PDP_RDMA_BASE_PDP_ID[31:0];
    }CFGROM_PDP_RDMA_BASE_PDP_ID;

//Sub-Unit PDP 
    reg {
        name = "CFGROM_PDP_DESC";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0010000b;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PDP_DESC[31:0];
    }CFGROM_PDP_DESC;

    reg {
        name = "CFGROM_PDP_CAP_INCOMPAT";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PDP_CAP_INCOMPAT[31:0];
    }CFGROM_PDP_CAP_INCOMPAT;

    reg {
        name = "CFGROM_PDP_CAP_COMPAT";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PDP_CAP_COMPAT[31:0];
    }CFGROM_PDP_CAP_COMPAT;

    reg {
        name = "CFGROM_PDP_BASE_FEATURE_TYPES";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x10;
            reset_mask      = 0xfff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PDP_BASE_FEATURE_TYPES[11:0];
    }CFGROM_PDP_BASE_FEATURE_TYPES;

    reg {
        name = "CFGROM_PDP_BASE_THROUGHPUT";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x1;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PDP_BASE_THROUGHPUT[31:0];
    }CFGROM_PDP_BASE_THROUGHPUT;

//Sub-Unit CDP_RDMA
    reg {
        name = "CFGROM_CDP_RDMA_DESC";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x000e000c;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDP_RDMA_DESC[31:0];
    }CFGROM_CDP_RDMA_DESC;

    reg {
        name = "CFGROM_CDP_RDMA_CAP_INCOMPAT";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDP_RDMA_CAP_INCOMPAT[31:0];
    }CFGROM_CDP_RDMA_CAP_INCOMPAT;

    reg {
        name = "CFGROM_CDP_RDMA_CAP_COMPAT";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDP_RDMA_CAP_COMPAT[31:0];
    }CFGROM_CDP_RDMA_CAP_COMPAT;

    reg {
        name = "CFGROM_CDP_RDMA_BASE_ATOMIC_M";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x8;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDP_RDMA_BASE_ATOMIC_M[31:0];
    }CFGROM_CDP_RDMA_BASE_ATOMIC_M;

    reg {
        name = "CFGROM_CDP_RDMA_BASE_CDP_ID";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0xd;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDP_RDMA_BASE_CDP_ID[31:0];
    }CFGROM_CDP_RDMA_BASE_CDP_ID;

//Sub-Unit CDP 
    reg {
        name = "CFGROM_CDP_DESC";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0010000d;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDP_DESC[31:0];
    }CFGROM_CDP_DESC;

    reg {
        name = "CFGROM_CDP_CAP_INCOMPAT";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDP_CAP_INCOMPAT[31:0];
    }CFGROM_CDP_CAP_INCOMPAT;

    reg {
        name = "CFGROM_CDP_CAP_COMPAT";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDP_CAP_COMPAT[31:0];
    }CFGROM_CDP_CAP_COMPAT;

    reg {
        name = "CFGROM_CDP_BASE_FEATURE_TYPES";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x10;
            reset_mask      = 0xfff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDP_BASE_FEATURE_TYPES[11:0];
    }CFGROM_CDP_BASE_FEATURE_TYPES;

    reg {
        name = "CFGROM_CDP_BASE_THROUGHPUT";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x1;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDP_BASE_THROUGHPUT[31:0];
    }CFGROM_CDP_BASE_THROUGHPUT;

//End-Of-List
    reg {
        name = "CFGROM_END_OF_LIST";
        desc = "";
        field {
            sw              = r;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } END_OF_LIST[31:0];
    }CFGROM_END_OF_LIST;
};

regfile regs_NVDLA_GLB{
    default regwidth=32;
    reg {
        name = "S_NVDLA_HW_VERSION";
        desc = "
//////////////////////////////////////////////////////////////////////////////////
////                                                                            //
////                    Define single group registers here                      //
////                    Register name should shart with prefix S_               //
////                                                                            //
//////////////////////////////////////////////////////////////////////////////////
";
        field {
            sw              = r;
            hw              = r;
            spec_access     = c;
            reset           = 0x31;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } MAJOR[7:0];
        MAJOR->desc="
////value = 0x31, ASCII code of 1
";
        field {
            sw              = r;
            hw              = r;
            spec_access     = c;
            reset           = 0x3030;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } MINOR[23:8];
        MINOR->desc="
////value = 0x3030 code of 00
";
    }S_NVDLA_HW_VERSION @0x0;
    reg {
        name = "S_INTR_MASK";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SDP_DONE_MASK0[0:0];
        SDP_DONE_MASK0->desc="
//// SDP layer done interrupt mask control
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SDP_DONE_MASK1[1:1];
        SDP_DONE_MASK1->desc="
//// SDP layer done interrupt mask control
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDP_DONE_MASK0[2:2];
        CDP_DONE_MASK0->desc="
//// CDP layer done interrupt mask control
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDP_DONE_MASK1[3:3];
        CDP_DONE_MASK1->desc="
//// CDP layer done interrupt mask control
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PDP_DONE_MASK0[4:4];
        PDP_DONE_MASK0->desc="
//// PDP layer done interrupt mask control
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PDP_DONE_MASK1[5:5];
        PDP_DONE_MASK1->desc="
//// PDP layer done interrupt mask control
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BDMA_DONE_MASK0[6:6];
        BDMA_DONE_MASK0->desc="
//// BDMA layer done interrupt mask control
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BDMA_DONE_MASK1[7:7];
        BDMA_DONE_MASK1->desc="
//// BDMA layer done interrupt mask control
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RUBIK_DONE_MASK0[8:8];
        RUBIK_DONE_MASK0->desc="
//// RUBIK layer done interrupt mask control
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RUBIK_DONE_MASK1[9:9];
        RUBIK_DONE_MASK1->desc="
//// RUBIK layer done interrupt mask control
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDMA_DAT_DONE_MASK0[16:16];
        CDMA_DAT_DONE_MASK0->desc="
//// CDMA data fetch done interrupt mask control
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDMA_DAT_DONE_MASK1[17:17];
        CDMA_DAT_DONE_MASK1->desc="
//// CDMA data fetch done interrupt mask control
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDMA_WT_DONE_MASK0[18:18];
        CDMA_WT_DONE_MASK0->desc="
//// CDMA weight fetch done interrupt mask control
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDMA_WT_DONE_MASK1[19:19];
        CDMA_WT_DONE_MASK1->desc="
//// CDMA weight fetch done interrupt mask control
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CACC_DONE_MASK0[20:20];
        CACC_DONE_MASK0->desc="
//// CACC output done interrupt mask control
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CACC_DONE_MASK1[21:21];
        CACC_DONE_MASK1->desc="
//// CACC output done interrupt mask control
";
    }S_INTR_MASK @0x4;
    reg {
        name = "S_INTR_SET";
        field {
            sw              = w;
            hw              = r;
            spec_access     = wto;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SDP_DONE_SET0[0:0];
        SDP_DONE_SET0->desc="
//// SDP layer done interrupt set manually 
";
        field {
            sw              = w;
            hw              = r;
            spec_access     = wo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SDP_DONE_SET1[1:1];
        SDP_DONE_SET1->desc="
//// SDP layer done interrupt set manually 
";
        field {
            sw              = w;
            hw              = r;
            spec_access     = wo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDP_DONE_SET0[2:2];
        CDP_DONE_SET0->desc="
//// CDP layer done interrupt set manually 
";
        field {
            sw              = w;
            hw              = r;
            spec_access     = wo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDP_DONE_SET1[3:3];
        CDP_DONE_SET1->desc="
//// CDP layer done interrupt set manually 
";
        field {
            sw              = w;
            hw              = r;
            spec_access     = wo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PDP_DONE_SET0[4:4];
        PDP_DONE_SET0->desc="
//// PDP layer done interrupt set manually 
";
        field {
            sw              = w;
            hw              = r;
            spec_access     = wo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PDP_DONE_SET1[5:5];
        PDP_DONE_SET1->desc="
//// PDP layer done interrupt set manually 
";
        field {
            sw              = w;
            hw              = r;
            spec_access     = wo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BDMA_DONE_SET0[6:6];
        BDMA_DONE_SET0->desc="
//// BDMA layer done interrupt set manually
";
        field {
            sw              = w;
            hw              = r;
            spec_access     = wo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BDMA_DONE_SET1[7:7];
        BDMA_DONE_SET1->desc="
//// BDMA layer done interrupt set manually
";
        field {
            sw              = w;
            hw              = r;
            spec_access     = wo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RUBIK_DONE_SET0[8:8];
        RUBIK_DONE_SET0->desc="
//// RUBIK layer done interrupt set manually
";
        field {
            sw              = w;
            hw              = r;
            spec_access     = wo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RUBIK_DONE_SET1[9:9];
        RUBIK_DONE_SET1->desc="
//// RUBIK layer done interrupt set manually
";
        field {
            sw              = w;
            hw              = r;
            spec_access     = wo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDMA_DAT_DONE_SET0[16:16];
        CDMA_DAT_DONE_SET0->desc="
//// CDMA data fetch done interrupt set manually
";
        field {
            sw              = w;
            hw              = r;
            spec_access     = wo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDMA_DAT_DONE_SET1[17:17];
        CDMA_DAT_DONE_SET1->desc="
//// CDMA data fetch done interrupt set manually
";
        field {
            sw              = w;
            hw              = r;
            spec_access     = wo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDMA_WT_DONE_SET0[18:18];
        CDMA_WT_DONE_SET0->desc="
//// CDMA weight fetch done interrupt set manually
";
        field {
            sw              = w;
            hw              = r;
            spec_access     = wo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDMA_WT_DONE_SET1[19:19];
        CDMA_WT_DONE_SET1->desc="
//// CDMA weight fetch done interrupt set manually
";
        field {
            sw              = w;
            hw              = r;
            spec_access     = wo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CACC_DONE_SET0[20:20];
        CACC_DONE_SET0->desc="
//// CACC output done interrupt set manually
";
        field {
            sw              = w;
            hw              = r;
            spec_access     = wo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CACC_DONE_SET1[21:21];
        CACC_DONE_SET1->desc="
//// CACC output done interrupt set manually
";
    }S_INTR_SET @0x8;
    reg {
        name = "S_INTR_STATUS";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rwto;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SDP_DONE_STATUS0[0:0];
        SDP_DONE_STATUS0->desc="
//// SDP layer done interrupt status 
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rwo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SDP_DONE_STATUS1[1:1];
        SDP_DONE_STATUS1->desc="
//// SDP layer done interrupt status 
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rwo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDP_DONE_STATUS0[2:2];
        CDP_DONE_STATUS0->desc="
//// CDP layer done interrupt status 
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rwo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDP_DONE_STATUS1[3:3];
        CDP_DONE_STATUS1->desc="
//// CDP layer done interrupt status 
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rwo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PDP_DONE_STATUS0[4:4];
        PDP_DONE_STATUS0->desc="
//// PDP layer done interrupt status 
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rwo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PDP_DONE_STATUS1[5:5];
        PDP_DONE_STATUS1->desc="
//// PDP layer done interrupt status 
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rwo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BDMA_DONE_STATUS0[6:6];
        BDMA_DONE_STATUS0->desc="
//// BDMA layer done interrupt status
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rwo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BDMA_DONE_STATUS1[7:7];
        BDMA_DONE_STATUS1->desc="
//// BDMA layer done interrupt status
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rwo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RUBIK_DONE_STATUS0[8:8];
        RUBIK_DONE_STATUS0->desc="
//// RUBIK layer done interrupt status
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rwo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RUBIK_DONE_STATUS1[9:9];
        RUBIK_DONE_STATUS1->desc="
//// RUBIK layer done interrupt status
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rwo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDMA_DAT_DONE_STATUS0[16:16];
        CDMA_DAT_DONE_STATUS0->desc="
//// CDMA data fetch done interrupt status
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rwo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDMA_DAT_DONE_STATUS1[17:17];
        CDMA_DAT_DONE_STATUS1->desc="
//// CDMA data fetch done interrupt status
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rwo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDMA_WT_DONE_STATUS0[18:18];
        CDMA_WT_DONE_STATUS0->desc="
//// CDMA weight fetch done interrupt status
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rwo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CDMA_WT_DONE_STATUS1[19:19];
        CDMA_WT_DONE_STATUS1->desc="
//// CDMA weight fetch done interrupt status
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rwo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CACC_DONE_STATUS0[20:20];
        CACC_DONE_STATUS0->desc="
//// CACC output done interrupt status
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rwo;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CACC_DONE_STATUS1[21:21];
        CACC_DONE_STATUS1->desc="
//// CACC output done interrupt status
";
    }S_INTR_STATUS @0xc;
};
regfile regs_NVDLA_MCIF{
    default regwidth=32;
    reg {
        name = "CFG_RD_WEIGHT_0";
        desc = "
//// 0x28 to 0x30 = Reserved for future use.
////MCIF Regiseters
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_WEIGHT_BDMA[7:0];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_WEIGHT_SDP[15:8];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_WEIGHT_PDP[23:16];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_WEIGHT_CDP[31:24];
    }CFG_RD_WEIGHT_0 @0x0;
    reg {
        name = "CFG_RD_WEIGHT_1";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_WEIGHT_SDP_B[7:0];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_WEIGHT_SDP_N[15:8];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_WEIGHT_SDP_E[23:16];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_WEIGHT_CDMA_DAT[31:24];
    }CFG_RD_WEIGHT_1 @0x4;
    reg {
        name = "CFG_RD_WEIGHT_2";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_WEIGHT_CDMA_WT[7:0];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_WEIGHT_RBK[15:8];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_WEIGHT_RSV_1[23:16];
        RD_WEIGHT_RSV_1->desc="
//// reserved
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_WEIGHT_RSV_0[31:24];
        RD_WEIGHT_RSV_0->desc="
//// reserved
";
    }CFG_RD_WEIGHT_2 @0x8;
    reg {
        name = "CFG_WR_WEIGHT_0";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WR_WEIGHT_BDMA[7:0];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WR_WEIGHT_SDP[15:8];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WR_WEIGHT_PDP[23:16];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WR_WEIGHT_CDP[31:24];
    }CFG_WR_WEIGHT_0 @0xc;
    reg {
        name = "CFG_WR_WEIGHT_1";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WR_WEIGHT_RBK[7:0];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WR_WEIGHT_RSV_2[15:8];
        WR_WEIGHT_RSV_2->desc="
//// reserved
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WR_WEIGHT_RSV_1[23:16];
        WR_WEIGHT_RSV_1->desc="
//// reserved
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WR_WEIGHT_RSV_0[31:24];
        WR_WEIGHT_RSV_0->desc="
//// reserved
";
    }CFG_WR_WEIGHT_1 @0x10;
    reg {
        name = "CFG_OUTSTANDING_CNT";
        desc = "
//// outstanding AXI transactions in unit of 64Byte, less than 256
//// +1
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0xff;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_OS_CNT[7:0];
        RD_OS_CNT->desc="
//// reserved
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0xff;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WR_OS_CNT[15:8];
        WR_OS_CNT->desc="
//// reserved
";
    }CFG_OUTSTANDING_CNT @0x14;
    reg {
        name = "STATUS";
        enum STATUS_IDLE_enum {
            NO = 1'd0 {desc = "
//// module is not idle, means there are oustanding AXI trans from/to CVNAS
";};
            YES = 1'd1 {desc = "
//// module is idle, no outstanding AXI trnas from/to CVNAS
";};
        };
        field {
            encode          = STATUS_IDLE_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } IDLE[8:8];
    }STATUS @0x18;
};
regfile regs_NVDLA_CDMA{
    default regwidth=32;
    reg {
        name = "S_STATUS";
        desc = "
////Convolution DMA Registers
";
        enum S_STATUS_STATUS_0_enum {
            IDLE = 2'd0;
            RUNNING = 2'd1;
            PENDING = 2'd2;
        };
        field {
            encode          = S_STATUS_STATUS_0_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_0[1:0];
        STATUS_0->desc="
//// Status of configuration register group 0
";
        enum S_STATUS_STATUS_1_enum {
            IDLE = 2'd0;
            RUNNING = 2'd1;
            PENDING = 2'd2;
        };
        field {
            encode          = S_STATUS_STATUS_1_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_1[17:16];
        STATUS_1->desc="
//// Status of configuration register group 1
";
    }S_STATUS @0x0;
    reg {
        name = "S_POINTER";
        enum S_POINTER_PRODUCER_enum {
            GROUP_0 = 1'd0;
            GROUP_1 = 1'd1;
        };
        field {
            encode          = S_POINTER_PRODUCER_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PRODUCER[0:0];
        PRODUCER->desc="
////Pointer for CSB master to access groups
";
        enum S_POINTER_CONSUMER_enum {
            GROUP_0 = 1'd0;
            GROUP_1 = 1'd1;
        };
        field {
            encode          = S_POINTER_CONSUMER_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CONSUMER[16:16];
        CONSUMER->desc="
////Pointer for datapath to access groups
";
    }S_POINTER @0x4;
    reg {
        name = "S_ARBITER";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0xf;
            reset_mask      = 0xf;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ARB_WEIGHT[3:0];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x3;
            reset_mask      = 0xf;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ARB_WMB[19:16];
    }S_ARBITER @0x8;
    reg {
        name = "S_CBUF_FLUSH_STATUS";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } FLUSH_DONE[0:0];
    }S_CBUF_FLUSH_STATUS @0xc;
    reg {
        name = "D_OP_ENABLE";
        desc = "
//////////////////////////////////////////////////////////////////////////////////
////                                                                            //
////                    Define single group registers here                      //
////                    Register name should shart with prefix D_               //
////                                                                            //
//////////////////////////////////////////////////////////////////////////////////
";
        enum D_OP_ENABLE_OP_EN_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_OP_ENABLE_OP_EN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rwto;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } OP_EN[0:0];
    }D_OP_ENABLE @0x10;
    reg {
        name = "D_MISC_CFG";
        enum D_MISC_CFG_CONV_MODE_enum {
            DIRECT = 1'd0;
            WINOGRAD = 1'd1;
        };
        field {
            encode          = D_MISC_CFG_CONV_MODE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CONV_MODE[0:0];
        enum D_MISC_CFG_IN_PRECISION_enum {
            INT8 = 2'd0;
            INT16 = 2'd1;
            FP16 = 2'd2;
        };
        field {
            encode          = D_MISC_CFG_IN_PRECISION_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } IN_PRECISION[9:8];
        enum D_MISC_CFG_PROC_PRECISION_enum {
            INT8 = 2'd0;
            INT16 = 2'd1;
            FP16 = 2'd2;
        };
        field {
            encode          = D_MISC_CFG_PROC_PRECISION_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PROC_PRECISION[13:12];
        enum D_MISC_CFG_DATA_REUSE_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_MISC_CFG_DATA_REUSE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATA_REUSE[16:16];
        enum D_MISC_CFG_WEIGHT_REUSE_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_MISC_CFG_WEIGHT_REUSE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WEIGHT_REUSE[20:20];
        enum D_MISC_CFG_SKIP_DATA_RLS_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_MISC_CFG_SKIP_DATA_RLS_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SKIP_DATA_RLS[24:24];
        enum D_MISC_CFG_SKIP_WEIGHT_RLS_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_MISC_CFG_SKIP_WEIGHT_RLS_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SKIP_WEIGHT_RLS[28:28];
    }D_MISC_CFG @0x14;
    reg {
        name = "D_DATAIN_FORMAT";
        enum D_DATAIN_FORMAT_DATAIN_FORMAT_enum {
            FEATURE = 1'd0;
            PIXEL = 1'd1;
        };
        field {
            encode          = D_DATAIN_FORMAT_DATAIN_FORMAT_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAIN_FORMAT[0:0];
        enum D_DATAIN_FORMAT_PIXEL_FORMAT_enum {
            T_R8 = 6'd0;
            T_R10 = 6'd1;
            T_R12 = 6'd2;
            T_R16 = 6'd3;
            T_R16_I = 6'd4;
            T_R16_F = 6'd5;
            T_A16B16G16R16 = 6'd6;
            T_X16B16G16R16 = 6'd7;
            T_A16B16G16R16_F = 6'd8;
            T_A16Y16U16V16 = 6'd9;
            T_V16U16Y16A16 = 6'd10;
            T_A16Y16U16V16_F = 6'd11;
            T_A8B8G8R8 = 6'd12;
            T_A8R8G8B8 = 6'd13;
            T_B8G8R8A8 = 6'd14;
            T_R8G8B8A8 = 6'd15;
            T_X8B8G8R8 = 6'd16;
            T_X8R8G8B8 = 6'd17;
            T_B8G8R8X8 = 6'd18;
            T_R8G8B8X8 = 6'd19;
            T_A2B10G10R10 = 6'd20;
            T_A2R10G10B10 = 6'd21;
            T_B10G10R10A2 = 6'd22;
            T_R10G10B10A2 = 6'd23;
            T_A2Y10U10V10 = 6'd24;
            T_V10U10Y10A2 = 6'd25;
            T_A8Y8U8V8 = 6'd26;
            T_V8U8Y8A8 = 6'd27;
            T_Y8___U8V8_N444 = 6'd28;
            T_Y8___V8U8_N444 = 6'd29;
            T_Y10___U10V10_N444 = 6'd30;
            T_Y10___V10U10_N444 = 6'd31;
            T_Y12___U12V12_N444 = 6'd32;
            T_Y12___V12U12_N444 = 6'd33;
            T_Y16___U16V16_N444 = 6'd34;
            T_Y16___V16U16_N444 = 6'd35;
        };
        field {
            encode          = D_DATAIN_FORMAT_PIXEL_FORMAT_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0xc;
            reset_mask      = 0x3f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PIXEL_FORMAT[13:8];
        enum D_DATAIN_FORMAT_PIXEL_MAPPING_enum {
            PITCH_LINEAR = 1'd0;
            RESERVED_LINEAR = 1'd1;
        };
        field {
            encode          = D_DATAIN_FORMAT_PIXEL_MAPPING_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PIXEL_MAPPING[16:16];
        enum D_DATAIN_FORMAT_PIXEL_SIGN_OVERRIDE_enum {
            UNSIGNED_INT = 1'd0;
            SIGNED_INT = 1'd1;
        };
        field {
            encode          = D_DATAIN_FORMAT_PIXEL_SIGN_OVERRIDE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PIXEL_SIGN_OVERRIDE[20:20];
    }D_DATAIN_FORMAT @0x18;
    reg {
        name = "D_DATAIN_SIZE_0";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAIN_WIDTH[12:0];
        DATAIN_WIDTH->desc="
////Input data cube width - 1
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAIN_HEIGHT[28:16];
        DATAIN_HEIGHT->desc="
////Input data cube height - 1
";
    }D_DATAIN_SIZE_0 @0x1c;
    reg {
        name = "D_DATAIN_SIZE_1";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAIN_CHANNEL[12:0];
        DATAIN_CHANNEL->desc="
////Input data cube channel - 1
";
    }D_DATAIN_SIZE_1 @0x20;
    reg {
        name = "D_DATAIN_SIZE_EXT_0";
        desc = "
////For winograd mode only
////DATAIN_WIDTH_EXT = (PAD_LEFT + PAD_RIGHT + DATAIN_WIDTH + 1)/(CONV_X_STRIDE + 1) - 1;
////DATAIN_HEIGHT_EXT = (PAD_TOP + PAD_BOTTOM + DATAIN_HEIGHT + 1)/(CONV_Y_STRIDE + 1) - 1;
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAIN_WIDTH_EXT[12:0];
        DATAIN_WIDTH_EXT->desc="
////Input data cube width - 1
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAIN_HEIGHT_EXT[28:16];
        DATAIN_HEIGHT_EXT->desc="
////Input data cube height - 1
";
    }D_DATAIN_SIZE_EXT_0 @0x24;
    reg {
        name = "D_PIXEL_OFFSET";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PIXEL_X_OFFSET[4:0];
        PIXEL_X_OFFSET->desc="
////Pixel horizontal offset
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PIXEL_Y_OFFSET[18:16];
        PIXEL_Y_OFFSET->desc="
////Pixel vertical offset
";
    }D_PIXEL_OFFSET @0x28;
    reg {
        name = "D_DAIN_RAM_TYPE";
        enum D_DAIN_RAM_TYPE_DATAIN_RAM_TYPE_enum {
            CVIF = 1'd0;
            MCIF = 1'd1;
        };
        field {
            encode          = D_DAIN_RAM_TYPE_DATAIN_RAM_TYPE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAIN_RAM_TYPE[0:0];
        DATAIN_RAM_TYPE->desc="
////indicate the source ram (CV or MC)
";
    }D_DAIN_RAM_TYPE @0x2c;
    reg {
        name = "D_DAIN_ADDR_HIGH_0";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAIN_ADDR_HIGH_0[31:0];
        DATAIN_ADDR_HIGH_0->desc="
////Input data address, high 32 bits
";
    }D_DAIN_ADDR_HIGH_0 @0x30;
    reg {
        name = "D_DAIN_ADDR_LOW_0";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAIN_ADDR_LOW_0[31:0];
        DATAIN_ADDR_LOW_0->desc="
////Input data address, low 32 bits
";
    }D_DAIN_ADDR_LOW_0 @0x34;
    reg {
        name = "D_DAIN_ADDR_HIGH_1";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAIN_ADDR_HIGH_1[31:0];
        DATAIN_ADDR_HIGH_1->desc="
////Input data address, high 32 bits, for UV plane
";
    }D_DAIN_ADDR_HIGH_1 @0x38;
    reg {
        name = "D_DAIN_ADDR_LOW_1";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAIN_ADDR_LOW_1[31:0];
        DATAIN_ADDR_LOW_1->desc="
////Input data address, low 32 bits, for UV plane
";
    }D_DAIN_ADDR_LOW_1 @0x3c;
    reg {
        name = "D_LINE_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LINE_STRIDE[31:0];
        LINE_STRIDE->desc="
////bytes
";
    }D_LINE_STRIDE @0x40;
    reg {
        name = "D_LINE_UV_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } UV_LINE_STRIDE[31:0];
        UV_LINE_STRIDE->desc="
////bytes
";
    }D_LINE_UV_STRIDE @0x44;
    reg {
        name = "D_SURF_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SURF_STRIDE[31:0];
        SURF_STRIDE->desc="
////bytes
";
    }D_SURF_STRIDE @0x48;
    reg {
        name = "D_DAIN_MAP";
        enum D_DAIN_MAP_LINE_PACKED_enum {
            FALSE = 1'd0;
            TRUE = 1'd1;
        };
        field {
            encode          = D_DAIN_MAP_LINE_PACKED_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LINE_PACKED[0:0];
        enum D_DAIN_MAP_SURF_PACKED_enum {
            FALSE = 1'd0;
            TRUE = 1'd1;
        };
        field {
            encode          = D_DAIN_MAP_SURF_PACKED_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SURF_PACKED[16:16];
    }D_DAIN_MAP @0x4c;
    reg {
        name = "D_RESERVED_X_CFG";
        desc = "
////reserved register, do not touch
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3ff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RSV_PER_LINE[9:0];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3ff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RSV_PER_UV_LINE[25:16];
    }D_RESERVED_X_CFG @0x50;
    reg {
        name = "D_RESERVED_Y_CFG";
        desc = "
////reserved register, do not touch
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RSV_HEIGHT[2:0];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RSV_Y_INDEX[20:16];
    }D_RESERVED_Y_CFG @0x54;
    reg {
        name = "D_BATCH_NUMBER";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BATCHES[4:0];
        BATCHES->desc="
////batch number - 1
";
    }D_BATCH_NUMBER @0x58;
    reg {
        name = "D_BATCH_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BATCH_STRIDE[31:0];
        BATCH_STRIDE->desc="
////bytes
";
    }D_BATCH_STRIDE @0x5c;
    reg {
        name = "D_ENTRY_PER_SLICE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ENTRIES[13:0];
        ENTRIES->desc="
////entries - 1
";
    }D_ENTRY_PER_SLICE @0x60;
    reg {
        name = "D_FETCH_GRAIN";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xfff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } GRAINS[11:0];
        GRAINS->desc="
////slice - 1
";
    }D_FETCH_GRAIN @0x64;
    reg {
        name = "D_WEIGHT_FORMAT";
        enum D_WEIGHT_FORMAT_WEIGHT_FORMAT_enum {
            UNCOMPRESSED = 1'd0;
            COMPRESSED = 1'd1;
        };
        field {
            encode          = D_WEIGHT_FORMAT_WEIGHT_FORMAT_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WEIGHT_FORMAT[0:0];
    }D_WEIGHT_FORMAT @0x68;
    reg {
        name = "D_WEIGHT_SIZE_0";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3ffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BYTE_PER_KERNEL[17:0];
        BYTE_PER_KERNEL->desc="
////BYTE_PER_KERNEL - 1
";
    }D_WEIGHT_SIZE_0 @0x6c;
    reg {
        name = "D_WEIGHT_SIZE_1";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WEIGHT_KERNEL[12:0];
        WEIGHT_KERNEL->desc="
////kernel - 1
";
    }D_WEIGHT_SIZE_1 @0x70;
    reg {
        name = "D_WEIGHT_RAM_TYPE";
        enum D_WEIGHT_RAM_TYPE_WEIGHT_RAM_TYPE_enum {
            CVIF = 1'd0;
            MCIF = 1'd1;
        };
        field {
            encode          = D_WEIGHT_RAM_TYPE_WEIGHT_RAM_TYPE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WEIGHT_RAM_TYPE[0:0];
        WEIGHT_RAM_TYPE->desc="
////indicate the source ram (CV or MC)
";
    }D_WEIGHT_RAM_TYPE @0x74;
    reg {
        name = "D_WEIGHT_ADDR_HIGH";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WEIGHT_ADDR_HIGH[31:0];
        WEIGHT_ADDR_HIGH->desc="
////Weight start address, high 32 bits
";
    }D_WEIGHT_ADDR_HIGH @0x78;
    reg {
        name = "D_WEIGHT_ADDR_LOW";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WEIGHT_ADDR_LOW[31:0];
        WEIGHT_ADDR_LOW->desc="
////weight start address, low 32 bits
";
    }D_WEIGHT_ADDR_LOW @0x7c;
    reg {
        name = "D_WEIGHT_BYTES";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1ffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WEIGHT_BYTES[31:0];
        WEIGHT_BYTES->desc="
////total bytes of entire weights
";
    }D_WEIGHT_BYTES @0x80;
    reg {
        name = "D_WGS_ADDR_HIGH";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WGS_ADDR_HIGH[31:0];
        WGS_ADDR_HIGH->desc="
////start address of WGS, high 32 bits
";
    }D_WGS_ADDR_HIGH @0x84;
    reg {
        name = "D_WGS_ADDR_LOW";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WGS_ADDR_LOW[31:0];
        WGS_ADDR_LOW->desc="
////start address of WGS, low 32 bits
";
    }D_WGS_ADDR_LOW @0x88;
    reg {
        name = "D_WMB_ADDR_HIGH";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WMB_ADDR_HIGH[31:0];
        WMB_ADDR_HIGH->desc="
////start address of WMB, high 32 bits
";
    }D_WMB_ADDR_HIGH @0x8c;
    reg {
        name = "D_WMB_ADDR_LOW";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WMB_ADDR_LOW[31:0];
        WMB_ADDR_LOW->desc="
////start address of WMB, low 32 bits
";
    }D_WMB_ADDR_LOW @0x90;
    reg {
        name = "D_WMB_BYTES";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WMB_BYTES[27:0];
        WMB_BYTES->desc="
////total WMB bytes
";
    }D_WMB_BYTES @0x94;
    reg {
        name = "D_MEAN_FORMAT";
        desc = "
////Mean value is always signed integer value
";
        enum D_MEAN_FORMAT_MEAN_FORMAT_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_MEAN_FORMAT_MEAN_FORMAT_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } MEAN_FORMAT[0:0];
    }D_MEAN_FORMAT @0x98;
    reg {
        name = "D_MEAN_GLOBAL_0";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } MEAN_RY[15:0];
        MEAN_RY->desc="
////global mean value for red in RGB or Y in YUV
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } MEAN_GU[31:16];
        MEAN_GU->desc="
////global mean value for green in RGB or U in YUV
";
    }D_MEAN_GLOBAL_0 @0x9c;
    reg {
        name = "D_MEAN_GLOBAL_1";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } MEAN_BV[15:0];
        MEAN_BV->desc="
////global mean value for blue in RGB or V in YUV
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } MEAN_AX[31:16];
        MEAN_AX->desc="
////global mean value for alpha in ARGB/AYUV or X in XRGB
";
    }D_MEAN_GLOBAL_1 @0xa0;
    reg {
        name = "D_CVT_CFG";
        desc = "
////CVT_TRUNCATE is unsigned value
";
        enum D_CVT_CFG_CVT_EN_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_CVT_CFG_CVT_EN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CVT_EN[0:0];
        CVT_EN->desc="
////Control byte, enable/disable all CVT function in CDMA
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CVT_TRUNCATE[9:4];
        CVT_TRUNCATE->desc="
////number of bits to be truncated
";
    }D_CVT_CFG @0xa4;
    reg {
        name = "D_CVT_OFFSET";
        desc = "
////CVT_OFFSET is signed 16-bit value
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CVT_OFFSET[15:0];
        CVT_OFFSET->desc="
////Offset to be added to feature data
";
    }D_CVT_OFFSET @0xa8;
    reg {
        name = "D_CVT_SCALE";
        desc = "
////CVT_SCALE is signed 16-bit value
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CVT_SCALE[15:0];
        CVT_SCALE->desc="
////scaling factor
";
    }D_CVT_SCALE @0xac;
    reg {
        name = "D_CONV_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CONV_X_STRIDE[2:0];
        CONV_X_STRIDE->desc="
////convolution x stride - 1
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CONV_Y_STRIDE[18:16];
        CONV_Y_STRIDE->desc="
////convolution y stride - 1
";
    }D_CONV_STRIDE @0xb0;
    reg {
        name = "D_ZERO_PADDING";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PAD_LEFT[4:0];
        PAD_LEFT->desc="
////left zero padding size
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PAD_RIGHT[13:8];
        PAD_RIGHT->desc="
////right zero padding size
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PAD_TOP[20:16];
        PAD_TOP->desc="
////top zero padding size
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PAD_BOTTOM[29:24];
        PAD_BOTTOM->desc="
////bottom zero padding size
";
    }D_ZERO_PADDING @0xb4;
    reg {
        name = "D_ZERO_PADDING_VALUE";
        desc = "
////For DC mode with feature input and Winograd mode, PAD_VALUE in CDMA is always signed integer
////For image input mode, whether PAD_VALUE is signed or unsigned is depending on PIXEL_SIGN_OVERRIDE bit
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PAD_VALUE[15:0];
        PAD_VALUE->desc="
////pad value. [7:0] for int8, [15:0] for int16/fp16.
";
    }D_ZERO_PADDING_VALUE @0xb8;
    reg {
        name = "D_BANK";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATA_BANK[4:0];
        DATA_BANK->desc="
////number of data banks - 1
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WEIGHT_BANK[20:16];
        WEIGHT_BANK->desc="
////number of weight banks - 1
";
    }D_BANK @0xbc;
    reg {
        name = "D_NAN_FLUSH_TO_ZERO";
        enum D_NAN_FLUSH_TO_ZERO_NAN_TO_ZERO_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_NAN_FLUSH_TO_ZERO_NAN_TO_ZERO_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } NAN_TO_ZERO[0:0];
        NAN_TO_ZERO->desc="
////option to flush input NaN to zero
";
    }D_NAN_FLUSH_TO_ZERO @0xc0;
    reg {
        name = "D_NAN_INPUT_DATA_NUM";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } NAN_DATA_NUM[31:0];
        NAN_DATA_NUM->desc="
////count NaN number in input data cube, update per layer
";
    }D_NAN_INPUT_DATA_NUM @0xc4;
    reg {
        name = "D_NAN_INPUT_WEIGHT_NUM";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } NAN_WEIGHT_NUM[31:0];
        NAN_WEIGHT_NUM->desc="
////count NaN number in weight kernels, update per layer
";
    }D_NAN_INPUT_WEIGHT_NUM @0xc8;
    reg {
        name = "D_INF_INPUT_DATA_NUM";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } INF_DATA_NUM[31:0];
        INF_DATA_NUM->desc="
////count infinity number in input data cube, update per layer
";
    }D_INF_INPUT_DATA_NUM @0xcc;
    reg {
        name = "D_INF_INPUT_WEIGHT_NUM";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } INF_WEIGHT_NUM[31:0];
        INF_WEIGHT_NUM->desc="
////count infinity number in weight kernels, update per layer
";
    }D_INF_INPUT_WEIGHT_NUM @0xd0;
    reg {
        name = "D_PERF_ENABLE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DMA_EN[0:0];
        DMA_EN->desc="
////enable/disable performance counter
";
    }D_PERF_ENABLE @0xd4;
    reg {
        name = "D_PERF_DAT_READ_STALL";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DAT_RD_STALL[31:0];
        DAT_RD_STALL->desc="
////count blocking cycles of read request of input data, update per layer
";
    }D_PERF_DAT_READ_STALL @0xd8;
    reg {
        name = "D_PERF_WT_READ_STALL";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WT_RD_STALL[31:0];
        WT_RD_STALL->desc="
////count blocking cycles of read request of weight data, update per layer
";
    }D_PERF_WT_READ_STALL @0xdc;
    reg {
        name = "D_PERF_DAT_READ_LATENCY";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DAT_RD_LATENCY[31:0];
        DAT_RD_LATENCY->desc="
////count total latency cycles of read response of input data, update per layer
";
    }D_PERF_DAT_READ_LATENCY @0xe0;
    reg {
        name = "D_PERF_WT_READ_LATENCY";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WT_RD_LATENCY[31:0];
        WT_RD_LATENCY->desc="
////count total latency cycles of read request of weight data, update per layer
";
    }D_PERF_WT_READ_LATENCY @0xe4;
    reg {
        name = "D_CYA";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CYA[31:0];
        CYA->desc="
////CYA register
";
    }D_CYA @0xe8;
};
regfile regs_NVDLA_CSC{
    default regwidth=32;
    reg {
        name = "S_STATUS";
        desc = "
//// //Convolution Buffer Registers
//// base NVDLA_CBUF (NVDLA_REG_BASE + CBUF_BASE);
//// #include arnvdla_cbuf.spec
////Convolution Sequence Generator Registers
";
        enum S_STATUS_STATUS_0_enum {
            IDLE = 2'd0;
            RUNNING = 2'd1;
            PENDING = 2'd2;
        };
        field {
            encode          = S_STATUS_STATUS_0_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_0[1:0];
        STATUS_0->desc="
//// Status of configuration register group 0
";
        enum S_STATUS_STATUS_1_enum {
            IDLE = 2'd0;
            RUNNING = 2'd1;
            PENDING = 2'd2;
        };
        field {
            encode          = S_STATUS_STATUS_1_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_1[17:16];
        STATUS_1->desc="
//// Status of configuration register group 1
";
    }S_STATUS @0x0;
    reg {
        name = "S_POINTER";
        enum S_POINTER_PRODUCER_enum {
            GROUP_0 = 1'd0;
            GROUP_1 = 1'd1;
        };
        field {
            encode          = S_POINTER_PRODUCER_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PRODUCER[0:0];
        PRODUCER->desc="
////Pointer for CSB master to access groups
";
        enum S_POINTER_CONSUMER_enum {
            GROUP_0 = 1'd0;
            GROUP_1 = 1'd1;
        };
        field {
            encode          = S_POINTER_CONSUMER_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CONSUMER[16:16];
        CONSUMER->desc="
////Pointer for datapath to access groups
";
    }S_POINTER @0x4;
    reg {
        name = "D_OP_ENABLE";
        desc = "
//////////////////////////////////////////////////////////////////////////////////
////                                                                            //
////                    Define single group registers here                      //
////                    Register name should shart with prefix D_               //
////                                                                            //
//////////////////////////////////////////////////////////////////////////////////
//// 
";
        enum D_OP_ENABLE_OP_EN_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_OP_ENABLE_OP_EN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rwto;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } OP_EN[0:0];
    }D_OP_ENABLE @0x8;
    reg {
        name = "D_MISC_CFG";
        enum D_MISC_CFG_CONV_MODE_enum {
            DIRECT = 1'd0;
            WINOGRAD = 1'd1;
        };
        field {
            encode          = D_MISC_CFG_CONV_MODE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CONV_MODE[0:0];
        enum D_MISC_CFG_IN_PRECISION_enum {
            INT8 = 2'd0;
            INT16 = 2'd1;
            FP16 = 2'd2;
        };
        field {
            encode          = D_MISC_CFG_IN_PRECISION_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } IN_PRECISION[9:8];
        enum D_MISC_CFG_PROC_PRECISION_enum {
            INT8 = 2'd0;
            INT16 = 2'd1;
            FP16 = 2'd2;
        };
        field {
            encode          = D_MISC_CFG_PROC_PRECISION_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PROC_PRECISION[13:12];
        enum D_MISC_CFG_DATA_REUSE_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_MISC_CFG_DATA_REUSE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATA_REUSE[16:16];
        enum D_MISC_CFG_WEIGHT_REUSE_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_MISC_CFG_WEIGHT_REUSE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WEIGHT_REUSE[20:20];
        enum D_MISC_CFG_SKIP_DATA_RLS_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_MISC_CFG_SKIP_DATA_RLS_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SKIP_DATA_RLS[24:24];
        enum D_MISC_CFG_SKIP_WEIGHT_RLS_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_MISC_CFG_SKIP_WEIGHT_RLS_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SKIP_WEIGHT_RLS[28:28];
    }D_MISC_CFG @0xc;
    reg {
        name = "D_DATAIN_FORMAT";
        enum D_DATAIN_FORMAT_DATAIN_FORMAT_enum {
            FEATURE = 1'd0;
            PIXEL = 1'd1;
        };
        field {
            encode          = D_DATAIN_FORMAT_DATAIN_FORMAT_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAIN_FORMAT[0:0];
    }D_DATAIN_FORMAT @0x10;
    reg {
        name = "D_DATAIN_SIZE_EXT_0";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAIN_WIDTH_EXT[12:0];
        DATAIN_WIDTH_EXT->desc="
////Input data cube width - 1
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAIN_HEIGHT_EXT[28:16];
        DATAIN_HEIGHT_EXT->desc="
////Input data cube height - 1
";
    }D_DATAIN_SIZE_EXT_0 @0x14;
    reg {
        name = "D_DATAIN_SIZE_EXT_1";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAIN_CHANNEL_EXT[12:0];
        DATAIN_CHANNEL_EXT->desc="
////Input data cube channel - 1
";
    }D_DATAIN_SIZE_EXT_1 @0x18;
    reg {
        name = "D_BATCH_NUMBER";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BATCHES[4:0];
        BATCHES->desc="
////batch number - 1
";
    }D_BATCH_NUMBER @0x1c;
    reg {
        name = "D_POST_Y_EXTENSION";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } Y_EXTENSION[1:0];
        Y_EXTENSION->desc="
////extened_height == 2**Y_EXTENSION, 0 <= Y_EXTENSION <= 2
";
    }D_POST_Y_EXTENSION @0x20;
    reg {
        name = "D_ENTRY_PER_SLICE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ENTRIES[13:0];
        ENTRIES->desc="
////entries - 1
";
    }D_ENTRY_PER_SLICE @0x24;
    reg {
        name = "D_WEIGHT_FORMAT";
        enum D_WEIGHT_FORMAT_WEIGHT_FORMAT_enum {
            UNCOMPRESSED = 1'd0;
            COMPRESSED = 1'd1;
        };
        field {
            encode          = D_WEIGHT_FORMAT_WEIGHT_FORMAT_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WEIGHT_FORMAT[0:0];
    }D_WEIGHT_FORMAT @0x28;
    reg {
        name = "D_WEIGHT_SIZE_EXT_0";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WEIGHT_WIDTH_EXT[4:0];
        WEIGHT_WIDTH_EXT->desc="
////width - 1
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WEIGHT_HEIGHT_EXT[20:16];
        WEIGHT_HEIGHT_EXT->desc="
////height - 1
";
    }D_WEIGHT_SIZE_EXT_0 @0x2c;
    reg {
        name = "D_WEIGHT_SIZE_EXT_1";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WEIGHT_CHANNEL_EXT[12:0];
        WEIGHT_CHANNEL_EXT->desc="
////channel - 1
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WEIGHT_KERNEL[28:16];
        WEIGHT_KERNEL->desc="
////kernel - 1
";
    }D_WEIGHT_SIZE_EXT_1 @0x30;
    reg {
        name = "D_WEIGHT_BYTES";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1ffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WEIGHT_BYTES[31:0];
        WEIGHT_BYTES->desc="
////total bytes of entire weights
";
    }D_WEIGHT_BYTES @0x34;
    reg {
        name = "D_WMB_BYTES";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WMB_BYTES[27:0];
        WMB_BYTES->desc="
////total WMB bytes
";
    }D_WMB_BYTES @0x38;
    reg {
        name = "D_DATAOUT_SIZE_0";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAOUT_WIDTH[12:0];
        DATAOUT_WIDTH->desc="
////Output data cube width - 1
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAOUT_HEIGHT[28:16];
        DATAOUT_HEIGHT->desc="
////Output data cube height - 1
";
    }D_DATAOUT_SIZE_0 @0x3c;
    reg {
        name = "D_DATAOUT_SIZE_1";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAOUT_CHANNEL[12:0];
        DATAOUT_CHANNEL->desc="
////Output data cube channel - 1
";
    }D_DATAOUT_SIZE_1 @0x40;
    reg {
        name = "D_ATOMICS";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1fffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ATOMICS[20:0];
        ATOMICS->desc="
////Output_data_cube_width * output_data_cube_height - 1
";
    }D_ATOMICS @0x44;
    reg {
        name = "D_RELEASE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xfff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RLS_SLICES[11:0];
        RLS_SLICES->desc="
////input_data_slices_to_be_released - 1
";
    }D_RELEASE @0x48;
    reg {
        name = "D_CONV_STRIDE_EXT";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CONV_X_STRIDE_EXT[2:0];
        CONV_X_STRIDE_EXT->desc="
////convolution x stride - 1
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CONV_Y_STRIDE_EXT[18:16];
        CONV_Y_STRIDE_EXT->desc="
////convolution y stride - 1
";
    }D_CONV_STRIDE_EXT @0x4c;
    reg {
        name = "D_DILATION_EXT";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } X_DILATION_EXT[4:0];
        X_DILATION_EXT->desc="
////x dilation size - 1
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } Y_DILATION_EXT[20:16];
        Y_DILATION_EXT->desc="
////y dilation size - 1
";
    }D_DILATION_EXT @0x50;
    reg {
        name = "D_ZERO_PADDING";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PAD_LEFT[4:0];
        PAD_LEFT->desc="
////left zero padding size
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PAD_TOP[20:16];
        PAD_TOP->desc="
////top zero padding size
";
    }D_ZERO_PADDING @0x54;
    reg {
        name = "D_ZERO_PADDING_VALUE";
        desc = "
////PAD_VALUE in CSC is always signed value
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PAD_VALUE[15:0];
        PAD_VALUE->desc="
////pad value. [7:0] for int8, [15:0] for int16/fp16
";
    }D_ZERO_PADDING_VALUE @0x58;
    reg {
        name = "D_BANK";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATA_BANK[4:0];
        DATA_BANK->desc="
////number of data banks - 1
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WEIGHT_BANK[20:16];
        WEIGHT_BANK->desc="
////number of weight banks - 1
";
    }D_BANK @0x5c;
    reg {
        name = "D_PRA_CFG";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PRA_TRUNCATE[1:0];
        PRA_TRUNCATE->desc="
////PRA truncate, range: 0~2
";
    }D_PRA_CFG @0x60;
    reg {
        name = "D_CYA";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CYA[31:0];
        CYA->desc="
////CYA register
";
    }D_CYA @0x64;
};
regfile regs_NVDLA_CMAC_A{
    default regwidth=32;
    reg {
        name = "S_STATUS";
        desc = "
////Convolution MAC array Registers
";
        enum S_STATUS_STATUS_0_enum {
            IDLE = 2'd0;
            RUNNING = 2'd1;
            PENDING = 2'd2;
        };
        field {
            encode          = S_STATUS_STATUS_0_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_0[1:0];
        STATUS_0->desc="
//// Status of configuration register group 0
";
        enum S_STATUS_STATUS_1_enum {
            IDLE = 2'd0;
            RUNNING = 2'd1;
            PENDING = 2'd2;
        };
        field {
            encode          = S_STATUS_STATUS_1_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_1[17:16];
        STATUS_1->desc="
//// Status of configuration register group 1
";
    }S_STATUS @0x0;
    reg {
        name = "S_POINTER";
        enum S_POINTER_PRODUCER_enum {
            GROUP_0 = 1'd0;
            GROUP_1 = 1'd1;
        };
        field {
            encode          = S_POINTER_PRODUCER_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PRODUCER[0:0];
        PRODUCER->desc="
////Pointer for CSB master to access groups
";
        enum S_POINTER_CONSUMER_enum {
            GROUP_0 = 1'd0;
            GROUP_1 = 1'd1;
        };
        field {
            encode          = S_POINTER_CONSUMER_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CONSUMER[16:16];
        CONSUMER->desc="
////Pointer for datapath to access groups
";
    }S_POINTER @0x4;
    reg {
        name = "D_OP_ENABLE";
        desc = "
//////////////////////////////////////////////////////////////////////////////////
////                                                                            //
////                    Define single group registers here                      //
////                    Register name should shart with prefix D_               //
////                                                                            //
//////////////////////////////////////////////////////////////////////////////////
//// 
";
        enum D_OP_ENABLE_OP_EN_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_OP_ENABLE_OP_EN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rwto;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } OP_EN[0:0];
    }D_OP_ENABLE @0x8;
    reg {
        name = "D_MISC_CFG";
        enum D_MISC_CFG_CONV_MODE_enum {
            DIRECT = 1'd0;
            WINOGRAD = 1'd1;
        };
        field {
            encode          = D_MISC_CFG_CONV_MODE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CONV_MODE[0:0];
        enum D_MISC_CFG_PROC_PRECISION_enum {
            INT8 = 2'd0;
            INT16 = 2'd1;
            FP16 = 2'd2;
        };
        field {
            encode          = D_MISC_CFG_PROC_PRECISION_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PROC_PRECISION[13:12];
    }D_MISC_CFG @0xc;
};
regfile regs_NVDLA_CMAC_B{
    default regwidth=32;
    reg {
        name = "S_STATUS";
        desc = "
////Convolution MAC array Registers
";
        enum S_STATUS_STATUS_0_enum {
            IDLE = 2'd0;
            RUNNING = 2'd1;
            PENDING = 2'd2;
        };
        field {
            encode          = S_STATUS_STATUS_0_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_0[1:0];
        STATUS_0->desc="
//// Status of configuration register group 0
";
        enum S_STATUS_STATUS_1_enum {
            IDLE = 2'd0;
            RUNNING = 2'd1;
            PENDING = 2'd2;
        };
        field {
            encode          = S_STATUS_STATUS_1_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_1[17:16];
        STATUS_1->desc="
//// Status of configuration register group 1
";
    }S_STATUS @0x0;
    reg {
        name = "S_POINTER";
        enum S_POINTER_PRODUCER_enum {
            GROUP_0 = 1'd0;
            GROUP_1 = 1'd1;
        };
        field {
            encode          = S_POINTER_PRODUCER_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PRODUCER[0:0];
        PRODUCER->desc="
////Pointer for CSB master to access groups
";
        enum S_POINTER_CONSUMER_enum {
            GROUP_0 = 1'd0;
            GROUP_1 = 1'd1;
        };
        field {
            encode          = S_POINTER_CONSUMER_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CONSUMER[16:16];
        CONSUMER->desc="
////Pointer for datapath to access groups
";
    }S_POINTER @0x4;
    reg {
        name = "D_OP_ENABLE";
        desc = "
//////////////////////////////////////////////////////////////////////////////////
////                                                                            //
////                    Define single group registers here                      //
////                    Register name should shart with prefix D_               //
////                                                                            //
//////////////////////////////////////////////////////////////////////////////////
//// 
";
        enum D_OP_ENABLE_OP_EN_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_OP_ENABLE_OP_EN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rwto;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } OP_EN[0:0];
    }D_OP_ENABLE @0x8;
    reg {
        name = "D_MISC_CFG";
        enum D_MISC_CFG_CONV_MODE_enum {
            DIRECT = 1'd0;
            WINOGRAD = 1'd1;
        };
        field {
            encode          = D_MISC_CFG_CONV_MODE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CONV_MODE[0:0];
        enum D_MISC_CFG_PROC_PRECISION_enum {
            INT8 = 2'd0;
            INT16 = 2'd1;
            FP16 = 2'd2;
        };
        field {
            encode          = D_MISC_CFG_PROC_PRECISION_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PROC_PRECISION[13:12];
    }D_MISC_CFG @0xc;
};
regfile regs_NVDLA_CACC{
    default regwidth=32;
    reg {
        name = "S_STATUS";
        desc = "
////Convolution Accumulator Registers
";
        enum S_STATUS_STATUS_0_enum {
            IDLE = 2'd0;
            RUNNING = 2'd1;
            PENDING = 2'd2;
        };
        field {
            encode          = S_STATUS_STATUS_0_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_0[1:0];
        STATUS_0->desc="
//// Status of configuration register group 0
";
        enum S_STATUS_STATUS_1_enum {
            IDLE = 2'd0;
            RUNNING = 2'd1;
            PENDING = 2'd2;
        };
        field {
            encode          = S_STATUS_STATUS_1_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_1[17:16];
        STATUS_1->desc="
//// Status of configuration register group 1
";
    }S_STATUS @0x0;
    reg {
        name = "S_POINTER";
        enum S_POINTER_PRODUCER_enum {
            GROUP_0 = 1'd0;
            GROUP_1 = 1'd1;
        };
        field {
            encode          = S_POINTER_PRODUCER_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PRODUCER[0:0];
        PRODUCER->desc="
////Pointer for CSB master to access groups
";
        enum S_POINTER_CONSUMER_enum {
            GROUP_0 = 1'd0;
            GROUP_1 = 1'd1;
        };
        field {
            encode          = S_POINTER_CONSUMER_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CONSUMER[16:16];
        CONSUMER->desc="
////Pointer for datapath to access groups
";
    }S_POINTER @0x4;
    reg {
        name = "D_OP_ENABLE";
        desc = "
//////////////////////////////////////////////////////////////////////////////////
////                                                                            //
////                    Define single group registers here                      //
////                    Register name should shart with prefix D_               //
////                                                                            //
//////////////////////////////////////////////////////////////////////////////////
";
        enum D_OP_ENABLE_OP_EN_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_OP_ENABLE_OP_EN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rwto;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } OP_EN[0:0];
    }D_OP_ENABLE @0x8;
    reg {
        name = "D_MISC_CFG";
        enum D_MISC_CFG_CONV_MODE_enum {
            DIRECT = 1'd0;
            WINOGRAD = 1'd1;
        };
        field {
            encode          = D_MISC_CFG_CONV_MODE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CONV_MODE[0:0];
        enum D_MISC_CFG_PROC_PRECISION_enum {
            INT8 = 2'd0;
            INT16 = 2'd1;
            FP16 = 2'd2;
        };
        field {
            encode          = D_MISC_CFG_PROC_PRECISION_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PROC_PRECISION[13:12];
    }D_MISC_CFG @0xc;
    reg {
        name = "D_DATAOUT_SIZE_0";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAOUT_WIDTH[12:0];
        DATAOUT_WIDTH->desc="
////Output data cube width - 1
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAOUT_HEIGHT[28:16];
        DATAOUT_HEIGHT->desc="
////Output data cube height - 1
";
    }D_DATAOUT_SIZE_0 @0x10;
    reg {
        name = "D_DATAOUT_SIZE_1";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAOUT_CHANNEL[12:0];
        DATAOUT_CHANNEL->desc="
////Output data cube channel - 1
";
    }D_DATAOUT_SIZE_1 @0x14;
    reg {
        name = "D_DATAOUT_ADDR";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAOUT_ADDR[31:0];
        DATAOUT_ADDR->desc="
////Output data address
";
    }D_DATAOUT_ADDR @0x18;
    reg {
        name = "D_BATCH_NUMBER";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BATCHES[4:0];
        BATCHES->desc="
////batch number - 1
";
    }D_BATCH_NUMBER @0x1c;
    reg {
        name = "D_LINE_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LINE_STRIDE[23:0];
        LINE_STRIDE->desc="
////bytes
";
    }D_LINE_STRIDE @0x20;
    reg {
        name = "D_SURF_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SURF_STRIDE[23:0];
        SURF_STRIDE->desc="
////bytes
";
    }D_SURF_STRIDE @0x24;
    reg {
        name = "D_DATAOUT_MAP";
        enum D_DATAOUT_MAP_LINE_PACKED_enum {
            FALSE = 1'd0;
            TRUE = 1'd1;
        };
        field {
            encode          = D_DATAOUT_MAP_LINE_PACKED_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LINE_PACKED[0:0];
        enum D_DATAOUT_MAP_SURF_PACKED_enum {
            FALSE = 1'd0;
            TRUE = 1'd1;
        };
        field {
            encode          = D_DATAOUT_MAP_SURF_PACKED_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SURF_PACKED[16:16];
    }D_DATAOUT_MAP @0x28;
    reg {
        name = "D_CLIP_CFG";
        desc = "
////CLIP_TRUNCATE is unsigned value. Range: 0~16
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CLIP_TRUNCATE[4:0];
        CLIP_TRUNCATE->desc="
////number of bits to be truncated
";
    }D_CLIP_CFG @0x2c;
    reg {
        name = "D_OUT_SATURATION";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SAT_COUNT[31:0];
    }D_OUT_SATURATION @0x30;
    reg {
        name = "D_CYA";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CYA[31:0];
        CYA->desc="
////CYA register
";
    }D_CYA @0x34;
};
regfile regs_NVDLA_SDP_RDMA{
    default regwidth=32;
    reg {
        name = "S_STATUS";
        desc = "
////Read DMA for Single Data Processor Registers
";
        enum S_STATUS_STATUS_0_enum {
            IDLE = 2'd0;
            RUNNING = 2'd1;
            PENDING = 2'd2;
        };
        field {
            encode          = S_STATUS_STATUS_0_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_0[1:0];
        STATUS_0->desc="
//// Status of configuration register group 0
";
        enum S_STATUS_STATUS_1_enum {
            IDLE = 2'd0;
            RUNNING = 2'd1;
            PENDING = 2'd2;
        };
        field {
            encode          = S_STATUS_STATUS_1_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_1[17:16];
        STATUS_1->desc="
//// Status of configuration register group 1
";
    }S_STATUS @0x0;
    reg {
        name = "S_POINTER";
        enum S_POINTER_PRODUCER_enum {
            GROUP_0 = 1'd0;
            GROUP_1 = 1'd1;
        };
        field {
            encode          = S_POINTER_PRODUCER_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PRODUCER[0:0];
        PRODUCER->desc="
////Pointer for CSB master to access groups
";
        enum S_POINTER_CONSUMER_enum {
            GROUP_0 = 1'd0;
            GROUP_1 = 1'd1;
        };
        field {
            encode          = S_POINTER_CONSUMER_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CONSUMER[16:16];
        CONSUMER->desc="
////Pointer for datapath to access groups
";
    }S_POINTER @0x4;
    reg {
        name = "D_OP_ENABLE";
        desc = "
//////////////////////////////////////////////////////////////////////////////////
////                                                                            //
////                    Define single group registers here                      //
////                    Register name should shart with prefix D_               //
////                                                                            //
//////////////////////////////////////////////////////////////////////////////////
//// 
";
        enum D_OP_ENABLE_OP_EN_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_OP_ENABLE_OP_EN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rwto;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } OP_EN[0:0];
    }D_OP_ENABLE @0x8;
    reg {
        name = "D_DATA_CUBE_WIDTH";
        desc = "
//// Data cube configuration, begin
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WIDTH[12:0];
        WIDTH->desc="
//// Element number in width direction, range is 1~8192, actual width = WIDTH+1
";
    }D_DATA_CUBE_WIDTH @0xc;
    reg {
        name = "D_DATA_CUBE_HEIGHT";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } HEIGHT[12:0];
        HEIGHT->desc="
//// Element number in height direction, range is 1~8192, actual height = HEIGHT+1
";
    }D_DATA_CUBE_HEIGHT @0x10;
    reg {
        name = "D_DATA_CUBE_CHANNEL";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CHANNEL[12:0];
        CHANNEL->desc="
//// Element number in channel direction, range is 1~8192, actual channel = CHANNEL+1
";
    }D_DATA_CUBE_CHANNEL @0x14;
    reg {
        name = "D_SRC_BASE_ADDR_LOW";
        desc = "
//// Data cube configuration, end
//// Source data cube memory configuration, begin
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SRC_BASE_ADDR_LOW[31:0];
        SRC_BASE_ADDR_LOW->desc="
////  Start address of the src data cube will be read from external memory
";
    }D_SRC_BASE_ADDR_LOW @0x18;
    reg {
        name = "D_SRC_BASE_ADDR_HIGH";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SRC_BASE_ADDR_HIGH[31:0];
        SRC_BASE_ADDR_HIGH->desc="
////  Start address of the source data cube which will be read from external memory for normalization
";
    }D_SRC_BASE_ADDR_HIGH @0x1c;
    reg {
        name = "D_SRC_LINE_STRIDE";
        desc = "
////  stride between two consective lines within a surface, actual stride value = LINE_STRIDE
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SRC_LINE_STRIDE[31:0];
    }D_SRC_LINE_STRIDE @0x20;
    reg {
        name = "D_SRC_SURFACE_STRIDE";
        desc = "
////  stride between two consective surface, actual stride value = SURFACE_STRIDE
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SRC_SURFACE_STRIDE[31:0];
    }D_SRC_SURFACE_STRIDE @0x24;
    reg {
        name = "D_BRDMA_CFG";
        desc = "
////reg D_MRDMA_CFG                     NVDLA_INCR
////    0:0     rw  MRDMA_DISABLE       init=0
////                                    enum (  NO = 0,
////                                            YES= 1
////                                    )
////
////BRDMA_DISABLE:    when sdp.BS_ALU_SRC is from REG, BRDMA need be disabled
////BRDMA_DATA_USE:   when enabled and set to MUL, sdp.BS_ALU_BYPASS should be set
////                  when enabled and set to ALU, sdp.BS_MUL_BYPASS should be set
////BRDMA_DATA_SIZE: tells the data size per element, and in INT16 Mode, should set to TWO_BYTE
";
        enum D_BRDMA_CFG_BRDMA_DISABLE_enum {
            NO = 1'd0;
            YES = 1'd1;
        };
        field {
            encode          = D_BRDMA_CFG_BRDMA_DISABLE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x1;
            sw_default_mask = 0x0;
        } BRDMA_DISABLE[0:0];
        enum D_BRDMA_CFG_BRDMA_DATA_USE_enum {
            MUL = 2'd0;
            ALU = 2'd1;
            BOTH = 2'd2;
        };
        field {
            encode          = D_BRDMA_CFG_BRDMA_DATA_USE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BRDMA_DATA_USE[2:1];
        enum D_BRDMA_CFG_BRDMA_DATA_SIZE_enum {
            ONE_BYTE = 1'd0;
            TWO_BYTE = 1'd1;
        };
        field {
            encode          = D_BRDMA_CFG_BRDMA_DATA_SIZE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BRDMA_DATA_SIZE[3:3];
        enum D_BRDMA_CFG_BRDMA_DATA_MODE_enum {
            PER_KERNEL = 1'd0;
            PER_ELEMENT = 1'd1;
        };
        field {
            encode          = D_BRDMA_CFG_BRDMA_DATA_MODE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BRDMA_DATA_MODE[4:4];
        enum D_BRDMA_CFG_BRDMA_RAM_TYPE_enum {
            CV = 1'd0;
            MC = 1'd1;
        };
        field {
            encode          = D_BRDMA_CFG_BRDMA_RAM_TYPE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BRDMA_RAM_TYPE[5:5];
    }D_BRDMA_CFG @0x28;
    reg {
        name = "D_BS_BASE_ADDR_LOW";
        desc = "
//// Source data cube memory configuration, begin
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BS_BASE_ADDR_LOW[31:0];
        BS_BASE_ADDR_LOW->desc="
////  Start address of the bias data cube low
";
    }D_BS_BASE_ADDR_LOW @0x2c;
    reg {
        name = "D_BS_BASE_ADDR_HIGH";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BS_BASE_ADDR_HIGH[31:0];
        BS_BASE_ADDR_HIGH->desc="
////  Start address of the bias data cube high
";
    }D_BS_BASE_ADDR_HIGH @0x30;
    reg {
        name = "D_BS_LINE_STRIDE";
        desc = "
////  stride between two consective lines within a surface, actual stride value = LINE_STRIDE
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BS_LINE_STRIDE[31:0];
    }D_BS_LINE_STRIDE @0x34;
    reg {
        name = "D_BS_SURFACE_STRIDE";
        desc = "
////  stride between two consective surface, actual stride value = SURFACE_STRIDE
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BS_SURFACE_STRIDE[31:0];
    }D_BS_SURFACE_STRIDE @0x38;
    reg {
        name = "D_BS_BATCH_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BS_BATCH_STRIDE[31:0];
    }D_BS_BATCH_STRIDE @0x3c;
    reg {
        name = "D_NRDMA_CFG";
        desc = "
////===================================================================
////BRDMA
////===================================================================
";
        enum D_NRDMA_CFG_NRDMA_DISABLE_enum {
            NO = 1'd0;
            YES = 1'd1;
        };
        field {
            encode          = D_NRDMA_CFG_NRDMA_DISABLE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x1;
            sw_default_mask = 0x0;
        } NRDMA_DISABLE[0:0];
        enum D_NRDMA_CFG_NRDMA_DATA_USE_enum {
            MUL = 2'd0;
            ALU = 2'd1;
            BOTH = 2'd2;
        };
        field {
            encode          = D_NRDMA_CFG_NRDMA_DATA_USE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } NRDMA_DATA_USE[2:1];
        enum D_NRDMA_CFG_NRDMA_DATA_SIZE_enum {
            ONE_BYTE = 1'd0;
            TWO_BYTE = 1'd1;
        };
        field {
            encode          = D_NRDMA_CFG_NRDMA_DATA_SIZE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } NRDMA_DATA_SIZE[3:3];
        enum D_NRDMA_CFG_NRDMA_DATA_MODE_enum {
            PER_KERNEL = 1'd0;
            PER_ELEMENT = 1'd1;
        };
        field {
            encode          = D_NRDMA_CFG_NRDMA_DATA_MODE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } NRDMA_DATA_MODE[4:4];
        enum D_NRDMA_CFG_NRDMA_RAM_TYPE_enum {
            CV = 1'd0;
            MC = 1'd1;
        };
        field {
            encode          = D_NRDMA_CFG_NRDMA_RAM_TYPE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } NRDMA_RAM_TYPE[5:5];
    }D_NRDMA_CFG @0x40;
    reg {
        name = "D_BN_BASE_ADDR_LOW";
        desc = "
//// Source data cube memory configuration, begin
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BN_BASE_ADDR_LOW[31:0];
        BN_BASE_ADDR_LOW->desc="
////  Start address of the bias data cube low
";
    }D_BN_BASE_ADDR_LOW @0x44;
    reg {
        name = "D_BN_BASE_ADDR_HIGH";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BN_BASE_ADDR_HIGH[31:0];
        BN_BASE_ADDR_HIGH->desc="
////  Start address of the bias data cube high
";
    }D_BN_BASE_ADDR_HIGH @0x48;
    reg {
        name = "D_BN_LINE_STRIDE";
        desc = "
////  stride between two consective lines within a surface, actual stride value = LINE_STRIDE
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BN_LINE_STRIDE[31:0];
    }D_BN_LINE_STRIDE @0x4c;
    reg {
        name = "D_BN_SURFACE_STRIDE";
        desc = "
////  stride between two consective surface, actual stride value = SURFACE_STRIDE
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BN_SURFACE_STRIDE[31:0];
    }D_BN_SURFACE_STRIDE @0x50;
    reg {
        name = "D_BN_BATCH_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BN_BATCH_STRIDE[31:0];
    }D_BN_BATCH_STRIDE @0x54;
    reg {
        name = "D_ERDMA_CFG";
        desc = "
////===================================================================
////ERDMA
////===================================================================
////ERDMA_DISABLE:    when sdp.BS_ALU_SRC is from REG, ERDMA need be disabled
////ERDMA_DATA_USE:   when enabled and set to MUL, sdp.BS_ALU_BYPASS should be set
////                  when enabled and set to ALU, sdp.BS_MUL_BYPASS should be set
////ERDMA_DATA_SIZE: tells the data size per element, and in INT16 Mode, should set to TWO_BYTE
";
        enum D_ERDMA_CFG_ERDMA_DISABLE_enum {
            NO = 1'd0;
            YES = 1'd1;
        };
        field {
            encode          = D_ERDMA_CFG_ERDMA_DISABLE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x1;
            sw_default_mask = 0x0;
        } ERDMA_DISABLE[0:0];
        enum D_ERDMA_CFG_ERDMA_DATA_USE_enum {
            MUL = 2'd0;
            ALU = 2'd1;
            BOTH = 2'd2;
        };
        field {
            encode          = D_ERDMA_CFG_ERDMA_DATA_USE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERDMA_DATA_USE[2:1];
        enum D_ERDMA_CFG_ERDMA_DATA_SIZE_enum {
            ONE_BYTE = 1'd0;
            TWO_BYTE = 1'd1;
        };
        field {
            encode          = D_ERDMA_CFG_ERDMA_DATA_SIZE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERDMA_DATA_SIZE[3:3];
        enum D_ERDMA_CFG_ERDMA_DATA_MODE_enum {
            PER_KERNEL = 1'd0;
            PER_ELEMENT = 1'd1;
        };
        field {
            encode          = D_ERDMA_CFG_ERDMA_DATA_MODE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERDMA_DATA_MODE[4:4];
        enum D_ERDMA_CFG_ERDMA_RAM_TYPE_enum {
            CV = 1'd0;
            MC = 1'd1;
        };
        field {
            encode          = D_ERDMA_CFG_ERDMA_RAM_TYPE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERDMA_RAM_TYPE[5:5];
    }D_ERDMA_CFG @0x58;
    reg {
        name = "D_EW_BASE_ADDR_LOW";
        desc = "
//// Source data cube memory configuration, begin
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } EW_BASE_ADDR_LOW[31:0];
        EW_BASE_ADDR_LOW->desc="
////  Start address of the bias data cube low
";
    }D_EW_BASE_ADDR_LOW @0x5c;
    reg {
        name = "D_EW_BASE_ADDR_HIGH";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } EW_BASE_ADDR_HIGH[31:0];
        EW_BASE_ADDR_HIGH->desc="
////  Start address of the bias data cube high
";
    }D_EW_BASE_ADDR_HIGH @0x60;
    reg {
        name = "D_EW_LINE_STRIDE";
        desc = "
////  stride between two consective lines within a surface, actual stride value = LINE_STRIDE
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } EW_LINE_STRIDE[31:0];
    }D_EW_LINE_STRIDE @0x64;
    reg {
        name = "D_EW_SURFACE_STRIDE";
        desc = "
////  stride between two consective surface, actual stride value = SURFACE_STRIDE
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } EW_SURFACE_STRIDE[31:0];
    }D_EW_SURFACE_STRIDE @0x68;
    reg {
        name = "D_EW_BATCH_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } EW_BATCH_STRIDE[31:0];
    }D_EW_BATCH_STRIDE @0x6c;
    reg {
        name = "D_FEATURE_MODE_CFG";
        desc = "
//// Feature Configuration, Bias/BatchNorm/Elementwise
";
        enum D_FEATURE_MODE_CFG_FLYING_MODE_enum {
            OFF = 1'd0 {desc = "
//// input data is from MEM
";};
            ON = 1'd1 {desc = "
//// input data is from Conv Core
";};
        };
        field {
            encode          = D_FEATURE_MODE_CFG_FLYING_MODE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } FLYING_MODE[0:0];
        enum D_FEATURE_MODE_CFG_WINOGRAD_enum {
            OFF = 1'd0 {desc = "
//// Direct Conv mode
";};
            ON = 1'd1 {desc = "
//// Winograd mode
";};
        };
        field {
            encode          = D_FEATURE_MODE_CFG_WINOGRAD_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WINOGRAD[1:1];
        enum D_FEATURE_MODE_CFG_IN_PRECISION_enum {
            INT8 = 2'd0;
            INT16 = 2'd1;
            FP16 = 2'd2;
        };
        field {
            encode          = D_FEATURE_MODE_CFG_IN_PRECISION_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } IN_PRECISION[3:2];
        enum D_FEATURE_MODE_CFG_PROC_PRECISION_enum {
            INT8 = 2'd0;
            INT16 = 2'd1;
            FP16 = 2'd2;
        };
        field {
            encode          = D_FEATURE_MODE_CFG_PROC_PRECISION_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PROC_PRECISION[5:4];
        enum D_FEATURE_MODE_CFG_OUT_PRECISION_enum {
            INT8 = 2'd0;
            INT16 = 2'd1;
            FP16 = 2'd2;
        };
        field {
            encode          = D_FEATURE_MODE_CFG_OUT_PRECISION_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } OUT_PRECISION[7:6];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BATCH_NUMBER[12:8];
        BATCH_NUMBER->desc="
//// Batch number, range is 1~32, actual value = BATCH_NUMBER+1
";
    }D_FEATURE_MODE_CFG @0x70;
    reg {
        name = "D_SRC_DMA_CFG";
        enum D_SRC_DMA_CFG_SRC_RAM_TYPE_enum {
            CV = 1'd0;
            MC = 1'd1;
        };
        field {
            encode          = D_SRC_DMA_CFG_SRC_RAM_TYPE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SRC_RAM_TYPE[0:0];
    }D_SRC_DMA_CFG @0x74;
    reg {
        name = "D_STATUS_NAN_INPUT_NUM";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_NAN_INPUT_NUM[31:0];
        STATUS_NAN_INPUT_NUM->desc="
//// input NaN element number
";
    }D_STATUS_NAN_INPUT_NUM @0x78;
    reg {
        name = "D_STATUS_INF_INPUT_NUM";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_INF_INPUT_NUM[31:0];
        STATUS_INF_INPUT_NUM->desc="
//// input Infinity element number
";
    }D_STATUS_INF_INPUT_NUM @0x7c;
    reg {
        name = "D_PERF_ENABLE";
        enum D_PERF_ENABLE_PERF_DMA_EN_enum {
            NO = 1'd0;
            YES = 1'd1;
        };
        field {
            encode          = D_PERF_ENABLE_PERF_DMA_EN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PERF_DMA_EN[0:0];
        enum D_PERF_ENABLE_PERF_NAN_INF_COUNT_EN_enum {
            NO = 1'd0;
            YES = 1'd1;
        };
        field {
            encode          = D_PERF_ENABLE_PERF_NAN_INF_COUNT_EN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PERF_NAN_INF_COUNT_EN[1:1];
    }D_PERF_ENABLE @0x80;
    reg {
        name = "D_PERF_MRDMA_READ_STALL";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } MRDMA_STALL[31:0];
        MRDMA_STALL->desc="
//// Count stall cycles of M read DMA for one layer
";
    }D_PERF_MRDMA_READ_STALL @0x84;
    reg {
        name = "D_PERF_BRDMA_READ_STALL";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BRDMA_STALL[31:0];
        BRDMA_STALL->desc="
//// Count stall cycles of B read DMA for one layer
";
    }D_PERF_BRDMA_READ_STALL @0x88;
    reg {
        name = "D_PERF_NRDMA_READ_STALL";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } NRDMA_STALL[31:0];
        NRDMA_STALL->desc="
//// Count stall cycles of N read DMA for one layer
";
    }D_PERF_NRDMA_READ_STALL @0x8c;
    reg {
        name = "D_PERF_ERDMA_READ_STALL";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERDMA_STALL[31:0];
        ERDMA_STALL->desc="
//// Count stall cycles of E read DMA for one layer
";
    }D_PERF_ERDMA_READ_STALL @0x90;
};
regfile regs_NVDLA_SDP{
    default regwidth=32;
    reg {
        name = "S_STATUS";
        desc = "
////Functional Logic and Write DMA for Single Data Processor Registers
//// 
";
        enum S_STATUS_STATUS_0_enum {
            IDLE = 2'd0;
            RUNNING = 2'd1;
            PENDING = 2'd2;
        };
        field {
            encode          = S_STATUS_STATUS_0_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_0[1:0];
        STATUS_0->desc="
//// Status of configuration register group 0
";
        enum S_STATUS_STATUS_1_enum {
            IDLE = 2'd0;
            RUNNING = 2'd1;
            PENDING = 2'd2;
        };
        field {
            encode          = S_STATUS_STATUS_1_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_1[17:16];
        STATUS_1->desc="
//// Status of configuration register group 1
";
    }S_STATUS @0x0;
    reg {
        name = "S_POINTER";
        enum S_POINTER_PRODUCER_enum {
            GROUP_0 = 1'd0;
            GROUP_1 = 1'd1;
        };
        field {
            encode          = S_POINTER_PRODUCER_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PRODUCER[0:0];
        PRODUCER->desc="
////Pointer for CSB master to access groups
";
        enum S_POINTER_CONSUMER_enum {
            GROUP_0 = 1'd0;
            GROUP_1 = 1'd1;
        };
        field {
            encode          = S_POINTER_CONSUMER_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CONSUMER[16:16];
        CONSUMER->desc="
////Pointer for datapath to access groups
";
    }S_POINTER @0x4;
    reg {
        name = "S_LUT_ACCESS_CFG";
        desc = "
//// LUT Content Program -- begin
//// LUT_DATA When WRITE, the value will be wrote to a specific LUT entry
//// When READ,  the value is read from a specific LUT entry
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rwt;
            reset           = 0x0;
            reset_mask      = 0x3ff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_ADDR[9:0];
        LUT_ADDR->desc="
//// The address to access the Table
";
        enum S_LUT_ACCESS_CFG_LUT_TABLE_ID_enum {
            LE = 1'd0 {desc = "
//// access Linear_Exponent table
";};
            LO = 1'd1 {desc = "
//// access Linear_Only table
";};
        };
        field {
            encode          = S_LUT_ACCESS_CFG_LUT_TABLE_ID_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_TABLE_ID[16:16];
        enum S_LUT_ACCESS_CFG_LUT_ACCESS_TYPE_enum {
            READ = 1'd0 {desc = "
//// Read data from table
";};
            WRITE = 1'd1 {desc = "
//// Write data to table
";};
        };
        field {
            encode          = S_LUT_ACCESS_CFG_LUT_ACCESS_TYPE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_ACCESS_TYPE[17:17];
    }S_LUT_ACCESS_CFG @0x8;
    reg {
        name = "S_LUT_ACCESS_DATA";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rwto;
            reset           = 0x0;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_DATA[15:0];
    }S_LUT_ACCESS_DATA @0xc;
    reg {
        name = "S_LUT_CFG";
        desc = "
//// LUT Content Program -- end
//// LUT Index -- begin
";
        enum S_LUT_CFG_LUT_LE_FUNCTION_enum {
            EXPONENT = 1'd0;
            LINEAR = 1'd1;
        };
        field {
            encode          = S_LUT_CFG_LUT_LE_FUNCTION_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LE_FUNCTION[0:0];
        enum S_LUT_CFG_LUT_UFLOW_PRIORITY_enum {
            LE = 1'd0 {desc = "
////select LE_lut output
";};
            LO = 1'd1 {desc = "
////select LO_lut output
";};
        };
        field {
            encode          = S_LUT_CFG_LUT_UFLOW_PRIORITY_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_UFLOW_PRIORITY[4:4];
        LUT_UFLOW_PRIORITY->desc="
//// indicate which table output should be selected when underflow happened to both table
";
        enum S_LUT_CFG_LUT_OFLOW_PRIORITY_enum {
            LE = 1'd0 {desc = "
////select LE_lut output
";};
            LO = 1'd1 {desc = "
////select LO_lut output
";};
        };
        field {
            encode          = S_LUT_CFG_LUT_OFLOW_PRIORITY_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_OFLOW_PRIORITY[5:5];
        LUT_OFLOW_PRIORITY->desc="
//// indicate which table output should be selected when overflow happened to both table
";
        enum S_LUT_CFG_LUT_HYBRID_PRIORITY_enum {
            LE = 1'd0 {desc = "
////select LE_lut output
";};
            LO = 1'd1 {desc = "
////select LO_lut output
";};
        };
        field {
            encode          = S_LUT_CFG_LUT_HYBRID_PRIORITY_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_HYBRID_PRIORITY[6:6];
        LUT_HYBRID_PRIORITY->desc="
//// indicate which table output should be selected when hit or miss happened to both table
";
    }S_LUT_CFG @0x10;
    reg {
        name = "S_LUT_INFO";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LE_INDEX_OFFSET[7:0];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LE_INDEX_SELECT[15:8];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LO_INDEX_SELECT[23:16];
    }S_LUT_INFO @0x14;
    reg {
        name = "S_LUT_LE_START";
        desc = "
//// Pipeline=INT: INT32
//// Pipeline=FP: FP32, denorm/inf/nan are not allowed;
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LE_START[31:0];
        LUT_LE_START->desc="
//// LE_lut coverage range is [min, max], LUT_LE_START means the value of min.
";
    }S_LUT_LE_START @0x18;
    reg {
        name = "S_LUT_LE_END";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LE_END[31:0];
        LUT_LE_END->desc="
//// LE_lut coverage range is [min, max], LUT_LE_START means the value of min.
";
    }S_LUT_LE_END @0x1c;
    reg {
        name = "S_LUT_LO_START";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LO_START[31:0];
        LUT_LO_START->desc="
//// LO_lut coverage range is [min, max], LUT_LO_START means the value of min.
";
    }S_LUT_LO_START @0x20;
    reg {
        name = "S_LUT_LO_END";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LO_END[31:0];
        LUT_LO_END->desc="
//// LO_lut coverage range is [min, max], LUT_LO_START means the value of min.
";
    }S_LUT_LO_END @0x24;
    reg {
        name = "S_LUT_LE_SLOPE_SCALE";
        desc = "
//// Pipeline=INT: INT16;
//// Pipeline=FP: FP16, inf/nan are not supported
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LE_SLOPE_UFLOW_SCALE[15:0];
        LUT_LE_SLOPE_UFLOW_SCALE->desc="
//// slope scale parameter for LE_lut underflow, signed value.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LE_SLOPE_OFLOW_SCALE[31:16];
        LUT_LE_SLOPE_OFLOW_SCALE->desc="
//// slope scale parameter for LE_lut overflow, signed value.
";
    }S_LUT_LE_SLOPE_SCALE @0x28;
    reg {
        name = "S_LUT_LE_SLOPE_SHIFT";
        desc = "
//// Pipeline=INT: UINT5
//// Pipeline=FP: DONT care
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LE_SLOPE_UFLOW_SHIFT[4:0];
        LUT_LE_SLOPE_UFLOW_SHIFT->desc="
//// slope shift parameter for LE_lut underflow, signed value, shift right if a positive num, shift left if a negative num.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LE_SLOPE_OFLOW_SHIFT[9:5];
        LUT_LE_SLOPE_OFLOW_SHIFT->desc="
//// slope shift parameter for LE_lut overflow, signed value, shift right if a positive num, shift left if a negative num.
";
    }S_LUT_LE_SLOPE_SHIFT @0x2c;
    reg {
        name = "S_LUT_LO_SLOPE_SCALE";
        desc = "
//// Pipeline=INT: INT16;
//// Pipeline=FP: FP16, inf/nan are not supported
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LO_SLOPE_UFLOW_SCALE[15:0];
        LUT_LO_SLOPE_UFLOW_SCALE->desc="
//// slope scale parameter for LO_lut underflow, signed value.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LO_SLOPE_OFLOW_SCALE[31:16];
        LUT_LO_SLOPE_OFLOW_SCALE->desc="
//// slope scale parameter for LO_lut overflow, signed value.
";
    }S_LUT_LO_SLOPE_SCALE @0x30;
    reg {
        name = "S_LUT_LO_SLOPE_SHIFT";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LO_SLOPE_UFLOW_SHIFT[4:0];
        LUT_LO_SLOPE_UFLOW_SHIFT->desc="
//// slope shift parameter for LO_lut underflow, signed value, shift right if a positive num, shift left if a negative num.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LO_SLOPE_OFLOW_SHIFT[9:5];
        LUT_LO_SLOPE_OFLOW_SHIFT->desc="
//// slope shift parameter for LO_lut overflow, signed value, shift right if a positive num, shift left if a negative num.
";
    }S_LUT_LO_SLOPE_SHIFT @0x34;
    reg {
        name = "D_OP_ENABLE";
        desc = "
//// LUT Index -- end
//////////////////////////////////////////////////////////////////////////////////
////                                                                            //
////                    Define single group registers here                      //
////                    Register name should shart with prefix D_               //
////                                                                            //
//////////////////////////////////////////////////////////////////////////////////
//// 
";
        enum D_OP_ENABLE_OP_EN_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_OP_ENABLE_OP_EN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rwto;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } OP_EN[0:0];
    }D_OP_ENABLE @0x38;
    reg {
        name = "D_DATA_CUBE_WIDTH";
        desc = "
//// Data cube configuration, begin
//// Pipeline = INT/FP, U13
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WIDTH[12:0];
        WIDTH->desc="
//// Element number in width direction, range is 1~8192, actual width = WIDTH+1
";
    }D_DATA_CUBE_WIDTH @0x3c;
    reg {
        name = "D_DATA_CUBE_HEIGHT";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } HEIGHT[12:0];
        HEIGHT->desc="
//// Element number in height direction, range is 1~8192, actual height = HEIGHT+1
";
    }D_DATA_CUBE_HEIGHT @0x40;
    reg {
        name = "D_DATA_CUBE_CHANNEL";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CHANNEL[12:0];
        CHANNEL->desc="
//// Element number in channel direction, range is 1~8192, actual channel = CHANNEL+1
";
    }D_DATA_CUBE_CHANNEL @0x44;
    reg {
        name = "D_DST_BASE_ADDR_LOW";
        desc = "
//// Data cube configuration, end
//// Destination data cube memory configuration, begin
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DST_BASE_ADDR_LOW[31:0];
        DST_BASE_ADDR_LOW->desc="
////  Start address of the destination data cube which will be wrote to external memory
";
    }D_DST_BASE_ADDR_LOW @0x48;
    reg {
        name = "D_DST_BASE_ADDR_HIGH";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DST_BASE_ADDR_HIGH[31:0];
        DST_BASE_ADDR_HIGH->desc="
////  Start address of the destination data cube which will be wrote external memory
";
    }D_DST_BASE_ADDR_HIGH @0x4c;
    reg {
        name = "D_DST_LINE_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DST_LINE_STRIDE[31:0];
        DST_LINE_STRIDE->desc="
////  Specify stride between two consective lines within a surface, actual stride value = LINE_STRIDE
";
    }D_DST_LINE_STRIDE @0x50;
    reg {
        name = "D_DST_SURFACE_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DST_SURFACE_STRIDE[31:0];
        DST_SURFACE_STRIDE->desc="
////  Specify stride between two consective surface, actual stride value = SURFACE_STRIDE
";
    }D_DST_SURFACE_STRIDE @0x54;
    reg {
        name = "D_DP_BS_CFG";
        desc = "
////====================================================
//// Bias
////====================================================
";
        enum D_DP_BS_CFG_BS_BYPASS_enum {
            NO = 1'd0;
            YES = 1'd1;
        };
        field {
            encode          = D_DP_BS_CFG_BS_BYPASS_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x1;
            sw_default_mask = 0x0;
        } BS_BYPASS[0:0];
        enum D_DP_BS_CFG_BS_ALU_BYPASS_enum {
            NO = 1'd0;
            YES = 1'd1;
        };
        field {
            encode          = D_DP_BS_CFG_BS_ALU_BYPASS_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x1;
            sw_default_mask = 0x0;
        } BS_ALU_BYPASS[1:1];
        enum D_DP_BS_CFG_BS_ALU_ALGO_enum {
            MAX = 2'd0;
            MIN = 2'd1;
            SUM = 2'd2;
        };
        field {
            encode          = D_DP_BS_CFG_BS_ALU_ALGO_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BS_ALU_ALGO[3:2];
        enum D_DP_BS_CFG_BS_MUL_BYPASS_enum {
            NO = 1'd0;
            YES = 1'd1;
        };
        field {
            encode          = D_DP_BS_CFG_BS_MUL_BYPASS_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x1;
            sw_default_mask = 0x0;
        } BS_MUL_BYPASS[4:4];
        enum D_DP_BS_CFG_BS_MUL_PRELU_enum {
            NO = 1'd0;
            YES = 1'd1;
        };
        field {
            encode          = D_DP_BS_CFG_BS_MUL_PRELU_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BS_MUL_PRELU[5:5];
        enum D_DP_BS_CFG_BS_RELU_BYPASS_enum {
            NO = 1'd0;
            YES = 1'd1;
        };
        field {
            encode          = D_DP_BS_CFG_BS_RELU_BYPASS_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x1;
            sw_default_mask = 0x0;
        } BS_RELU_BYPASS[6:6];
    }D_DP_BS_CFG @0x58;
    reg {
        name = "D_DP_BS_ALU_CFG";
        enum D_DP_BS_ALU_CFG_BS_ALU_SRC_enum {
            REG = 1'd0;
            MEM = 1'd1;
        };
        field {
            encode          = D_DP_BS_ALU_CFG_BS_ALU_SRC_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BS_ALU_SRC[0:0];
        BS_ALU_SRC->desc="
////    1:1     rw  BS_ALU_SHIFT_DIR    init=0
////                                    enum (  LEFT   =0,
////                                            RIGHT  =1 
////                                    )
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BS_ALU_SHIFT_VALUE[13:8];
        BS_ALU_SHIFT_VALUE->desc="
//// U6, not used for FP pipeline
";
    }D_DP_BS_ALU_CFG @0x5c;
    reg {
        name = "D_DP_BS_ALU_SRC_VALUE";
        desc = "
//// Pipeline=INT: INT16;
//// Pipeline=FP: FP16, nan/inf are not supported
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BS_ALU_OPERAND[15:0];
    }D_DP_BS_ALU_SRC_VALUE @0x60;
    reg {
        name = "D_DP_BS_MUL_CFG";
        enum D_DP_BS_MUL_CFG_BS_MUL_SRC_enum {
            REG = 1'd0;
            MEM = 1'd1;
        };
        field {
            encode          = D_DP_BS_MUL_CFG_BS_MUL_SRC_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BS_MUL_SRC[0:0];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BS_MUL_SHIFT_VALUE[15:8];
        BS_MUL_SHIFT_VALUE->desc="
//// Truncate after multiplier in DP pipeline
";
    }D_DP_BS_MUL_CFG @0x64;
    reg {
        name = "D_DP_BS_MUL_SRC_VALUE";
        desc = "
//// Pipeline=INT: INT16;
//// Pipeline=FP: FP16, nan/inf are not supported
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BS_MUL_OPERAND[15:0];
    }D_DP_BS_MUL_SRC_VALUE @0x68;
    reg {
        name = "D_DP_BN_CFG";
        desc = "
////====================================================
//// Batch Normalization
////====================================================
//// Module Functional Configuration on the first DP, which is mainly for Batch Normorlization, but could be used for other purpuse too
";
        enum D_DP_BN_CFG_BN_BYPASS_enum {
            NO = 1'd0;
            YES = 1'd1;
        };
        field {
            encode          = D_DP_BN_CFG_BN_BYPASS_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x1;
            sw_default_mask = 0x0;
        } BN_BYPASS[0:0];
        enum D_DP_BN_CFG_BN_ALU_BYPASS_enum {
            NO = 1'd0;
            YES = 1'd1;
        };
        field {
            encode          = D_DP_BN_CFG_BN_ALU_BYPASS_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x1;
            sw_default_mask = 0x0;
        } BN_ALU_BYPASS[1:1];
        enum D_DP_BN_CFG_BN_ALU_ALGO_enum {
            MAX = 2'd0;
            MIN = 2'd1;
            SUM = 2'd2;
        };
        field {
            encode          = D_DP_BN_CFG_BN_ALU_ALGO_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BN_ALU_ALGO[3:2];
        enum D_DP_BN_CFG_BN_MUL_BYPASS_enum {
            NO = 1'd0;
            YES = 1'd1;
        };
        field {
            encode          = D_DP_BN_CFG_BN_MUL_BYPASS_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x1;
            sw_default_mask = 0x0;
        } BN_MUL_BYPASS[4:4];
        enum D_DP_BN_CFG_BN_MUL_PRELU_enum {
            NO = 1'd0;
            YES = 1'd1;
        };
        field {
            encode          = D_DP_BN_CFG_BN_MUL_PRELU_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BN_MUL_PRELU[5:5];
        enum D_DP_BN_CFG_BN_RELU_BYPASS_enum {
            NO = 1'd0;
            YES = 1'd1;
        };
        field {
            encode          = D_DP_BN_CFG_BN_RELU_BYPASS_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x1;
            sw_default_mask = 0x0;
        } BN_RELU_BYPASS[6:6];
    }D_DP_BN_CFG @0x6c;
    reg {
        name = "D_DP_BN_ALU_CFG";
        enum D_DP_BN_ALU_CFG_BN_ALU_SRC_enum {
            REG = 1'd0;
            MEM = 1'd1;
        };
        field {
            encode          = D_DP_BN_ALU_CFG_BN_ALU_SRC_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BN_ALU_SRC[0:0];
        BN_ALU_SRC->desc="
////    1:1     rw  BN_ALU_SHIFT_DIR    init=0
////                                    enum (  LEFT   =0,
////                                            RIGHT  =1 
////                                    )
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BN_ALU_SHIFT_VALUE[13:8];
        BN_ALU_SHIFT_VALUE->desc="
//// U6, not used for FP pipe
";
    }D_DP_BN_ALU_CFG @0x70;
    reg {
        name = "D_DP_BN_ALU_SRC_VALUE";
        desc = "
//// Pipeline=INT: INT16;
//// Pipeline=FP: FP16, nan/inf are not supported
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BN_ALU_OPERAND[15:0];
    }D_DP_BN_ALU_SRC_VALUE @0x74;
    reg {
        name = "D_DP_BN_MUL_CFG";
        enum D_DP_BN_MUL_CFG_BN_MUL_SRC_enum {
            REG = 1'd0;
            MEM = 1'd1;
        };
        field {
            encode          = D_DP_BN_MUL_CFG_BN_MUL_SRC_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BN_MUL_SRC[0:0];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BN_MUL_SHIFT_VALUE[15:8];
        BN_MUL_SHIFT_VALUE->desc="
//// Truncate value after BN multiplier in DP pipeline, U8
";
    }D_DP_BN_MUL_CFG @0x78;
    reg {
        name = "D_DP_BN_MUL_SRC_VALUE";
        desc = "
//// Pipeline=INT: INT16;
//// Pipeline=FP: FP16, nan/inf are not supported
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BN_MUL_OPERAND[15:0];
    }D_DP_BN_MUL_SRC_VALUE @0x7c;
    reg {
        name = "D_DP_EW_CFG";
        desc = "
////====================================================
//// Element Wise
////====================================================
//// EW_BYPASS: bypass the whole module, all ALU/MUL/LUT will be bypassed
//// EW_ALU_BYPASS: bypass ALU(max/min/sum depends on ALU_ALGO field) logic
//// EW_ALU_ALGO:   output = max/min/sum of two input
//// EW_MUL_BYPASS: bypass MULTIPLIER logic
//// EW_MUL_PRELU:  only do a MUL when the incoming data is negtive, and the operand from RDMA is per channel
////                and the previous stage of RELU need be set as BYPASS to make the negtive number unchanged
//// EW_RELU_BYPASS: bypass RELU logic
";
        enum D_DP_EW_CFG_EW_BYPASS_enum {
            NO = 1'd0;
            YES = 1'd1;
        };
        field {
            encode          = D_DP_EW_CFG_EW_BYPASS_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x1;
            sw_default_mask = 0x0;
        } EW_BYPASS[0:0];
        enum D_DP_EW_CFG_EW_ALU_BYPASS_enum {
            NO = 1'd0;
            YES = 1'd1;
        };
        field {
            encode          = D_DP_EW_CFG_EW_ALU_BYPASS_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x1;
            sw_default_mask = 0x0;
        } EW_ALU_BYPASS[1:1];
        enum D_DP_EW_CFG_EW_ALU_ALGO_enum {
            MAX = 2'd0;
            MIN = 2'd1;
            SUM = 2'd2;
            EQL = 2'd3;
        };
        field {
            encode          = D_DP_EW_CFG_EW_ALU_ALGO_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } EW_ALU_ALGO[3:2];
        enum D_DP_EW_CFG_EW_MUL_BYPASS_enum {
            NO = 1'd0;
            YES = 1'd1;
        };
        field {
            encode          = D_DP_EW_CFG_EW_MUL_BYPASS_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x1;
            sw_default_mask = 0x0;
        } EW_MUL_BYPASS[4:4];
        enum D_DP_EW_CFG_EW_MUL_PRELU_enum {
            NO = 1'd0;
            YES = 1'd1;
        };
        field {
            encode          = D_DP_EW_CFG_EW_MUL_PRELU_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } EW_MUL_PRELU[5:5];
        enum D_DP_EW_CFG_EW_LUT_BYPASS_enum {
            NO = 1'd0;
            YES = 1'd1;
        };
        field {
            encode          = D_DP_EW_CFG_EW_LUT_BYPASS_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x1;
            sw_default_mask = 0x0;
        } EW_LUT_BYPASS[6:6];
    }D_DP_EW_CFG @0x80;
    reg {
        name = "D_DP_EW_ALU_CFG";
        enum D_DP_EW_ALU_CFG_EW_ALU_SRC_enum {
            REG = 1'd0;
            MEM = 1'd1;
        };
        field {
            encode          = D_DP_EW_ALU_CFG_EW_ALU_SRC_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } EW_ALU_SRC[0:0];
        enum D_DP_EW_ALU_CFG_EW_ALU_CVT_BYPASS_enum {
            NO = 1'd0;
            YES = 1'd1;
        };
        field {
            encode          = D_DP_EW_ALU_CFG_EW_ALU_CVT_BYPASS_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x1;
            sw_default_mask = 0x0;
        } EW_ALU_CVT_BYPASS[1:1];
    }D_DP_EW_ALU_CFG @0x84;
    reg {
        name = "D_DP_EW_ALU_SRC_VALUE";
        desc = "
//// Pipeline=INT: INT32;
//// Pipeline=FP: FP32, denorm/nan/inf are not supported
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } EW_ALU_OPERAND[31:0];
    }D_DP_EW_ALU_SRC_VALUE @0x88;
    reg {
        name = "D_DP_EW_ALU_CVT_OFFSET_VALUE";
        desc = "
//// Pipeline=INT: INT32;
//// Pipeline=FP: Not used 
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } EW_ALU_CVT_OFFSET[31:0];
    }D_DP_EW_ALU_CVT_OFFSET_VALUE @0x8c;
    reg {
        name = "D_DP_EW_ALU_CVT_SCALE_VALUE";
        desc = "
//// Pipeline=INT: INT16;
//// Pipeline=FP: Not used 
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } EW_ALU_CVT_SCALE[15:0];
    }D_DP_EW_ALU_CVT_SCALE_VALUE @0x90;
    reg {
        name = "D_DP_EW_ALU_CVT_TRUNCATE_VALUE";
        desc = "
//// Pipeline=INT: U6;
//// Pipeline=FP: Not used 
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } EW_ALU_CVT_TRUNCATE[5:0];
    }D_DP_EW_ALU_CVT_TRUNCATE_VALUE @0x94;
    reg {
        name = "D_DP_EW_MUL_CFG";
        enum D_DP_EW_MUL_CFG_EW_MUL_SRC_enum {
            REG = 1'd0;
            MEM = 1'd1;
        };
        field {
            encode          = D_DP_EW_MUL_CFG_EW_MUL_SRC_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } EW_MUL_SRC[0:0];
        enum D_DP_EW_MUL_CFG_EW_MUL_CVT_BYPASS_enum {
            NO = 1'd0;
            YES = 1'd1;
        };
        field {
            encode          = D_DP_EW_MUL_CFG_EW_MUL_CVT_BYPASS_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x1;
            sw_default_mask = 0x0;
        } EW_MUL_CVT_BYPASS[1:1];
    }D_DP_EW_MUL_CFG @0x98;
    reg {
        name = "D_DP_EW_MUL_SRC_VALUE";
        desc = "
//// Pipeline=INT: INT32;
//// Pipeline=FP: FP32, denorm/nan/inf are not supported
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } EW_MUL_OPERAND[31:0];
    }D_DP_EW_MUL_SRC_VALUE @0x9c;
    reg {
        name = "D_DP_EW_MUL_CVT_OFFSET_VALUE";
        desc = "
//// Pipeline=INT: INT32;
//// Pipeline=FP: Not used 
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } EW_MUL_CVT_OFFSET[31:0];
    }D_DP_EW_MUL_CVT_OFFSET_VALUE @0xa0;
    reg {
        name = "D_DP_EW_MUL_CVT_SCALE_VALUE";
        desc = "
//// Pipeline=INT: INT16;
//// Pipeline=FP: Not used 
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } EW_MUL_CVT_SCALE[15:0];
    }D_DP_EW_MUL_CVT_SCALE_VALUE @0xa4;
    reg {
        name = "D_DP_EW_MUL_CVT_TRUNCATE_VALUE";
        desc = "
//// Pipeline=INT: U6;
//// Pipeline=FP: Not used 
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } EW_MUL_CVT_TRUNCATE[5:0];
    }D_DP_EW_MUL_CVT_TRUNCATE_VALUE @0xa8;
    reg {
        name = "D_DP_EW_TRUNCATE_VALUE";
        desc = "
//// Pipeline=INT: U8;
//// Pipeline=FP: Not used 
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3ff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } EW_TRUNCATE[9:0];
    }D_DP_EW_TRUNCATE_VALUE @0xac;
    reg {
        name = "D_FEATURE_MODE_CFG";
        desc = "
//// Feature Configuration, Bias/BatchNorm/Elementwise
//// BATCH_NUMBER: +1
";
        enum D_FEATURE_MODE_CFG_FLYING_MODE_enum {
            OFF = 1'd0 {desc = "
//// input data is from external Memory
";};
            ON = 1'd1 {desc = "
//// input data is from ConvC
";};
        };
        field {
            encode          = D_FEATURE_MODE_CFG_FLYING_MODE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } FLYING_MODE[0:0];
        enum D_FEATURE_MODE_CFG_OUTPUT_DST_enum {
            MEM = 1'd0 {desc = "
//// Destination is external memory
";};
            PDP = 1'd1 {desc = "
//// Destination is planar data processor
";};
        };
        field {
            encode          = D_FEATURE_MODE_CFG_OUTPUT_DST_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } OUTPUT_DST[1:1];
        OUTPUT_DST->desc="
//// Output data destination
";
        enum D_FEATURE_MODE_CFG_WINOGRAD_enum {
            OFF = 1'd0;
            ON = 1'd1;
        };
        field {
            encode          = D_FEATURE_MODE_CFG_WINOGRAD_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WINOGRAD[2:2];
        enum D_FEATURE_MODE_CFG_NAN_TO_ZERO_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_FEATURE_MODE_CFG_NAN_TO_ZERO_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } NAN_TO_ZERO[3:3];
        NAN_TO_ZERO->desc="
////option to flush input NaN to zero
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } BATCH_NUMBER[12:8];
        BATCH_NUMBER->desc="
//// Batch number, range is 1~32, actual value = BATCH_NUMBER+1
";
    }D_FEATURE_MODE_CFG @0xb0;
    reg {
        name = "D_DST_DMA_CFG";
        enum D_DST_DMA_CFG_DST_RAM_TYPE_enum {
            CV = 1'd0;
            MC = 1'd1;
        };
        field {
            encode          = D_DST_DMA_CFG_DST_RAM_TYPE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DST_RAM_TYPE[0:0];
    }D_DST_DMA_CFG @0xb4;
    reg {
        name = "D_DST_BATCH_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DST_BATCH_STRIDE[31:0];
    }D_DST_BATCH_STRIDE @0xb8;
    reg {
        name = "D_DATA_FORMAT";
        desc = "
//// Destination data cube memory configuration, end
";
        enum D_DATA_FORMAT_PROC_PRECISION_enum {
            INT8 = 2'd0;
            INT16 = 2'd1;
            FP16 = 2'd2;
        };
        field {
            encode          = D_DATA_FORMAT_PROC_PRECISION_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PROC_PRECISION[1:0];
        enum D_DATA_FORMAT_OUT_PRECISION_enum {
            INT8 = 2'd0;
            INT16 = 2'd1;
            FP16 = 2'd2;
        };
        field {
            encode          = D_DATA_FORMAT_OUT_PRECISION_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } OUT_PRECISION[3:2];
    }D_DATA_FORMAT @0xbc;
    reg {
        name = "D_CVT_OFFSET";
        desc = "
//// Pipeline=INT: INT32;
//// Pipeline=FP: Not used 
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CVT_OFFSET[31:0];
        CVT_OFFSET->desc="
////  Offset which has been performed on output data before write to DMA
";
    }D_CVT_OFFSET @0xc0;
    reg {
        name = "D_CVT_SCALE";
        desc = "
//// Pipeline=INT: INT16;
//// Pipeline=FP: Not used 
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CVT_SCALE[15:0];
        CVT_SCALE->desc="
////  Scaling factor which has been performed on output data before write to DMA
";
    }D_CVT_SCALE @0xc4;
    reg {
        name = "D_CVT_SHIFT";
        desc = "
//// Pipeline=INT: U6;
//// Pipeline=FP: Not used 
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CVT_SHIFT[5:0];
    }D_CVT_SHIFT @0xc8;
    reg {
        name = "D_STATUS";
        desc = "
////status register
";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_UNEQUAL[0:0];
    }D_STATUS @0xcc;
    reg {
        name = "D_STATUS_NAN_INPUT_NUM";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_NAN_INPUT_NUM[31:0];
        STATUS_NAN_INPUT_NUM->desc="
//// input NaN element number
";
    }D_STATUS_NAN_INPUT_NUM @0xd0;
    reg {
        name = "D_STATUS_INF_INPUT_NUM";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_INF_INPUT_NUM[31:0];
        STATUS_INF_INPUT_NUM->desc="
//// input Infinity element number
";
    }D_STATUS_INF_INPUT_NUM @0xd4;
    reg {
        name = "D_STATUS_NAN_OUTPUT_NUM";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_NAN_OUTPUT_NUM[31:0];
        STATUS_NAN_OUTPUT_NUM->desc="
//// output NaN element number
";
    }D_STATUS_NAN_OUTPUT_NUM @0xd8;
    reg {
        name = "D_PERF_ENABLE";
        enum D_PERF_ENABLE_PERF_DMA_EN_enum {
            NO = 1'd0;
            YES = 1'd1;
        };
        field {
            encode          = D_PERF_ENABLE_PERF_DMA_EN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PERF_DMA_EN[0:0];
        enum D_PERF_ENABLE_PERF_LUT_EN_enum {
            NO = 1'd0;
            YES = 1'd1;
        };
        field {
            encode          = D_PERF_ENABLE_PERF_LUT_EN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PERF_LUT_EN[1:1];
        enum D_PERF_ENABLE_PERF_SAT_EN_enum {
            NO = 1'd0;
            YES = 1'd1;
        };
        field {
            encode          = D_PERF_ENABLE_PERF_SAT_EN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PERF_SAT_EN[2:2];
        enum D_PERF_ENABLE_PERF_NAN_INF_COUNT_EN_enum {
            NO = 1'd0;
            YES = 1'd1;
        };
        field {
            encode          = D_PERF_ENABLE_PERF_NAN_INF_COUNT_EN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PERF_NAN_INF_COUNT_EN[3:3];
    }D_PERF_ENABLE @0xdc;
    reg {
        name = "D_PERF_WDMA_WRITE_STALL";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WDMA_STALL[31:0];
        WDMA_STALL->desc="
//// Count stall cycles of write DMA for one layer
";
    }D_PERF_WDMA_WRITE_STALL @0xe0;
    reg {
        name = "D_PERF_LUT_UFLOW";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_UFLOW[31:0];
        LUT_UFLOW->desc="
//// element number of both table underflow
";
    }D_PERF_LUT_UFLOW @0xe4;
    reg {
        name = "D_PERF_LUT_OFLOW";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_OFLOW[31:0];
        LUT_OFLOW->desc="
//// element number of both table overflow
";
    }D_PERF_LUT_OFLOW @0xe8;
    reg {
        name = "D_PERF_OUT_SATURATION";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } OUT_SATURATION[31:0];
        OUT_SATURATION->desc="
//// element number of both table overflow
";
    }D_PERF_OUT_SATURATION @0xec;
    reg {
        name = "D_PERF_LUT_HYBRID";
        desc = "
//// element number of both hit, or both miss situation that element underflow one table and at the same time overflow the other. 
";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_HYBRID[31:0];
    }D_PERF_LUT_HYBRID @0xf0;
    reg {
        name = "D_PERF_LUT_LE_HIT";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LE_HIT[31:0];
        LUT_LE_HIT->desc="
//// element number of only linear_exponent table hitted
";
    }D_PERF_LUT_LE_HIT @0xf4;
    reg {
        name = "D_PERF_LUT_LO_HIT";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LO_HIT[31:0];
        LUT_LO_HIT->desc="
//// element number of only linear_only table hitted
";
    }D_PERF_LUT_LO_HIT @0xf8;
};
regfile regs_NVDLA_PDP_RDMA{
    default regwidth=32;
    reg {
        name = "S_STATUS";
        desc = "
////Planar Data Processor Registers
";
        enum S_STATUS_STATUS_0_enum {
            IDLE = 2'd0;
            RUNNING = 2'd1;
            PENDING = 2'd2;
        };
        field {
            encode          = S_STATUS_STATUS_0_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_0[1:0];
        STATUS_0->desc="
//// Status of configuration register group 0
";
        enum S_STATUS_STATUS_1_enum {
            IDLE = 2'd0;
            RUNNING = 2'd1;
            PENDING = 2'd2;
        };
        field {
            encode          = S_STATUS_STATUS_1_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_1[17:16];
        STATUS_1->desc="
//// Status of configuration register group 1
";
    }S_STATUS @0x0;
    reg {
        name = "S_POINTER";
        enum S_POINTER_PRODUCER_enum {
            GROUP_0 = 1'd0;
            GROUP_1 = 1'd1;
        };
        field {
            encode          = S_POINTER_PRODUCER_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PRODUCER[0:0];
        PRODUCER->desc="
////Pointer for CSB master to access groups
";
        enum S_POINTER_CONSUMER_enum {
            GROUP_0 = 1'd0;
            GROUP_1 = 1'd1;
        };
        field {
            encode          = S_POINTER_CONSUMER_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CONSUMER[16:16];
        CONSUMER->desc="
////Pointer for datapath to access groups
";
    }S_POINTER @0x4;
    reg {
        name = "D_OP_ENABLE";
        desc = "
//////////////////////////////////////////////////////////////////////////////////
////                                                                            //
////                    Define single group registers here                      //
////                    Register name should shart with prefix D_               //
////                                                                            //
//////////////////////////////////////////////////////////////////////////////////
//// 
";
        enum D_OP_ENABLE_OP_EN_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_OP_ENABLE_OP_EN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rwto;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } OP_EN[0:0];
    }D_OP_ENABLE @0x8;
    reg {
        name = "D_DATA_CUBE_IN_WIDTH";
        desc = "
//// Data cube configuration, begin
//// Input data cube size settings
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CUBE_IN_WIDTH[12:0];
        CUBE_IN_WIDTH->desc="
//// Element number in width direction, range is 1~8192, actual width = WIDTH+1. only active in non-split mode
";
    }D_DATA_CUBE_IN_WIDTH @0xc;
    reg {
        name = "D_DATA_CUBE_IN_HEIGHT";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CUBE_IN_HEIGHT[12:0];
        CUBE_IN_HEIGHT->desc="
//// Element number in height direction, range is 1~8192, actual height = HEIGHT+1
";
    }D_DATA_CUBE_IN_HEIGHT @0x10;
    reg {
        name = "D_DATA_CUBE_IN_CHANNEL";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CUBE_IN_CHANNEL[12:0];
        CUBE_IN_CHANNEL->desc="
//// Element number in channel direction, range is 1~8192, actual channel = CHANNEL+1
";
    }D_DATA_CUBE_IN_CHANNEL @0x14;
    reg {
        name = "D_FLYING_MODE";
        desc = "
//// Data cube configuration, end
////redundant reg. can be removed, forget dangle in RTL for temp
";
        enum D_FLYING_MODE_FLYING_MODE_enum {
            ON_FLYING = 1'd0 {desc = "
//// Source is SDP
";};
            OFF_FLYING = 1'd1 {desc = "
//// Source is external memory
";};
        };
        field {
            encode          = D_FLYING_MODE_FLYING_MODE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } FLYING_MODE[0:0];
        FLYING_MODE->desc="
//// Input data from SDP 
";
    }D_FLYING_MODE @0x18;
    reg {
        name = "D_SRC_BASE_ADDR_LOW";
        desc = "
//// Source data cube memory configuration, begin
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SRC_BASE_ADDR_LOW[31:0];
        SRC_BASE_ADDR_LOW->desc="
////  Start address of the source data cube which will be read from external memory for normalization
";
    }D_SRC_BASE_ADDR_LOW @0x1c;
    reg {
        name = "D_SRC_BASE_ADDR_HIGH";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SRC_BASE_ADDR_HIGH[31:0];
        SRC_BASE_ADDR_HIGH->desc="
////  Start address of the source data cube which will be read from external memory for normalization
";
    }D_SRC_BASE_ADDR_HIGH @0x20;
    reg {
        name = "D_SRC_LINE_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SRC_LINE_STRIDE[31:0];
        SRC_LINE_STRIDE->desc="
////  Specify stride between two consective lines within a surface, actual stride value = LINE_STRIDE
";
    }D_SRC_LINE_STRIDE @0x24;
    reg {
        name = "D_SRC_SURFACE_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SRC_SURFACE_STRIDE[31:0];
        SRC_SURFACE_STRIDE->desc="
////  Specify stride between two consective surface, actual stride value = SURFACE_STRIDE
";
    }D_SRC_SURFACE_STRIDE @0x28;
    reg {
        name = "D_SRC_RAM_CFG";
        enum D_SRC_RAM_CFG_SRC_RAM_TYPE_enum {
            CV = 1'd0;
            MC = 1'd1;
        };
        field {
            encode          = D_SRC_RAM_CFG_SRC_RAM_TYPE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SRC_RAM_TYPE[0:0];
        SRC_RAM_TYPE->desc="
//// Specify target is MC or CV_SRAM
";
    }D_SRC_RAM_CFG @0x2c;
    reg {
        name = "D_DATA_FORMAT";
        enum D_DATA_FORMAT_INPUT_DATA_enum {
            INT8 = 2'd0;
            INT16 = 2'd1;
            FP16 = 2'd2;
        };
        field {
            encode          = D_DATA_FORMAT_INPUT_DATA_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } INPUT_DATA[1:0];
    }D_DATA_FORMAT @0x30;
    reg {
        name = "D_OPERATION_MODE_CFG";
        desc = "
//// When data buffer could not accommodate all temperal output data within the whole width, input/output data cube will be splited along height x channel plane. Since PDP line buffer size is (64*112bits*8), could accomodate 2048/4096 elements in int16/int8 format, the maximum line buffer limited output width is 2048/16=128 or 4096/32=128, since the width configuration could be 8192, so the split_num could be 8192/128=64. Actual value is SPLIT_NUM+1.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SPLIT_NUM[7:0];
    }D_OPERATION_MODE_CFG @0x34;
    reg {
        name = "D_POOLING_KERNEL_CFG";
        enum D_POOLING_KERNEL_CFG_KERNEL_WIDTH_enum {
            KERNEL_WIDTH_1 = 4'd0;
            KERNEL_WIDTH_2 = 4'd1;
            KERNEL_WIDTH_3 = 4'd2;
            KERNEL_WIDTH_4 = 4'd3;
            KERNEL_WIDTH_5 = 4'd4;
            KERNEL_WIDTH_6 = 4'd5;
            KERNEL_WIDTH_7 = 4'd6;
            KERNEL_WIDTH_8 = 4'd7;
        };
        field {
            encode          = D_POOLING_KERNEL_CFG_KERNEL_WIDTH_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xf;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } KERNEL_WIDTH[3:0];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xf;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } KERNEL_STRIDE_WIDTH[7:4];
        KERNEL_STRIDE_WIDTH->desc="
////+1
";
    }D_POOLING_KERNEL_CFG @0x38;
    reg {
        name = "D_POOLING_PADDING_CFG";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xf;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PAD_WIDTH[3:0];
    }D_POOLING_PADDING_CFG @0x3c;
    reg {
        name = "D_PARTIAL_WIDTH_IN";
        desc = "
//// When data buffer could not accommodate all temperal output data within the whole width, input data cube will be splited along height x channel plane
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3ff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PARTIAL_WIDTH_IN_FIRST[9:0];
        PARTIAL_WIDTH_IN_FIRST->desc="
////only active in split mode, that is SPLIT_NUM is NOT ZERO value. +1
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3ff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PARTIAL_WIDTH_IN_LAST[19:10];
        PARTIAL_WIDTH_IN_LAST->desc="
////only active in split mode, that is SPLIT_NUM is NOT ZERO value. +1
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3ff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PARTIAL_WIDTH_IN_MID[29:20];
        PARTIAL_WIDTH_IN_MID->desc="
////only active in split mode, that is SPLIT_NUM is NOT ZERO value. +1
";
    }D_PARTIAL_WIDTH_IN @0x40;
    reg {
        name = "D_PERF_ENABLE";
        desc = "
//// LUT status, begin
";
        enum D_PERF_ENABLE_DMA_EN_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_PERF_ENABLE_DMA_EN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DMA_EN[0:0];
        DMA_EN->desc="
//// dma perf reg enable control.
";
    }D_PERF_ENABLE @0x44;
    reg {
        name = "D_PERF_READ_STALL";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PERF_READ_STALL[31:0];
        PERF_READ_STALL->desc="
//// element number that for both LUT under-flow.
";
    }D_PERF_READ_STALL @0x48;
    reg {
        name = "D_CYA";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CYA[31:0];
        CYA->desc="
////CYA register
";
    }D_CYA @0x4c;
};
regfile regs_NVDLA_PDP{
    default regwidth=32;
    reg {
        name = "S_STATUS";
        desc = "
////Planar Data Processor Registers
";
        enum S_STATUS_STATUS_0_enum {
            IDLE = 2'd0;
            RUNNING = 2'd1;
            PENDING = 2'd2;
        };
        field {
            encode          = S_STATUS_STATUS_0_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_0[1:0];
        STATUS_0->desc="
//// Status of configuration register group 0
";
        enum S_STATUS_STATUS_1_enum {
            IDLE = 2'd0;
            RUNNING = 2'd1;
            PENDING = 2'd2;
        };
        field {
            encode          = S_STATUS_STATUS_1_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_1[17:16];
        STATUS_1->desc="
//// Status of configuration register group 1
";
    }S_STATUS @0x0;
    reg {
        name = "S_POINTER";
        enum S_POINTER_PRODUCER_enum {
            GROUP_0 = 1'd0;
            GROUP_1 = 1'd1;
        };
        field {
            encode          = S_POINTER_PRODUCER_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PRODUCER[0:0];
        PRODUCER->desc="
////Pointer for CSB master to access groups
";
        enum S_POINTER_CONSUMER_enum {
            GROUP_0 = 1'd0;
            GROUP_1 = 1'd1;
        };
        field {
            encode          = S_POINTER_CONSUMER_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CONSUMER[16:16];
        CONSUMER->desc="
////Pointer for datapath to access groups
";
    }S_POINTER @0x4;
    reg {
        name = "D_OP_ENABLE";
        desc = "
//////////////////////////////////////////////////////////////////////////////////
////                                                                            //
////                    Define single group registers here                      //
////                    Register name should shart with prefix D_               //
////                                                                            //
//////////////////////////////////////////////////////////////////////////////////
//// 
";
        enum D_OP_ENABLE_OP_EN_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_OP_ENABLE_OP_EN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rwto;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } OP_EN[0:0];
    }D_OP_ENABLE @0x8;
    reg {
        name = "D_DATA_CUBE_IN_WIDTH";
        desc = "
//// Data cube configuration, begin
//// Input data cube size settings
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CUBE_IN_WIDTH[12:0];
        CUBE_IN_WIDTH->desc="
//// Element number in width direction used in non-split mode, range is 1~8192, actual width = WIDTH+1
";
    }D_DATA_CUBE_IN_WIDTH @0xc;
    reg {
        name = "D_DATA_CUBE_IN_HEIGHT";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CUBE_IN_HEIGHT[12:0];
        CUBE_IN_HEIGHT->desc="
//// Element number in height direction used in non-split mode, range is 1~8192, actual height = HEIGHT+1
";
    }D_DATA_CUBE_IN_HEIGHT @0x10;
    reg {
        name = "D_DATA_CUBE_IN_CHANNEL";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CUBE_IN_CHANNEL[12:0];
        CUBE_IN_CHANNEL->desc="
//// Element number in channel direction used in non-split mode, range is 1~8192, actual channel = CHANNEL+1
";
    }D_DATA_CUBE_IN_CHANNEL @0x14;
    reg {
        name = "D_DATA_CUBE_OUT_WIDTH";
        desc = "
//// Output data cube size settings
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CUBE_OUT_WIDTH[12:0];
        CUBE_OUT_WIDTH->desc="
//// Element number in width direction used in non-split mode, range is 1~8192, actual width = WIDTH+1
";
    }D_DATA_CUBE_OUT_WIDTH @0x18;
    reg {
        name = "D_DATA_CUBE_OUT_HEIGHT";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CUBE_OUT_HEIGHT[12:0];
        CUBE_OUT_HEIGHT->desc="
//// Element number in height direction used in non-split mode, range is 1~8192, actual height = HEIGHT+1
";
    }D_DATA_CUBE_OUT_HEIGHT @0x1c;
    reg {
        name = "D_DATA_CUBE_OUT_CHANNEL";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CUBE_OUT_CHANNEL[12:0];
        CUBE_OUT_CHANNEL->desc="
//// Element number in channel direction used in non-split mode, range is 1~8192, actual channel = CHANNEL+1
";
    }D_DATA_CUBE_OUT_CHANNEL @0x20;
    reg {
        name = "D_OPERATION_MODE_CFG";
        desc = "
//// Data cube configuration, end
";
        enum D_OPERATION_MODE_CFG_POOLING_METHOD_enum {
            POOLING_METHOD_AVERAGE = 2'd0;
            POOLING_METHOD_MAX = 2'd1;
            POOLING_METHOD_MIN = 2'd2;
        };
        field {
            encode          = D_OPERATION_MODE_CFG_POOLING_METHOD_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } POOLING_METHOD[1:0];
        enum D_OPERATION_MODE_CFG_FLYING_MODE_enum {
            ON_FLYING = 1'd0 {desc = "
//// Source is SDP
";};
            OFF_FLYING = 1'd1 {desc = "
//// Source is external memory
";};
        };
        field {
            encode          = D_OPERATION_MODE_CFG_FLYING_MODE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } FLYING_MODE[4:4];
        FLYING_MODE->desc="
//// Input data from SDP 
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SPLIT_NUM[15:8];
        SPLIT_NUM->desc="
//// When data buffer could not accommodate all temperal output data within the whole width, input/output data cube will be splited along height x channel plane. Since PDP line buffer size is (64*112bits*8), could accomodate 2048/4096 elements in int16/int8 format, the maximum line buffer limited output width is 2048/16=128 or 4096/32=128, since the width configuration could be 8192, so the split_num could be 8192/128=64. Actual value is SPLIT_NUM+1.
";
    }D_OPERATION_MODE_CFG @0x24;
    reg {
        name = "D_NAN_FLUSH_TO_ZERO";
        enum D_NAN_FLUSH_TO_ZERO_NAN_TO_ZERO_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_NAN_FLUSH_TO_ZERO_NAN_TO_ZERO_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } NAN_TO_ZERO[0:0];
        NAN_TO_ZERO->desc="
////option to flush input NaN to zero, only active in off-flying mode
";
    }D_NAN_FLUSH_TO_ZERO @0x28;
    reg {
        name = "D_PARTIAL_WIDTH_IN";
        desc = "
//// When data buffer could not accommodate all temperal output data within the whole width, output data cube will be splited along height x channel plane
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3ff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PARTIAL_WIDTH_IN_FIRST[9:0];
        PARTIAL_WIDTH_IN_FIRST->desc="
////only used in split mode, +1
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3ff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PARTIAL_WIDTH_IN_LAST[19:10];
        PARTIAL_WIDTH_IN_LAST->desc="
////only used in split mode, +1
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3ff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PARTIAL_WIDTH_IN_MID[29:20];
        PARTIAL_WIDTH_IN_MID->desc="
////only used in split mode and SPLIT_NUM is set more than 1, +1. PARTIAL_WIDTH_IN_FIRST + PARTIAL_WIDTH_IN_LAST + PARTIAL_WIDTH_IN_MID = input cube width
";
    }D_PARTIAL_WIDTH_IN @0x2c;
    reg {
        name = "D_PARTIAL_WIDTH_OUT";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3ff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PARTIAL_WIDTH_OUT_FIRST[9:0];
        PARTIAL_WIDTH_OUT_FIRST->desc="
////only used in split mode, +1
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3ff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PARTIAL_WIDTH_OUT_LAST[19:10];
        PARTIAL_WIDTH_OUT_LAST->desc="
////only used in split mode, +1
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3ff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PARTIAL_WIDTH_OUT_MID[29:20];
        PARTIAL_WIDTH_OUT_MID->desc="
////only used in split mode, and SPLIT_NUM is set more than 1, +1. PARTIAL_WIDTH_OUT_FIRST + PARTIAL_WIDTH_OUT_LAST + PARTIAL_WIDTH_OUT_MID = output cube width
";
    }D_PARTIAL_WIDTH_OUT @0x30;
    reg {
        name = "D_POOLING_KERNEL_CFG";
        enum D_POOLING_KERNEL_CFG_KERNEL_WIDTH_enum {
            KERNEL_WIDTH_1 = 4'd0;
            KERNEL_WIDTH_2 = 4'd1;
            KERNEL_WIDTH_3 = 4'd2;
            KERNEL_WIDTH_4 = 4'd3;
            KERNEL_WIDTH_5 = 4'd4;
            KERNEL_WIDTH_6 = 4'd5;
            KERNEL_WIDTH_7 = 4'd6;
            KERNEL_WIDTH_8 = 4'd7;
        };
        field {
            encode          = D_POOLING_KERNEL_CFG_KERNEL_WIDTH_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xf;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } KERNEL_WIDTH[3:0];
        KERNEL_WIDTH->desc="
//// +1
";
        enum D_POOLING_KERNEL_CFG_KERNEL_HEIGHT_enum {
            KERNEL_HEIGHT_1 = 4'd0;
            KERNEL_HEIGHT_2 = 4'd1;
            KERNEL_HEIGHT_3 = 4'd2;
            KERNEL_HEIGHT_4 = 4'd3;
            KERNEL_HEIGHT_5 = 4'd4;
            KERNEL_HEIGHT_6 = 4'd5;
            KERNEL_HEIGHT_7 = 4'd6;
            KERNEL_HEIGHT_8 = 4'd7;
        };
        field {
            encode          = D_POOLING_KERNEL_CFG_KERNEL_HEIGHT_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xf;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } KERNEL_HEIGHT[11:8];
        KERNEL_HEIGHT->desc="
//// +1
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xf;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } KERNEL_STRIDE_WIDTH[19:16];
        KERNEL_STRIDE_WIDTH->desc="
//// +1
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xf;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } KERNEL_STRIDE_HEIGHT[23:20];
        KERNEL_STRIDE_HEIGHT->desc="
//// +1
";
    }D_POOLING_KERNEL_CFG @0x34;
    reg {
        name = "D_RECIP_KERNEL_WIDTH";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1ffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RECIP_KERNEL_WIDTH[16:0];
        RECIP_KERNEL_WIDTH->desc="
//// reciprocal of kernel_width, set to actual value * 2^16 when INT8/INT16 format enabled. and set to actual value for fp16 precision mode with fp17 data format.
";
    }D_RECIP_KERNEL_WIDTH @0x38;
    reg {
        name = "D_RECIP_KERNEL_HEIGHT";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1ffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RECIP_KERNEL_HEIGHT[16:0];
        RECIP_KERNEL_HEIGHT->desc="
//// reciprocal of kernel_height, set to actual value * 2^16 when INT8/INT16 format enabled. and set to actual value for fp16 precision mode with fp17 data format.
";
    }D_RECIP_KERNEL_HEIGHT @0x3c;
    reg {
        name = "D_POOLING_PADDING_CFG";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PAD_LEFT[2:0];
        PAD_LEFT->desc="
////padding number. active for all of pooling mode. 
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PAD_TOP[6:4];
        PAD_TOP->desc="
////padding number. active for all of pooling mode.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PAD_RIGHT[10:8];
        PAD_RIGHT->desc="
////padding number. active for all of pooling mode.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PAD_BOTTOM[14:12];
        PAD_BOTTOM->desc="
////padding number. active for all of pooling mode.
";
    }D_POOLING_PADDING_CFG @0x40;
    reg {
        name = "D_POOLING_PADDING_VALUE_1_CFG";
        desc = "
////PAD_VALUE_1X means the value in padding position. pad value only active in average pooling mode.
////it is a signed value. please note its signed MSB bits,reg setting need signed bit extended.
////For INT8, active pad value is signed 8bit value, 1x active bits is LSB 8bits; 
////For INT16, active pad value is a 16bits number. 1x active bits is LSB 16bits
////For FP16, pad value should always be set to value 0, support +/- 0 with fp17 format,sign bit extended.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7ffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PAD_VALUE_1X[18:0];
    }D_POOLING_PADDING_VALUE_1_CFG @0x44;
    reg {
        name = "D_POOLING_PADDING_VALUE_2_CFG";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7ffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PAD_VALUE_2X[18:0];
    }D_POOLING_PADDING_VALUE_2_CFG @0x48;
    reg {
        name = "D_POOLING_PADDING_VALUE_3_CFG";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7ffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PAD_VALUE_3X[18:0];
    }D_POOLING_PADDING_VALUE_3_CFG @0x4c;
    reg {
        name = "D_POOLING_PADDING_VALUE_4_CFG";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7ffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PAD_VALUE_4X[18:0];
    }D_POOLING_PADDING_VALUE_4_CFG @0x50;
    reg {
        name = "D_POOLING_PADDING_VALUE_5_CFG";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7ffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PAD_VALUE_5X[18:0];
    }D_POOLING_PADDING_VALUE_5_CFG @0x54;
    reg {
        name = "D_POOLING_PADDING_VALUE_6_CFG";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7ffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PAD_VALUE_6X[18:0];
    }D_POOLING_PADDING_VALUE_6_CFG @0x58;
    reg {
        name = "D_POOLING_PADDING_VALUE_7_CFG";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7ffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PAD_VALUE_7X[18:0];
    }D_POOLING_PADDING_VALUE_7_CFG @0x5c;
    reg {
        name = "D_SRC_BASE_ADDR_LOW";
        desc = "
//// Source data cube memory configuration, begin
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SRC_BASE_ADDR_LOW[31:0];
        SRC_BASE_ADDR_LOW->desc="
////  Start address of the source data cube which will be read from external memory for normalization
";
    }D_SRC_BASE_ADDR_LOW @0x60;
    reg {
        name = "D_SRC_BASE_ADDR_HIGH";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SRC_BASE_ADDR_HIGH[31:0];
        SRC_BASE_ADDR_HIGH->desc="
////  Start address of the source data cube which will be read from external memory for normalization
";
    }D_SRC_BASE_ADDR_HIGH @0x64;
    reg {
        name = "D_SRC_LINE_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SRC_LINE_STRIDE[31:0];
        SRC_LINE_STRIDE->desc="
////  Specify stride between two consective lines within a surface, actual stride value = LINE_STRIDE
";
    }D_SRC_LINE_STRIDE @0x68;
    reg {
        name = "D_SRC_SURFACE_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SRC_SURFACE_STRIDE[31:0];
        SRC_SURFACE_STRIDE->desc="
////  Specify stride between two consective surface, actual stride value = SURFACE_STRIDE
";
    }D_SRC_SURFACE_STRIDE @0x6c;
    reg {
        name = "D_DST_BASE_ADDR_LOW";
        desc = "
//// Destination data cube memory configuration, begin
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DST_BASE_ADDR_LOW[31:0];
        DST_BASE_ADDR_LOW->desc="
////  Start address of the destination data cube which will be wrote to external memory
";
    }D_DST_BASE_ADDR_LOW @0x70;
    reg {
        name = "D_DST_BASE_ADDR_HIGH";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DST_BASE_ADDR_HIGH[31:0];
        DST_BASE_ADDR_HIGH->desc="
////  Start address of the destination data cube which will be wrote external memory
";
    }D_DST_BASE_ADDR_HIGH @0x74;
    reg {
        name = "D_DST_LINE_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DST_LINE_STRIDE[31:0];
        DST_LINE_STRIDE->desc="
////  Specify stride between two consective lines within a surface, actual stride value = LINE_STRIDE
";
    }D_DST_LINE_STRIDE @0x78;
    reg {
        name = "D_DST_SURFACE_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DST_SURFACE_STRIDE[31:0];
        DST_SURFACE_STRIDE->desc="
////  Specify stride between two consective surface, actual stride value = SURFACE_STRIDE
";
    }D_DST_SURFACE_STRIDE @0x7c;
    reg {
        name = "D_DST_RAM_CFG";
        enum D_DST_RAM_CFG_DST_RAM_TYPE_enum {
            CV = 1'd0;
            MC = 1'd1;
        };
        field {
            encode          = D_DST_RAM_CFG_DST_RAM_TYPE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DST_RAM_TYPE[0:0];
        DST_RAM_TYPE->desc="
//// Specify target is MC or CV_SRAM
";
    }D_DST_RAM_CFG @0x80;
    reg {
        name = "D_DATA_FORMAT";
        enum D_DATA_FORMAT_INPUT_DATA_enum {
            INT8 = 2'd0;
            INT16 = 2'd1;
            FP16 = 2'd2;
        };
        field {
            encode          = D_DATA_FORMAT_INPUT_DATA_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } INPUT_DATA[1:0];
    }D_DATA_FORMAT @0x84;
    reg {
        name = "D_INF_INPUT_NUM";
        desc = "
////status register
";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } INF_INPUT_NUM[31:0];
        INF_INPUT_NUM->desc="
//// input infinity element number
";
    }D_INF_INPUT_NUM @0x88;
    reg {
        name = "D_NAN_INPUT_NUM";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } NAN_INPUT_NUM[31:0];
        NAN_INPUT_NUM->desc="
//// input NaN element number
";
    }D_NAN_INPUT_NUM @0x8c;
    reg {
        name = "D_NAN_OUTPUT_NUM";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } NAN_OUTPUT_NUM[31:0];
        NAN_OUTPUT_NUM->desc="
//// output NaN element number
";
    }D_NAN_OUTPUT_NUM @0x90;
    reg {
        name = "D_PERF_ENABLE";
        desc = "
//// LUT status, begin
";
        enum D_PERF_ENABLE_DMA_EN_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_PERF_ENABLE_DMA_EN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DMA_EN[0:0];
        DMA_EN->desc="
//// dma perf reg enable control.
";
    }D_PERF_ENABLE @0x94;
    reg {
        name = "D_PERF_WRITE_STALL";
        desc = "
////reg D_PERF_READ_STALL               NVDLA_INCR 
////    31:0    r   PERF_READ_STALL     init=0 // element number that for both LUT under-flow.
////
";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PERF_WRITE_STALL[31:0];
        PERF_WRITE_STALL->desc="
//// element number that for both LUT under-flow.
";
    }D_PERF_WRITE_STALL @0x98;
    reg {
        name = "D_CYA";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CYA[31:0];
        CYA->desc="
////CYA register
";
    }D_CYA @0x9c;
};
regfile regs_NVDLA_CDP_RDMA{
    default regwidth=32;
    reg {
        name = "S_STATUS";
        desc = "
////Read DMA for Channel Data Processor Registers
";
        enum S_STATUS_STATUS_0_enum {
            IDLE = 2'd0;
            RUNNING = 2'd1;
            PENDING = 2'd2;
        };
        field {
            encode          = S_STATUS_STATUS_0_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_0[1:0];
        STATUS_0->desc="
//// Status of configuration register group 0
";
        enum S_STATUS_STATUS_1_enum {
            IDLE = 2'd0;
            RUNNING = 2'd1;
            PENDING = 2'd2;
        };
        field {
            encode          = S_STATUS_STATUS_1_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_1[17:16];
        STATUS_1->desc="
//// Status of configuration register group 1
";
    }S_STATUS @0x0;
    reg {
        name = "S_POINTER";
        enum S_POINTER_PRODUCER_enum {
            GROUP_0 = 1'd0;
            GROUP_1 = 1'd1;
        };
        field {
            encode          = S_POINTER_PRODUCER_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PRODUCER[0:0];
        PRODUCER->desc="
////Pointer for CSB master to access groups
";
        enum S_POINTER_CONSUMER_enum {
            GROUP_0 = 1'd0;
            GROUP_1 = 1'd1;
        };
        field {
            encode          = S_POINTER_CONSUMER_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CONSUMER[16:16];
        CONSUMER->desc="
////Pointer for datapath to access groups
";
    }S_POINTER @0x4;
    reg {
        name = "D_OP_ENABLE";
        desc = "
//////////////////////////////////////////////////////////////////////////////////
////                                                                            //
////                    Define single group registers here                      //
////                    Register name should shart with prefix D_               //
////                                                                            //
//////////////////////////////////////////////////////////////////////////////////
//// 
";
        enum D_OP_ENABLE_OP_EN_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_OP_ENABLE_OP_EN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rwto;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } OP_EN[0:0];
    }D_OP_ENABLE @0x8;
    reg {
        name = "D_DATA_CUBE_WIDTH";
        desc = "
//// Data cube configuration, begin
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WIDTH[12:0];
        WIDTH->desc="
//// Element number in width direction, range is 1~8192, actual width = WIDTH+1
";
    }D_DATA_CUBE_WIDTH @0xc;
    reg {
        name = "D_DATA_CUBE_HEIGHT";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } HEIGHT[12:0];
        HEIGHT->desc="
//// Element number in height direction, range is 1~8192, actual height = HEIGHT+1
";
    }D_DATA_CUBE_HEIGHT @0x10;
    reg {
        name = "D_DATA_CUBE_CHANNEL";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CHANNEL[12:0];
        CHANNEL->desc="
//// Element number in channel direction, range is 1~8192, actual channel = CHANNEL+1
";
    }D_DATA_CUBE_CHANNEL @0x14;
    reg {
        name = "D_SRC_BASE_ADDR_LOW";
        desc = "
//// Data cube configuration, end
//// Source data cube memory configuration, begin
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SRC_BASE_ADDR_LOW[31:0];
        SRC_BASE_ADDR_LOW->desc="
////  Start address of the source data cube which will be read from external memory for normalization
";
    }D_SRC_BASE_ADDR_LOW @0x18;
    reg {
        name = "D_SRC_BASE_ADDR_HIGH";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SRC_BASE_ADDR_HIGH[31:0];
        SRC_BASE_ADDR_HIGH->desc="
////  Start address of the source data cube which will be read from external memory for normalization
";
    }D_SRC_BASE_ADDR_HIGH @0x1c;
    reg {
        name = "D_SRC_LINE_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SRC_LINE_STRIDE[31:0];
        SRC_LINE_STRIDE->desc="
////  Specify stride between two consective lines within a surface, actual stride value = LINE_STRIDE
";
    }D_SRC_LINE_STRIDE @0x20;
    reg {
        name = "D_SRC_SURFACE_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SRC_SURFACE_STRIDE[31:0];
        SRC_SURFACE_STRIDE->desc="
////  Specify stride between two consective surface, actual stride value = SURFACE_STRIDE
";
    }D_SRC_SURFACE_STRIDE @0x24;
    reg {
        name = "D_SRC_DMA_CFG";
        enum D_SRC_DMA_CFG_SRC_RAM_TYPE_enum {
            CV = 1'd0;
            MC = 1'd1;
        };
        field {
            encode          = D_SRC_DMA_CFG_SRC_RAM_TYPE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SRC_RAM_TYPE[0:0];
        SRC_RAM_TYPE->desc="
//// Specify target is MC or CV_SRAM
";
    }D_SRC_DMA_CFG @0x28;
    reg {
        name = "D_SRC_COMPRESSION_EN";
        desc = "
//// Source data is compresed or not, always disable in NVDLA version 1.0
";
        enum D_SRC_COMPRESSION_EN_SRC_COMPRESSION_EN_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_SRC_COMPRESSION_EN_SRC_COMPRESSION_EN_enum;
            sw              = r;
            hw              = r;
            spec_access     = c;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SRC_COMPRESSION_EN[0:0];
    }D_SRC_COMPRESSION_EN @0x2c;
    reg {
        name = "D_OPERATION_MODE";
        desc = "
//// Source data cube memory configuration, end
////Always disable this reg in the 1st verion.
////1:0     rw  OPERATION_MODE      init=0
";
        enum D_OPERATION_MODE_OPERATION_MODE_enum {
            READPHILE = 2'd0;
            WRITEPHILE = 2'd1;
            ORDINARY = 2'd2;
        };
        field {
            encode          = D_OPERATION_MODE_OPERATION_MODE_enum;
            sw              = r;
            hw              = r;
            spec_access     = c;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } OPERATION_MODE[1:0];
    }D_OPERATION_MODE @0x30;
    reg {
        name = "D_DATA_FORMAT";
        enum D_DATA_FORMAT_INPUT_DATA_enum {
            INT8 = 2'd0;
            INT16 = 2'd1;
            FP16 = 2'd2;
        };
        field {
            encode          = D_DATA_FORMAT_INPUT_DATA_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } INPUT_DATA[1:0];
    }D_DATA_FORMAT @0x34;
    reg {
        name = "D_PERF_ENABLE";
        desc = "
///////////////////////////////////////////
//// LUT status, begin
";
        enum D_PERF_ENABLE_DMA_EN_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_PERF_ENABLE_DMA_EN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DMA_EN[0:0];
        DMA_EN->desc="
//// dma perf reg enable control.
";
    }D_PERF_ENABLE @0x38;
    reg {
        name = "D_PERF_READ_STALL";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PERF_READ_STALL[31:0];
        PERF_READ_STALL->desc="
//// element number that for both LUT under-flow.
";
    }D_PERF_READ_STALL @0x3c;
    reg {
        name = "D_CYA";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CYA[31:0];
        CYA->desc="
////CYA register
";
    }D_CYA @0x40;
};
regfile regs_NVDLA_CDP{
    default regwidth=32;
    reg {
        name = "S_STATUS";
        desc = "
////Functional Logic and Write DMA for Channel Data Processor Registers
//// --------------------------------------------------------------------------
";
        enum S_STATUS_STATUS_0_enum {
            IDLE = 2'd0;
            RUNNING = 2'd1;
            PENDING = 2'd2;
        };
        field {
            encode          = S_STATUS_STATUS_0_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_0[1:0];
        STATUS_0->desc="
//// Status of configuration register group 0
";
        enum S_STATUS_STATUS_1_enum {
            IDLE = 2'd0;
            RUNNING = 2'd1;
            PENDING = 2'd2;
        };
        field {
            encode          = S_STATUS_STATUS_1_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_1[17:16];
        STATUS_1->desc="
//// Status of configuration register group 1
";
    }S_STATUS @0x0;
    reg {
        name = "S_POINTER";
        enum S_POINTER_PRODUCER_enum {
            GROUP_0 = 1'd0;
            GROUP_1 = 1'd1;
        };
        field {
            encode          = S_POINTER_PRODUCER_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PRODUCER[0:0];
        PRODUCER->desc="
////Pointer for CSB master to access groups
";
        enum S_POINTER_CONSUMER_enum {
            GROUP_0 = 1'd0;
            GROUP_1 = 1'd1;
        };
        field {
            encode          = S_POINTER_CONSUMER_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CONSUMER[16:16];
        CONSUMER->desc="
////Pointer for datapath to access groups
";
    }S_POINTER @0x4;
    reg {
        name = "S_LUT_ACCESS_CFG";
        desc = "
//// LUT Content setup, begin
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rwto;
            reset           = 0x0;
            reset_mask      = 0x3ff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_ADDR[9:0];
        LUT_ADDR->desc="
////LUT access start address for one reading or writting process
";
        enum S_LUT_ACCESS_CFG_LUT_TABLE_ID_enum {
            LE = 1'd0 {desc = "
//// Access LE_lut
";};
            LO = 1'd1 {desc = "
//// Access LO_lut
";};
        };
        field {
            encode          = S_LUT_ACCESS_CFG_LUT_TABLE_ID_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_TABLE_ID[16:16];
        enum S_LUT_ACCESS_CFG_LUT_ACCESS_TYPE_enum {
            READ = 1'd0 {desc = "
//// Read data from table
";};
            WRITE = 1'd1 {desc = "
//// Write data to table
";};
        };
        field {
            encode          = S_LUT_ACCESS_CFG_LUT_ACCESS_TYPE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_ACCESS_TYPE[17:17];
    }S_LUT_ACCESS_CFG @0x8;
    reg {
        name = "S_LUT_ACCESS_DATA";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rwto;
            reset           = 0x0;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_DATA[15:0];
        LUT_DATA->desc="
////signed data 
//// Data for LUT content access,
//// When LUT_ACCESS_TYPE == WRITE, this register means data that be written to LUT
//// When LUT_ACCESS_TYPE == READ, this register means data that read from LUT
";
    }S_LUT_ACCESS_DATA @0xc;
    reg {
        name = "S_LUT_CFG";
        enum S_LUT_CFG_LUT_LE_FUNCTION_enum {
            EXPONENT = 1'd0 {desc = "
////raw table is an exponential table
";};
            LINEAR = 1'd1 {desc = "
////raw table is a linear table 
";};
        };
        field {
            encode          = S_LUT_CFG_LUT_LE_FUNCTION_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LE_FUNCTION[0:0];
        LUT_LE_FUNCTION->desc="
//// LE_lut function
";
        enum S_LUT_CFG_LUT_UFLOW_PRIORITY_enum {
            LE = 1'd0 {desc = "
////select LE_lut output
";};
            LO = 1'd1 {desc = "
////select LO_lut output
";};
        };
        field {
            encode          = S_LUT_CFG_LUT_UFLOW_PRIORITY_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_UFLOW_PRIORITY[4:4];
        LUT_UFLOW_PRIORITY->desc="
//// indicate which table output should be selected when underflow happened to both table
";
        enum S_LUT_CFG_LUT_OFLOW_PRIORITY_enum {
            LE = 1'd0 {desc = "
////select LE_lut output
";};
            LO = 1'd1 {desc = "
////select LO_lut output
";};
        };
        field {
            encode          = S_LUT_CFG_LUT_OFLOW_PRIORITY_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_OFLOW_PRIORITY[5:5];
        LUT_OFLOW_PRIORITY->desc="
//// indicate which table output should be selected when overflow happened to both table
";
        enum S_LUT_CFG_LUT_HYBRID_PRIORITY_enum {
            LE = 1'd0 {desc = "
////select LE_lut output
";};
            LO = 1'd1 {desc = "
////select LO_lut output
";};
        };
        field {
            encode          = S_LUT_CFG_LUT_HYBRID_PRIORITY_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_HYBRID_PRIORITY[6:6];
        LUT_HYBRID_PRIORITY->desc="
//// indicate which table output should be selected when hit or miss happened to both table
";
    }S_LUT_CFG @0x10;
    reg {
        name = "S_LUT_INFO";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LE_INDEX_OFFSET[7:0];
        LUT_LE_INDEX_OFFSET->desc="
////signed value, Parameter serves for LE_lut works as exponent, 8bits for all data type.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LE_INDEX_SELECT[15:8];
        LUT_LE_INDEX_SELECT->desc="
////signed value, Parameter serves for LE_lut works as linear,6bits for int8, 7bits for int16, 8bits for fp16
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LO_INDEX_SELECT[23:16];
        LUT_LO_INDEX_SELECT->desc="
////signed value, Parameter serves for LO_lut, it is a Linear only table,6bits for int8, 7bits for int16, 8bits for fp16
";
    }S_LUT_INFO @0x14;
    reg {
        name = "S_LUT_LE_START_LOW";
        desc = "
//// LE_lut coverage range is [le_min, le_max], signed value
//// when LE works as linear table, LUT_LE_START equals to the value of le_min;
//// when LE works as exponential table, and LUT_LE_INDEX_OFFSET>=0, LUT_LE_START+2^LUT_LE_INDEX_OFFSET equals the value of le_min;
//// when LE works as exponential table, and LUT_LE_INDEX_OFFSET<0,  LUT_LE_START equals to the value of le_min.
//// 22bits for int8, 38bits for int16, 32bits for fp16(fp32 data value).
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LE_START_LOW[31:0];
    }S_LUT_LE_START_LOW @0x18;
    reg {
        name = "S_LUT_LE_START_HIGH";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LE_START_HIGH[5:0];
    }S_LUT_LE_START_HIGH @0x1c;
    reg {
        name = "S_LUT_LE_END_LOW";
        desc = "
//// LE_lut coverage range is [le_min,le_max], signed value
//// LUT_LE_END equals to the value of le_max;
//// 22bits for int8, 38bits for int16, 32bits for fp16(fp32 data value).
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LE_END_LOW[31:0];
    }S_LUT_LE_END_LOW @0x20;
    reg {
        name = "S_LUT_LE_END_HIGH";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LE_END_HIGH[5:0];
    }S_LUT_LE_END_HIGH @0x24;
    reg {
        name = "S_LUT_LO_START_LOW";
        desc = "
//// LO_lut coverage range is [lo_min, lo_max], signed value
//// LUT_LO_START equals to the value of lo_min;
//// 22bits for int8, 38bits for int16, 32bits for fp16(fp32 data value).
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LO_START_LOW[31:0];
    }S_LUT_LO_START_LOW @0x28;
    reg {
        name = "S_LUT_LO_START_HIGH";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LO_START_HIGH[5:0];
    }S_LUT_LO_START_HIGH @0x2c;
    reg {
        name = "S_LUT_LO_END_LOW";
        desc = "
//// LO_lut coverage range is [lo_min, lo_max], signed value
//// LUT_LO_END equals to the value of lo_max;
//// 22bits for int8, 38bits for int16, 32bits for fp16(fp32 data value).
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LO_END_LOW[31:0];
    }S_LUT_LO_END_LOW @0x30;
    reg {
        name = "S_LUT_LO_END_HIGH";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LO_END_HIGH[5:0];
    }S_LUT_LO_END_HIGH @0x34;
    reg {
        name = "S_LUT_LE_SLOPE_SCALE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LE_SLOPE_UFLOW_SCALE[15:0];
        LUT_LE_SLOPE_UFLOW_SCALE->desc="
//// slope scale parameter for LE_lut underflow, signed value.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LE_SLOPE_OFLOW_SCALE[31:16];
        LUT_LE_SLOPE_OFLOW_SCALE->desc="
//// slope scale parameter for LE_lut overflow, signed value.
";
    }S_LUT_LE_SLOPE_SCALE @0x38;
    reg {
        name = "S_LUT_LE_SLOPE_SHIFT";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LE_SLOPE_UFLOW_SHIFT[4:0];
        LUT_LE_SLOPE_UFLOW_SHIFT->desc="
//// slope shift parameter for LE_lut underflow, signed value, shift right if a positive num, shift left if a negative num.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LE_SLOPE_OFLOW_SHIFT[9:5];
        LUT_LE_SLOPE_OFLOW_SHIFT->desc="
//// slope shift parameter for LE_lut overflow, signed value, shift right if a positive num, shift left if a negative num.
";
    }S_LUT_LE_SLOPE_SHIFT @0x3c;
    reg {
        name = "S_LUT_LO_SLOPE_SCALE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LO_SLOPE_UFLOW_SCALE[15:0];
        LUT_LO_SLOPE_UFLOW_SCALE->desc="
//// slope scale parameter for LO_lut underflow, signed value.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LO_SLOPE_OFLOW_SCALE[31:16];
        LUT_LO_SLOPE_OFLOW_SCALE->desc="
//// slope scale parameter for LO_lut overflow, signed value.
";
    }S_LUT_LO_SLOPE_SCALE @0x40;
    reg {
        name = "S_LUT_LO_SLOPE_SHIFT";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LO_SLOPE_UFLOW_SHIFT[4:0];
        LUT_LO_SLOPE_UFLOW_SHIFT->desc="
//// slope shift parameter for LO_lut underflow, signed value, shift right if a positive num, shift left if a negative num.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_LO_SLOPE_OFLOW_SHIFT[9:5];
        LUT_LO_SLOPE_OFLOW_SHIFT->desc="
//// slope shift parameter for LO_lut overflow, signed value, shift right if a positive num, shift left if a negative num.
";
    }S_LUT_LO_SLOPE_SHIFT @0x44;
    reg {
        name = "D_OP_ENABLE";
        desc = "
//// LUT Content setup, end
//////////////////////////////////////////////////////////////////////////////////
////                                                                            //
////                    Define single group registers here                      //
////                    Register name should shart with prefix D_               //
////                                                                            //
//////////////////////////////////////////////////////////////////////////////////
//// 
";
        enum D_OP_ENABLE_OP_EN_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_OP_ENABLE_OP_EN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rwto;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } OP_EN[0:0];
    }D_OP_ENABLE @0x48;
    reg {
        name = "D_FUNC_BYPASS";
        enum D_FUNC_BYPASS_SQSUM_BYPASS_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_FUNC_BYPASS_SQSUM_BYPASS_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SQSUM_BYPASS[0:0];
        SQSUM_BYPASS->desc="
////square_sum process bypass control, DISABLE means disable bypass control and function works normally, ENABLE means function be bypassed.
";
        enum D_FUNC_BYPASS_MUL_BYPASS_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_FUNC_BYPASS_MUL_BYPASS_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } MUL_BYPASS[1:1];
        MUL_BYPASS->desc="
////multiplier after interpolator bypass control, DISABLE means disable bypass control and function works normally, ENABLE means function be bypassed.
";
    }D_FUNC_BYPASS @0x4c;
    reg {
        name = "D_DST_BASE_ADDR_LOW";
        desc = "
//// Destination data cube memory configuration, begin
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DST_BASE_ADDR_LOW[31:0];
        DST_BASE_ADDR_LOW->desc="
////  Start address of the source data cube which will be read from external memory for normalization
";
    }D_DST_BASE_ADDR_LOW @0x50;
    reg {
        name = "D_DST_BASE_ADDR_HIGH";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DST_BASE_ADDR_HIGH[31:0];
        DST_BASE_ADDR_HIGH->desc="
////  Start address of the source data cube which will be read from external memory for normalization
";
    }D_DST_BASE_ADDR_HIGH @0x54;
    reg {
        name = "D_DST_LINE_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DST_LINE_STRIDE[31:0];
        DST_LINE_STRIDE->desc="
////  Specify stride between two consective lines within a surface, actual stride value = LINE_STRIDE
";
    }D_DST_LINE_STRIDE @0x58;
    reg {
        name = "D_DST_SURFACE_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DST_SURFACE_STRIDE[31:0];
        DST_SURFACE_STRIDE->desc="
////  Specify stride between two consective surface, actual stride value = SURFACE_STRIDE
";
    }D_DST_SURFACE_STRIDE @0x5c;
    reg {
        name = "D_DST_DMA_CFG";
        enum D_DST_DMA_CFG_DST_RAM_TYPE_enum {
            CV = 1'd0;
            MC = 1'd1;
        };
        field {
            encode          = D_DST_DMA_CFG_DST_RAM_TYPE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DST_RAM_TYPE[0:0];
        DST_RAM_TYPE->desc="
//// Specify target is MC or CV_SRAM
";
    }D_DST_DMA_CFG @0x60;
    reg {
        name = "D_DST_COMPRESSION_EN";
        desc = "
//// Destination data is compresed or not, always disable in NVDLA version 1.0
";
        enum D_DST_COMPRESSION_EN_DST_COMPRESSION_EN_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_DST_COMPRESSION_EN_DST_COMPRESSION_EN_enum;
            sw              = r;
            hw              = r;
            spec_access     = c;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DST_COMPRESSION_EN[0:0];
    }D_DST_COMPRESSION_EN @0x64;
    reg {
        name = "D_DATA_FORMAT";
        desc = "
//// Destination data cube memory configuration, end
";
        enum D_DATA_FORMAT_INPUT_DATA_TYPE_enum {
            INT8 = 2'd0;
            INT16 = 2'd1;
            FP16 = 2'd2;
        };
        field {
            encode          = D_DATA_FORMAT_INPUT_DATA_TYPE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } INPUT_DATA_TYPE[1:0];
    }D_DATA_FORMAT @0x68;
    reg {
        name = "D_NAN_FLUSH_TO_ZERO";
        enum D_NAN_FLUSH_TO_ZERO_NAN_TO_ZERO_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_NAN_FLUSH_TO_ZERO_NAN_TO_ZERO_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } NAN_TO_ZERO[0:0];
        NAN_TO_ZERO->desc="
////option to flush input NaN to zero
";
    }D_NAN_FLUSH_TO_ZERO @0x6c;
    reg {
        name = "D_LRN_CFG";
        desc = "
//// figure out we need data conversion config or not
";
        enum D_LRN_CFG_NORMALZ_LEN_enum {
            LEN3 = 2'd0 {desc = "
////normal length=3 
";};
            LEN5 = 2'd1 {desc = "
////normal length=5
";};
            LEN7 = 2'd2 {desc = "
////normal length=7
";};
            LEN9 = 2'd3 {desc = "
////normal length=9
";};
        };
        field {
            encode          = D_LRN_CFG_NORMALZ_LEN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } NORMALZ_LEN[1:0];
        NORMALZ_LEN->desc="
////  the number of channels to sum over
";
    }D_LRN_CFG @0x70;
    reg {
        name = "D_DATIN_OFFSET";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATIN_OFFSET[15:0];
        DATIN_OFFSET->desc="
////  Input data convertor offset, signed data; 8bits for int8, 16bits for int16, 16bits for fp16.
";
    }D_DATIN_OFFSET @0x74;
    reg {
        name = "D_DATIN_SCALE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATIN_SCALE[15:0];
        DATIN_SCALE->desc="
////  Input data convertor scaling factor, signed data
";
    }D_DATIN_SCALE @0x78;
    reg {
        name = "D_DATIN_SHIFTER";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATIN_SHIFTER[4:0];
        DATIN_SHIFTER->desc="
////  Input data convertor shifter factor, unsigned data
";
    }D_DATIN_SHIFTER @0x7c;
    reg {
        name = "D_DATOUT_OFFSET";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATOUT_OFFSET[31:0];
        DATOUT_OFFSET->desc="
////  Output data convertor offset, signed data; 25bits for int8, 32bits for int16, 16bits for fp16.
";
    }D_DATOUT_OFFSET @0x80;
    reg {
        name = "D_DATOUT_SCALE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATOUT_SCALE[15:0];
        DATOUT_SCALE->desc="
////  Output data convertor scaling factor, signed data
";
    }D_DATOUT_SCALE @0x84;
    reg {
        name = "D_DATOUT_SHIFTER";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATOUT_SHIFTER[5:0];
        DATOUT_SHIFTER->desc="
////  Output data convertor shiftor factor, unsigned data
";
    }D_DATOUT_SHIFTER @0x88;
    reg {
        name = "D_NAN_INPUT_NUM";
        desc = "
//////////////////////////////////////////////////////////////////////////////////////////
////status register
";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } NAN_INPUT_NUM[31:0];
        NAN_INPUT_NUM->desc="
//// input NaN element number
";
    }D_NAN_INPUT_NUM @0x8c;
    reg {
        name = "D_INF_INPUT_NUM";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } INF_INPUT_NUM[31:0];
        INF_INPUT_NUM->desc="
//// input Infinity element number
";
    }D_INF_INPUT_NUM @0x90;
    reg {
        name = "D_NAN_OUTPUT_NUM";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } NAN_OUTPUT_NUM[31:0];
        NAN_OUTPUT_NUM->desc="
//// output NaN element number
";
    }D_NAN_OUTPUT_NUM @0x94;
    reg {
        name = "D_OUT_SATURATION";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } OUT_SATURATION[31:0];
        OUT_SATURATION->desc="
//// saturated element number.
";
    }D_OUT_SATURATION @0x98;
    reg {
        name = "D_PERF_ENABLE";
        desc = "
//// LUT status, begin
";
        enum D_PERF_ENABLE_DMA_EN_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_PERF_ENABLE_DMA_EN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DMA_EN[0:0];
        DMA_EN->desc="
//// dma perf reg enable control.
";
        enum D_PERF_ENABLE_LUT_EN_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_PERF_ENABLE_LUT_EN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } LUT_EN[1:1];
        LUT_EN->desc="
//// lut perf reg enable control.
";
    }D_PERF_ENABLE @0x9c;
    reg {
        name = "D_PERF_WRITE_STALL";
        desc = "
////reg D_PERF_READ_STALL               NVDLA_INCR 
////    31:0    r   PERF_READ_STALL     init=0 // element number that for both LUT under-flow.
////
";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PERF_WRITE_STALL[31:0];
        PERF_WRITE_STALL->desc="
//// element number that for both LUT under-flow.
";
    }D_PERF_WRITE_STALL @0xa0;
    reg {
        name = "D_PERF_LUT_UFLOW";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PERF_LUT_UFLOW[31:0];
        PERF_LUT_UFLOW->desc="
//// element number that for both LUT under-flow.
";
    }D_PERF_LUT_UFLOW @0xa4;
    reg {
        name = "D_PERF_LUT_OFLOW";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PERF_LUT_OFLOW[31:0];
        PERF_LUT_OFLOW->desc="
//// element number that for both LUT over-flow.
";
    }D_PERF_LUT_OFLOW @0xa8;
    reg {
        name = "D_PERF_LUT_HYBRID";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PERF_LUT_HYBRID[31:0];
        PERF_LUT_HYBRID->desc="
//// element number that for both LUT miss, one is over-flow and the other is overflow.
";
    }D_PERF_LUT_HYBRID @0xac;
    reg {
        name = "D_PERF_LUT_LE_HIT";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PERF_LUT_LE_HIT[31:0];
        PERF_LUT_LE_HIT->desc="
//// element number that for LE_lut hitted only.
";
    }D_PERF_LUT_LE_HIT @0xb0;
    reg {
        name = "D_PERF_LUT_LO_HIT";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PERF_LUT_LO_HIT[31:0];
        PERF_LUT_LO_HIT->desc="
//// element number that for LO_lut hitted only.
";
    }D_PERF_LUT_LO_HIT @0xb4;
    reg {
        name = "D_CYA";
        desc = "
//// LUT status, end
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CYA[31:0];
        CYA->desc="
////CYA register
";
    }D_CYA @0xb8;
};
regfile regs_NVDLA_GEC{
    default regwidth=32;
    reg {
        name = "FEATURE";
        desc = "
////Error Collator Registers
////==================================
//// GLOBAL SLICE
////==================================
";
        field {
            sw              = r;
            hw              = r;
            spec_access     = c;
            reset           = 0x43;
            reset_mask      = 0xffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } NUM_ERR[31:16];
        NUM_ERR->desc="
//// Number of errors connected to this collator. This is passed as a build time option to the plugin
";
        field {
            sw              = r;
            hw              = r;
            spec_access     = c;
            reset           = 0x3;
            reset_mask      = 0x3f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } NUM_ERR_SLICES[5:0];
        NUM_ERR_SLICES->desc="
//// Number of error slices supported by this error collator, does not include the GlobalSpace and is 
//// derived by ceil (NUM_ERR/32). SW shall first read this register to determine the number of slices 
//// and read the required number of Error_Status registers .
";
    }FEATURE @0x0;
    reg {
        name = "SWRESET";
        field {
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SWRST[0:0];
        SWRST->desc="
//// 1'b1 : Issue a SW reset to the Error Collator. This will reset all the registers(Except SCR), counters 
////        and logic of the Error Collator. SW can use this bit to flush errors logged into the error collator 
////        for ex, after Boot, SC7/8 exit.
//// 1'b0 : Do nothing, reset value.
//// This bit is auto-cleared.
";
    }SWRESET @0x4;
    reg {
        name = "MISSIONERR_TYPE";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x5;
            reset_mask      = 0x3f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CODE[5:0];
        CODE->desc="
//// This register indicates the fault code of the register based on the value of MISSIONERR_INDEX Register. 
//// This can be used by a fault handling agent to triage an error without requiring device-specific code.The
//// possible values of this field are:
////   6'd0  : None
////   6'd1  : Parity Error on internal data path
////   6'd2  : ECC SEC Error on internal data path
////   6'd3  : ECC DED Error on internal data path
////   6'd4  : Comparator Error
////   6'd5  : Register Parity Error
////   6'd6  : Parity Error SEC Error from on-chip SRAM/Fifo
////   6'd7  : ECC SEC Error from on-chip SRAM/Fifo
////   6'd8  : ECC DED Error from on-chip SRAM/Fifo
////   6'd9  : Clock Monitor ErrorOther Error
////   6'd10 : Voltage Error
////   6'd11 : Temperature Error
////   6'd16 : SW Correctable Error
////   6'd17 : SW Un-Correctable Error
////   6'd32 : Other HW Correctable Error
////   6'd33 : Other HW Uncorrectable Error
//// All other values : Reserved for future use.
";
    }MISSIONERR_TYPE @0x8;
    reg {
        name = "CURRENT_COUNTER_VALUE";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x1ff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } VALUE[8:0];
        VALUE->desc="
//// Provides the current value of the counter corresponding to the error in MissionErr_Index Register. 
//// Default provides the value of error 0 counter. 
//// Bit[8] is the ovrerflow bit post which the counter saturates and does not counter further. 
";
    }CURRENT_COUNTER_VALUE @0xc;
    reg {
        name = "MISSIONERR_INDEX";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } IDX[6:0];
        IDX->desc="
//// BINARY Encoded. For error number 32, register should be programmed with value 0x20. 
//// Write to this register with Error number will update:
////   - MISSIONERR_TYPE Register with the Error-Code for the Error.
////   - CURRENT_COUNTER_VALUE Register with the error's SEC/DED Counter.
////   - MISSIONERR_USERVALUE with value of the first error_<i>_user signal.
//// SW can use this to trage the error.
//// number shall update the MISSIONERR_TYPE register with the error code and the Current_Counter_Value register 
//// with the value of the errors SEC/DED counter. SW can use this register to triage the error.
";
    }MISSIONERR_INDEX @0x14;
    reg {
        name = "CORRECTABLE_THRESHOLD";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0xff;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } COUNT[7:0];
        COUNT->desc="
//// Threshold value for all SEC Fault Reporting Units connected to this error collator.
//// SEC Errors are logged once the threshold is reached and the overflow bit is set.
//// 7'b0  : Log SEC error after receiving 1 Error.
//// 7'b1  : Log SEC error after receiving 2 Errors. 
//// ...
//// 7'bFF : Log SEC error after receiving 256 Errors.
";
    }CORRECTABLE_THRESHOLD @0x18;
    reg {
        name = "MISSIONERR_INJECT_UNLOCK";
        enum MISSIONERR_INJECT_UNLOCK_VALUE_enum {
            LOCK = 8'd0;
            UNLOCK = 8'd225;
        };
        field {
            encode          = MISSIONERR_INJECT_UNLOCK_VALUE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } VALUE[7:0];
        VALUE->desc="
//// Writes to ERRSLICE_XXX_MISSIONERR_INJECT registers are disabled until this register is written with a value of 0xE1. 
//// This is to prevent an inadvertent safety error injection in the safety plugin due to: 
////  1. A fault on ERRSLICE_XXX_MISSIONERR_INJECT register itself.
////  2. Erroneous SW.
//// The register shall be written with a value of 0x0 to reestablish the lock after user has completed the error injection testing. 
//// 0xE1 : Unlock the MISSIONERR_INJECT Register
//// 0x0  : Lock the MISSIONERR_INJECT Register
";
    }MISSIONERR_INJECT_UNLOCK @0x1c;
    reg {
        name = "ERRSLICE0_MISSIONERR_ENABLE";
        desc = "
//// 0x20 to 0x2C = Reserved for future use.
////==================================
//// ERROR SLICE - 0
////==================================
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR31_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR31_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR31[31:31];
        ERR31->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D0BUF>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D0BUF>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR30_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR30_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR30[30:30];
        ERR30->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A7BUF>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A7BUF>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR29_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR29_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR29[29:29];
        ERR29->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A7BUF>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A7BUF>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR28_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR28_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR28[28:28];
        ERR28->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A6BUF>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A6BUF>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR27_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR27_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR27[27:27];
        ERR27->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A6BUF>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A6BUF>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR26_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR26_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR26[26:26];
        ERR26->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A5BUF>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A5BUF>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR25_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR25_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR25[25:25];
        ERR25->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A5BUF>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A5BUF>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR24_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR24_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR24[24:24];
        ERR24->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A4BUF>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A4BUF>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR23_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR23_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR23[23:23];
        ERR23->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A4BUF>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A4BUF>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR22_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR22_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR22[22:22];
        ERR22->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A3BUF>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A3BUF>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR21_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR21_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR21[21:21];
        ERR21->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A3BUF>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A3BUF>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR20_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR20_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR20[20:20];
        ERR20->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A2BUF>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A2BUF>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR19_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR19_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR19[19:19];
        ERR19->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A2BUF>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A2BUF>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR18_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR18_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR18[18:18];
        ERR18->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A1BUF>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A1BUF>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR17_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR17_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR17[17:17];
        ERR17->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A1BUF>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A1BUF>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR16_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR16_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR16[16:16];
        ERR16->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A0BUF>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A0BUF>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR15_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR15_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR15[15:15];
        ERR15->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A0BUF>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A0BUF>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR14_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR14_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR14[14:14];
        ERR14->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<MH>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<MH>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR13_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR13_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR13[13:13];
        ERR13->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<MH>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<MH>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR12_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR12_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR12[12:12];
        ERR12->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<ML>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<ML>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR11_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR11_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR11[11:11];
        ERR11->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<ML>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<ML>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR10_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR10_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR10[10:10];
        ERR10->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WH>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WH>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR9_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR9_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR9[9:9];
        ERR9->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WH>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WH>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR8_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR8_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR8[8:8];
        ERR8->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WL>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WL>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR7_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR7_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR7[7:7];
        ERR7->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WL>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WL>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR6_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR6_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR6[6:6];
        ERR6->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DH>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DH>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR5_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR5_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR5[5:5];
        ERR5->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DH>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DH>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR4_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR4_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR4[4:4];
        ERR4->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DL>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DL>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR3_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR3_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR3[3:3];
        ERR3->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DL>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DL>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR2_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR2_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR2[2:2];
        ERR2->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<BDMA>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<BDMA>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR1_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR1_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR1[1:1];
        ERR1->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<BDMA>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<BDMA>
";
        enum ERRSLICE0_MISSIONERR_ENABLE_ERR0_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_ENABLE_ERR0_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR0[0:0];
        ERR0->desc="
////1'b1 -> Enable  Mission Error Reporting for Register Parity Error from NV_NVDLA_GLB_FC_err_collator
////1'b0 -> Disable Mission Error Reporting for Register Parity Error from NV_NVDLA_GLB_FC_err_collator
";
    }ERRSLICE0_MISSIONERR_ENABLE @0x30;
    reg {
        name = "ERRSLICE0_MISSIONERR_FORCE";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR31_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR31_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR31[31:31];
        ERR31->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D0BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR30_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR30_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR30[30:30];
        ERR30->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A7BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR29_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR29_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR29[29:29];
        ERR29->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A7BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR28_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR28_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR28[28:28];
        ERR28->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A6BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR27_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR27_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR27[27:27];
        ERR27->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A6BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR26_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR26_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR26[26:26];
        ERR26->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A5BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR25_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR25_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR25[25:25];
        ERR25->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A5BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR24_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR24_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR24[24:24];
        ERR24->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A4BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR23_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR23_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR23[23:23];
        ERR23->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A4BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR22_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR22_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR22[22:22];
        ERR22->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A3BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR21_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR21_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR21[21:21];
        ERR21->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A3BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR20_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR20_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR20[20:20];
        ERR20->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A2BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR19_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR19_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR19[19:19];
        ERR19->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A2BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR18_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR18_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR18[18:18];
        ERR18->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A1BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR17_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR17_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR17[17:17];
        ERR17->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A1BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR16_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR16_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR16[16:16];
        ERR16->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A0BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR15_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR15_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR15[15:15];
        ERR15->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A0BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR14_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR14_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR14[14:14];
        ERR14->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<MH>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR13_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR13_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR13[13:13];
        ERR13->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<MH>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR12_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR12_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR12[12:12];
        ERR12->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<ML>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR11_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR11_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR11[11:11];
        ERR11->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<ML>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR10_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR10_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR10[10:10];
        ERR10->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WH>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR9_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR9_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR9[9:9];
        ERR9->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WH>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR8_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR8_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR8[8:8];
        ERR8->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WL>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR7_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR7_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR7[7:7];
        ERR7->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WL>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR6_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR6_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR6[6:6];
        ERR6->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DH>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR5_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR5_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR5[5:5];
        ERR5->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DH>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR4_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR4_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR4[4:4];
        ERR4->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DL>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR3_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR3_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR3[3:3];
        ERR3->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DL>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR2_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR2_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR2[2:2];
        ERR2->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<BDMA>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR1_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR1_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR1[1:1];
        ERR1->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<BDMA>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_MISSIONERR_FORCE_ERR0_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_FORCE_ERR0_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR0[0:0];
        ERR0->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for Register Parity Error from NV_NVDLA_GLB_FC_err_collator
////1'b0 -> Do Nothing
";
    }ERRSLICE0_MISSIONERR_FORCE @0x34;
    reg {
        name = "ERRSLICE0_MISSIONERR_STATUS";
        desc = "
////SW must write 1 to clear the fields of this register.
////Bits in this register continue to be logged independent of the value of MissionError_Enable register, to avoid silent dropping of errors.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR31[31:31];
        ERR31->desc="
////1'b1 -> Error_31_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D0BUF> was equal to 2'b10.
////1'b0 -> Error_31_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D0BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR30[30:30];
        ERR30->desc="
////1'b1 -> Error_30_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A7BUF> was equal to 2'b10.
////1'b0 -> Error_30_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A7BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR29[29:29];
        ERR29->desc="
////1'b1 -> Error_29_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A7BUF> was equal to 2'b10.
////1'b0 -> Error_29_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A7BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR28[28:28];
        ERR28->desc="
////1'b1 -> Error_28_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A6BUF> was equal to 2'b10.
////1'b0 -> Error_28_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A6BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR27[27:27];
        ERR27->desc="
////1'b1 -> Error_27_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A6BUF> was equal to 2'b10.
////1'b0 -> Error_27_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A6BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR26[26:26];
        ERR26->desc="
////1'b1 -> Error_26_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A5BUF> was equal to 2'b10.
////1'b0 -> Error_26_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A5BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR25[25:25];
        ERR25->desc="
////1'b1 -> Error_25_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A5BUF> was equal to 2'b10.
////1'b0 -> Error_25_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A5BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR24[24:24];
        ERR24->desc="
////1'b1 -> Error_24_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A4BUF> was equal to 2'b10.
////1'b0 -> Error_24_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A4BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR23[23:23];
        ERR23->desc="
////1'b1 -> Error_23_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A4BUF> was equal to 2'b10.
////1'b0 -> Error_23_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A4BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR22[22:22];
        ERR22->desc="
////1'b1 -> Error_22_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A3BUF> was equal to 2'b10.
////1'b0 -> Error_22_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A3BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR21[21:21];
        ERR21->desc="
////1'b1 -> Error_21_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A3BUF> was equal to 2'b10.
////1'b0 -> Error_21_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A3BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR20[20:20];
        ERR20->desc="
////1'b1 -> Error_20_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A2BUF> was equal to 2'b10.
////1'b0 -> Error_20_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A2BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR19[19:19];
        ERR19->desc="
////1'b1 -> Error_19_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A2BUF> was equal to 2'b10.
////1'b0 -> Error_19_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A2BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR18[18:18];
        ERR18->desc="
////1'b1 -> Error_18_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A1BUF> was equal to 2'b10.
////1'b0 -> Error_18_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A1BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR17[17:17];
        ERR17->desc="
////1'b1 -> Error_17_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A1BUF> was equal to 2'b10.
////1'b0 -> Error_17_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A1BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR16[16:16];
        ERR16->desc="
////1'b1 -> Error_16_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A0BUF> was equal to 2'b10.
////1'b0 -> Error_16_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A0BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR15[15:15];
        ERR15->desc="
////1'b1 -> Error_15_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A0BUF> was equal to 2'b10.
////1'b0 -> Error_15_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A0BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR14[14:14];
        ERR14->desc="
////1'b1 -> Error_14_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<MH> was equal to 2'b10.
////1'b0 -> Error_14_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<MH> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR13[13:13];
        ERR13->desc="
////1'b1 -> Error_13_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<MH> was equal to 2'b10.
////1'b0 -> Error_13_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<MH> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR12[12:12];
        ERR12->desc="
////1'b1 -> Error_12_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<ML> was equal to 2'b10.
////1'b0 -> Error_12_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<ML> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR11[11:11];
        ERR11->desc="
////1'b1 -> Error_11_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<ML> was equal to 2'b10.
////1'b0 -> Error_11_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<ML> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR10[10:10];
        ERR10->desc="
////1'b1 -> Error_10_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WH> was equal to 2'b10.
////1'b0 -> Error_10_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WH> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR9[9:9];
        ERR9->desc="
////1'b1 -> Error_9_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WH> was equal to 2'b10.
////1'b0 -> Error_9_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WH> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR8[8:8];
        ERR8->desc="
////1'b1 -> Error_8_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WL> was equal to 2'b10.
////1'b0 -> Error_8_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WL> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR7[7:7];
        ERR7->desc="
////1'b1 -> Error_7_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WL> was equal to 2'b10.
////1'b0 -> Error_7_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WL> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR6[6:6];
        ERR6->desc="
////1'b1 -> Error_6_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DH> was equal to 2'b10.
////1'b0 -> Error_6_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DH> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR5[5:5];
        ERR5->desc="
////1'b1 -> Error_5_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DH> was equal to 2'b10.
////1'b0 -> Error_5_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DH> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR4[4:4];
        ERR4->desc="
////1'b1 -> Error_4_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DL> was equal to 2'b10.
////1'b0 -> Error_4_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DL> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR3[3:3];
        ERR3->desc="
////1'b1 -> Error_3_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DL> was equal to 2'b10.
////1'b0 -> Error_3_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DL> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR2[2:2];
        ERR2->desc="
////1'b1 -> Error_2_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<BDMA> was equal to 2'b10.
////1'b0 -> Error_2_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<BDMA> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR1[1:1];
        ERR1->desc="
////1'b1 -> Error_1_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<BDMA> was equal to 2'b10.
////1'b0 -> Error_1_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<BDMA> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR0[0:0];
        ERR0->desc="
////1'b1 -> Error_0_pulse[1:0] for Register Parity Error from NV_NVDLA_GLB_FC_err_collator was equal to 2'b10.
////1'b0 -> Error_0_pulse[1:0] for Register Parity Error from NV_NVDLA_GLB_FC_err_collator was equal to 2'b01.
";
    }ERRSLICE0_MISSIONERR_STATUS @0x38;
    reg {
        name = "ERRSLICE0_MISSIONERR_INJECT";
        enum ERRSLICE0_MISSIONERR_INJECT_ERR31_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_INJECT_ERR31_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR31[31:31];
        ERR31->desc="
////1'b1 -> Assert the inject_error_31 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<D0BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_31 output.
";
        enum ERRSLICE0_MISSIONERR_INJECT_ERR30_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_INJECT_ERR30_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR30[30:30];
        ERR30->desc="
////1'b1 -> Assert the inject_error_30 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<A7BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_30 output.
";
        enum ERRSLICE0_MISSIONERR_INJECT_ERR29_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_INJECT_ERR29_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR29[29:29];
        ERR29->desc="
////1'b1 -> Assert the inject_error_29 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<A7BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_29 output.
";
        enum ERRSLICE0_MISSIONERR_INJECT_ERR28_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_INJECT_ERR28_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR28[28:28];
        ERR28->desc="
////1'b1 -> Assert the inject_error_28 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<A6BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_28 output.
";
        enum ERRSLICE0_MISSIONERR_INJECT_ERR27_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_INJECT_ERR27_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR27[27:27];
        ERR27->desc="
////1'b1 -> Assert the inject_error_27 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<A6BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_27 output.
";
        enum ERRSLICE0_MISSIONERR_INJECT_ERR26_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_INJECT_ERR26_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR26[26:26];
        ERR26->desc="
////1'b1 -> Assert the inject_error_26 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<A5BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_26 output.
";
        enum ERRSLICE0_MISSIONERR_INJECT_ERR25_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_INJECT_ERR25_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR25[25:25];
        ERR25->desc="
////1'b1 -> Assert the inject_error_25 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<A5BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_25 output.
";
        enum ERRSLICE0_MISSIONERR_INJECT_ERR24_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_INJECT_ERR24_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR24[24:24];
        ERR24->desc="
////1'b1 -> Assert the inject_error_24 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<A4BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_24 output.
";
        enum ERRSLICE0_MISSIONERR_INJECT_ERR23_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_INJECT_ERR23_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR23[23:23];
        ERR23->desc="
////1'b1 -> Assert the inject_error_23 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<A4BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_23 output.
";
        enum ERRSLICE0_MISSIONERR_INJECT_ERR22_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_INJECT_ERR22_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR22[22:22];
        ERR22->desc="
////1'b1 -> Assert the inject_error_22 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<A3BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_22 output.
";
        enum ERRSLICE0_MISSIONERR_INJECT_ERR21_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_INJECT_ERR21_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR21[21:21];
        ERR21->desc="
////1'b1 -> Assert the inject_error_21 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<A3BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_21 output.
";
        enum ERRSLICE0_MISSIONERR_INJECT_ERR20_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_INJECT_ERR20_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR20[20:20];
        ERR20->desc="
////1'b1 -> Assert the inject_error_20 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<A2BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_20 output.
";
        enum ERRSLICE0_MISSIONERR_INJECT_ERR19_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_INJECT_ERR19_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR19[19:19];
        ERR19->desc="
////1'b1 -> Assert the inject_error_19 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<A2BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_19 output.
";
        enum ERRSLICE0_MISSIONERR_INJECT_ERR18_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_INJECT_ERR18_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR18[18:18];
        ERR18->desc="
////1'b1 -> Assert the inject_error_18 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<A1BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_18 output.
";
        enum ERRSLICE0_MISSIONERR_INJECT_ERR17_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_INJECT_ERR17_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR17[17:17];
        ERR17->desc="
////1'b1 -> Assert the inject_error_17 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<A1BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_17 output.
";
        enum ERRSLICE0_MISSIONERR_INJECT_ERR16_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_INJECT_ERR16_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR16[16:16];
        ERR16->desc="
////1'b1 -> Assert the inject_error_16 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<A0BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_16 output.
";
        enum ERRSLICE0_MISSIONERR_INJECT_ERR15_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_INJECT_ERR15_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR15[15:15];
        ERR15->desc="
////1'b1 -> Assert the inject_error_15 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<A0BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_15 output.
";
        enum ERRSLICE0_MISSIONERR_INJECT_ERR8_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_INJECT_ERR8_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR8[8:8];
        ERR8->desc="
////1'b1 -> Assert the inject_error_8 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<CBUF>.<WL> to allow for error injection.
////1'b0 -> De-Asseert inject_error_8 output.
";
        enum ERRSLICE0_MISSIONERR_INJECT_ERR7_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_INJECT_ERR7_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR7[7:7];
        ERR7->desc="
////1'b1 -> Assert the inject_error_7 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<CBUF>.<WL> to allow for error injection.
////1'b0 -> De-Asseert inject_error_7 output.
";
        enum ERRSLICE0_MISSIONERR_INJECT_ERR6_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_INJECT_ERR6_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR6[6:6];
        ERR6->desc="
////1'b1 -> Assert the inject_error_6 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<CBUF>.<DH> to allow for error injection.
////1'b0 -> De-Asseert inject_error_6 output.
";
        enum ERRSLICE0_MISSIONERR_INJECT_ERR5_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_INJECT_ERR5_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR5[5:5];
        ERR5->desc="
////1'b1 -> Assert the inject_error_5 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<CBUF>.<DH> to allow for error injection.
////1'b0 -> De-Asseert inject_error_5 output.
";
        enum ERRSLICE0_MISSIONERR_INJECT_ERR4_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_INJECT_ERR4_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR4[4:4];
        ERR4->desc="
////1'b1 -> Assert the inject_error_4 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<CBUF>.<DL> to allow for error injection.
////1'b0 -> De-Asseert inject_error_4 output.
";
        enum ERRSLICE0_MISSIONERR_INJECT_ERR3_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_INJECT_ERR3_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR3[3:3];
        ERR3->desc="
////1'b1 -> Assert the inject_error_3 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<CBUF>.<DL> to allow for error injection.
////1'b0 -> De-Asseert inject_error_3 output.
";
        enum ERRSLICE0_MISSIONERR_INJECT_ERR2_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_INJECT_ERR2_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR2[2:2];
        ERR2->desc="
////1'b1 -> Assert the inject_error_2 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<BDMA> to allow for error injection.
////1'b0 -> De-Asseert inject_error_2 output.
";
        enum ERRSLICE0_MISSIONERR_INJECT_ERR1_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_INJECT_ERR1_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR1[1:1];
        ERR1->desc="
////1'b1 -> Assert the inject_error_1 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<BDMA> to allow for error injection.
////1'b0 -> De-Asseert inject_error_1 output.
";
        enum ERRSLICE0_MISSIONERR_INJECT_ERR0_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_MISSIONERR_INJECT_ERR0_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR0[0:0];
        ERR0->desc="
////1'b1 -> Assert the inject_error_0 output for Register Parity Error to NV_NVDLA_GLB_FC_err_collator to allow for error injection.
////1'b0 -> De-Asseert inject_error_0 output.
";
    }ERRSLICE0_MISSIONERR_INJECT @0x3c;
    reg {
        name = "ERRSLICE0_LATENTERR_ENABLE";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR31_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR31_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR31[31:31];
        ERR31->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D0BUF>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D0BUF>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR30_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR30_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR30[30:30];
        ERR30->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A7BUF>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A7BUF>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR29_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR29_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR29[29:29];
        ERR29->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A7BUF>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A7BUF>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR28_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR28_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR28[28:28];
        ERR28->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A6BUF>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A6BUF>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR27_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR27_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR27[27:27];
        ERR27->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A6BUF>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A6BUF>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR26_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR26_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR26[26:26];
        ERR26->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A5BUF>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A5BUF>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR25_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR25_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR25[25:25];
        ERR25->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A5BUF>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A5BUF>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR24_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR24_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR24[24:24];
        ERR24->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A4BUF>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A4BUF>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR23_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR23_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR23[23:23];
        ERR23->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A4BUF>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A4BUF>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR22_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR22_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR22[22:22];
        ERR22->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A3BUF>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A3BUF>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR21_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR21_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR21[21:21];
        ERR21->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A3BUF>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A3BUF>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR20_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR20_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR20[20:20];
        ERR20->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A2BUF>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A2BUF>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR19_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR19_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR19[19:19];
        ERR19->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A2BUF>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A2BUF>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR18_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR18_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR18[18:18];
        ERR18->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A1BUF>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A1BUF>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR17_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR17_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR17[17:17];
        ERR17->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A1BUF>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A1BUF>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR16_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR16_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR16[16:16];
        ERR16->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A0BUF>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A0BUF>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR15_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR15_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR15[15:15];
        ERR15->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A0BUF>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A0BUF>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR14_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR14_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR14[14:14];
        ERR14->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<MH>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<MH>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR13_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR13_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR13[13:13];
        ERR13->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<MH>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<MH>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR12_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR12_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR12[12:12];
        ERR12->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<ML>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<ML>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR11_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR11_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR11[11:11];
        ERR11->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<ML>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<ML>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR10_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR10_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR10[10:10];
        ERR10->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WH>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WH>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR9_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR9_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR9[9:9];
        ERR9->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WH>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WH>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR8_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR8_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR8[8:8];
        ERR8->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WL>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WL>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR7_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR7_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR7[7:7];
        ERR7->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WL>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WL>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR6_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR6_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR6[6:6];
        ERR6->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DH>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DH>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR5_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR5_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR5[5:5];
        ERR5->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DH>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DH>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR4_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR4_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR4[4:4];
        ERR4->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DL>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DL>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR3_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR3_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR3[3:3];
        ERR3->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DL>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DL>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR2_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR2_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR2[2:2];
        ERR2->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<BDMA>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<BDMA>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR1_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR1_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR1[1:1];
        ERR1->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<BDMA>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<BDMA>
";
        enum ERRSLICE0_LATENTERR_ENABLE_ERR0_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_ENABLE_ERR0_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR0[0:0];
        ERR0->desc="
////1'b1 -> Enable  Latent Error Reporting for Register Parity Error from NV_NVDLA_GLB_FC_err_collator
////1'b0 -> Disable Latent Error Reporting for Register Parity Error from NV_NVDLA_GLB_FC_err_collator
";
    }ERRSLICE0_LATENTERR_ENABLE @0x40;
    reg {
        name = "ERRSLICE0_LATENTERR_FORCE";
        enum ERRSLICE0_LATENTERR_FORCE_ERR31_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR31_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR31[31:31];
        ERR31->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D0BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR30_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR30_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR30[30:30];
        ERR30->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A7BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR29_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR29_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR29[29:29];
        ERR29->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A7BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR28_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR28_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR28[28:28];
        ERR28->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A6BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR27_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR27_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR27[27:27];
        ERR27->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A6BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR26_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR26_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR26[26:26];
        ERR26->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A5BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR25_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR25_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR25[25:25];
        ERR25->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A5BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR24_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR24_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR24[24:24];
        ERR24->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A4BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR23_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR23_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR23[23:23];
        ERR23->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A4BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR22_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR22_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR22[22:22];
        ERR22->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A3BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR21_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR21_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR21[21:21];
        ERR21->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A3BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR20_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR20_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR20[20:20];
        ERR20->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A2BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR19_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR19_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR19[19:19];
        ERR19->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A2BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR18_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR18_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR18[18:18];
        ERR18->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A1BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR17_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR17_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR17[17:17];
        ERR17->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A1BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR16_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR16_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR16[16:16];
        ERR16->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A0BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR15_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR15_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR15[15:15];
        ERR15->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A0BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR14_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR14_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR14[14:14];
        ERR14->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<MH>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR13_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR13_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR13[13:13];
        ERR13->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<MH>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR12_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR12_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR12[12:12];
        ERR12->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<ML>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR11_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR11_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR11[11:11];
        ERR11->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<ML>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR10_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR10_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR10[10:10];
        ERR10->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WH>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR9_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR9_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR9[9:9];
        ERR9->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WH>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR8_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR8_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR8[8:8];
        ERR8->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WL>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR7_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR7_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR7[7:7];
        ERR7->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WL>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR6_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR6_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR6[6:6];
        ERR6->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DH>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR5_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR5_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR5[5:5];
        ERR5->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DH>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR4_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR4_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR4[4:4];
        ERR4->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DL>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR3_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR3_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR3[3:3];
        ERR3->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DL>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR2_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR2_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR2[2:2];
        ERR2->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<BDMA>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR1_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR1_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR1[1:1];
        ERR1->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<BDMA>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_LATENTERR_FORCE_ERR0_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE0_LATENTERR_FORCE_ERR0_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR0[0:0];
        ERR0->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for Register Parity Error from NV_NVDLA_GLB_FC_err_collator
////1'b0 -> Do Nothing
";
    }ERRSLICE0_LATENTERR_FORCE @0x44;
    reg {
        name = "ERRSLICE0_LATENTERR_STATUS";
        desc = "
////SW must write 1 to clear the fields of this register.
////Bits in this register continue to be logged independent of the value of LatentError_Enable register, to avoid silent dropping of errors.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR31[31:31];
        ERR31->desc="
////1'b1 -> Error_31_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D0BUF> was equal to 2'b10.
////1'b0 -> Error_31_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D0BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR30[30:30];
        ERR30->desc="
////1'b1 -> Error_30_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A7BUF> was equal to 2'b10.
////1'b0 -> Error_30_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A7BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR29[29:29];
        ERR29->desc="
////1'b1 -> Error_29_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A7BUF> was equal to 2'b10.
////1'b0 -> Error_29_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A7BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR28[28:28];
        ERR28->desc="
////1'b1 -> Error_28_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A6BUF> was equal to 2'b10.
////1'b0 -> Error_28_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A6BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR27[27:27];
        ERR27->desc="
////1'b1 -> Error_27_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A6BUF> was equal to 2'b10.
////1'b0 -> Error_27_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A6BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR26[26:26];
        ERR26->desc="
////1'b1 -> Error_26_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A5BUF> was equal to 2'b10.
////1'b0 -> Error_26_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A5BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR25[25:25];
        ERR25->desc="
////1'b1 -> Error_25_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A5BUF> was equal to 2'b10.
////1'b0 -> Error_25_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A5BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR24[24:24];
        ERR24->desc="
////1'b1 -> Error_24_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A4BUF> was equal to 2'b10.
////1'b0 -> Error_24_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A4BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR23[23:23];
        ERR23->desc="
////1'b1 -> Error_23_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A4BUF> was equal to 2'b10.
////1'b0 -> Error_23_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A4BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR22[22:22];
        ERR22->desc="
////1'b1 -> Error_22_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A3BUF> was equal to 2'b10.
////1'b0 -> Error_22_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A3BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR21[21:21];
        ERR21->desc="
////1'b1 -> Error_21_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A3BUF> was equal to 2'b10.
////1'b0 -> Error_21_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A3BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR20[20:20];
        ERR20->desc="
////1'b1 -> Error_20_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A2BUF> was equal to 2'b10.
////1'b0 -> Error_20_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A2BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR19[19:19];
        ERR19->desc="
////1'b1 -> Error_19_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A2BUF> was equal to 2'b10.
////1'b0 -> Error_19_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A2BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR18[18:18];
        ERR18->desc="
////1'b1 -> Error_18_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A1BUF> was equal to 2'b10.
////1'b0 -> Error_18_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A1BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR17[17:17];
        ERR17->desc="
////1'b1 -> Error_17_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A1BUF> was equal to 2'b10.
////1'b0 -> Error_17_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A1BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR16[16:16];
        ERR16->desc="
////1'b1 -> Error_16_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A0BUF> was equal to 2'b10.
////1'b0 -> Error_16_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A0BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR15[15:15];
        ERR15->desc="
////1'b1 -> Error_15_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A0BUF> was equal to 2'b10.
////1'b0 -> Error_15_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A0BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR14[14:14];
        ERR14->desc="
////1'b1 -> Error_14_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<MH> was equal to 2'b10.
////1'b0 -> Error_14_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<MH> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR13[13:13];
        ERR13->desc="
////1'b1 -> Error_13_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<MH> was equal to 2'b10.
////1'b0 -> Error_13_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<MH> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR12[12:12];
        ERR12->desc="
////1'b1 -> Error_12_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<ML> was equal to 2'b10.
////1'b0 -> Error_12_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<ML> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR11[11:11];
        ERR11->desc="
////1'b1 -> Error_11_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<ML> was equal to 2'b10.
////1'b0 -> Error_11_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<ML> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR10[10:10];
        ERR10->desc="
////1'b1 -> Error_10_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WH> was equal to 2'b10.
////1'b0 -> Error_10_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WH> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR9[9:9];
        ERR9->desc="
////1'b1 -> Error_9_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WH> was equal to 2'b10.
////1'b0 -> Error_9_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WH> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR8[8:8];
        ERR8->desc="
////1'b1 -> Error_8_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WL> was equal to 2'b10.
////1'b0 -> Error_8_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WL> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR7[7:7];
        ERR7->desc="
////1'b1 -> Error_7_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WL> was equal to 2'b10.
////1'b0 -> Error_7_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WL> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR6[6:6];
        ERR6->desc="
////1'b1 -> Error_6_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DH> was equal to 2'b10.
////1'b0 -> Error_6_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DH> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR5[5:5];
        ERR5->desc="
////1'b1 -> Error_5_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DH> was equal to 2'b10.
////1'b0 -> Error_5_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DH> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR4[4:4];
        ERR4->desc="
////1'b1 -> Error_4_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DL> was equal to 2'b10.
////1'b0 -> Error_4_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DL> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR3[3:3];
        ERR3->desc="
////1'b1 -> Error_3_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DL> was equal to 2'b10.
////1'b0 -> Error_3_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DL> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR2[2:2];
        ERR2->desc="
////1'b1 -> Error_2_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<BDMA> was equal to 2'b10.
////1'b0 -> Error_2_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<BDMA> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR1[1:1];
        ERR1->desc="
////1'b1 -> Error_1_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<BDMA> was equal to 2'b10.
////1'b0 -> Error_1_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<BDMA> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR0[0:0];
        ERR0->desc="
////1'b1 -> Error_0_pulse[1:0] for Register Parity Error from NV_NVDLA_GLB_FC_err_collator was equal to 2'b10.
////1'b0 -> Error_0_pulse[1:0] for Register Parity Error from NV_NVDLA_GLB_FC_err_collator was equal to 2'b01.
";
    }ERRSLICE0_LATENTERR_STATUS @0x48;
    reg {
        name = "ERRSLICE0_COUNTER_RELOAD";
        enum ERRSLICE0_COUNTER_RELOAD_ERR31_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR31_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR31[31:31];
        ERR31->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D0BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR30_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR30_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR30[30:30];
        ERR30->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A7BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR29_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR29_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR29[29:29];
        ERR29->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A7BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR28_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR28_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR28[28:28];
        ERR28->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A6BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR27_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR27_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR27[27:27];
        ERR27->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A6BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR26_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR26_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR26[26:26];
        ERR26->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A5BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR25_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR25_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR25[25:25];
        ERR25->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A5BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR24_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR24_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR24[24:24];
        ERR24->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A4BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR23_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR23_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR23[23:23];
        ERR23->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A4BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR22_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR22_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR22[22:22];
        ERR22->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A3BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR21_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR21_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR21[21:21];
        ERR21->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A3BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR20_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR20_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR20[20:20];
        ERR20->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A2BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR19_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR19_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR19[19:19];
        ERR19->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A2BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR18_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR18_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR18[18:18];
        ERR18->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A1BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR17_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR17_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR17[17:17];
        ERR17->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A1BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR16_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR16_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR16[16:16];
        ERR16->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A0BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR15_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR15_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR15[15:15];
        ERR15->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<A0BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR14_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR14_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR14[14:14];
        ERR14->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<MH>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR13_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR13_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR13[13:13];
        ERR13->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<MH>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR12_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR12_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR12[12:12];
        ERR12->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<ML>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR11_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR11_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR11[11:11];
        ERR11->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<ML>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR10_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR10_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR10[10:10];
        ERR10->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WH>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR9_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR9_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR9[9:9];
        ERR9->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WH>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR8_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR8_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR8[8:8];
        ERR8->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WL>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR7_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR7_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR7[7:7];
        ERR7->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<WL>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR6_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR6_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR6[6:6];
        ERR6->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DH>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR5_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR5_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR5[5:5];
        ERR5->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DH>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR4_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR4_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR4[4:4];
        ERR4->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DL>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR3_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR3_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR3[3:3];
        ERR3->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CBUF>.<DL>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR2_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR2_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR2[2:2];
        ERR2->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<BDMA>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR1_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR1_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR1[1:1];
        ERR1->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<BDMA>
////1'b0 -> Do Nothing
";
        enum ERRSLICE0_COUNTER_RELOAD_ERR0_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE0_COUNTER_RELOAD_ERR0_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR0[0:0];
        ERR0->desc="
////1'b1 -> Reload Error Counter for Register Parity Error from NV_NVDLA_GLB_FC_err_collator
////1'b0 -> Do Nothing
";
    }ERRSLICE0_COUNTER_RELOAD @0x50;
    reg {
        name = "ERRSLICE1_MISSIONERR_ENABLE";
        desc = "
//// 0x28 to 0x30 = Reserved for future use.
////==================================
//// ERROR SLICE - 1
////==================================
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR63_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR63_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR63[31:31];
        ERR63->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<IMEM>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<IMEM>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR62_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR62_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR62[30:30];
        ERR62->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_B>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_B>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR61_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR61_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR61[29:29];
        ERR61->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_B>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_B>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR60_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR60_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR60[28:28];
        ERR60->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_A>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_A>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR59_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR59_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR59[27:27];
        ERR59->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_A>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_A>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR58_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR58_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR58[26:26];
        ERR58->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CDP>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CDP>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR57_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR57_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR57[25:25];
        ERR57->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CDP>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CDP>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR56_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR56_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR56[24:24];
        ERR56->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<PDP>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<PDP>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR55_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR55_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR55[23:23];
        ERR55->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<PDP>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<PDP>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR54_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR54_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR54[22:22];
        ERR54->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<E2>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<E2>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR53_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR53_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR53[21:21];
        ERR53->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<E2>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<E2>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR52_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR52_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR52[20:20];
        ERR52->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<N2>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<N2>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR51_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR51_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR51[19:19];
        ERR51->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<N2>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<N2>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR50_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR50_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR50[18:18];
        ERR50->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<B2>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<B2>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR49_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR49_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR49[17:17];
        ERR49->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<B2>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<B2>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR48_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR48_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR48[16:16];
        ERR48->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR47_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR47_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR47[15:15];
        ERR47->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR46_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR46_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR46[14:14];
        ERR46->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D7BUF>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D7BUF>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR45_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR45_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR45[13:13];
        ERR45->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D7BUF>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D7BUF>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR44_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR44_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR44[12:12];
        ERR44->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D6BUF>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D6BUF>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR43_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR43_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR43[11:11];
        ERR43->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D6BUF>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D6BUF>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR42_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR42_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR42[10:10];
        ERR42->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D5BUF>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D5BUF>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR41_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR41_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR41[9:9];
        ERR41->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D5BUF>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D5BUF>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR40_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR40_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR40[8:8];
        ERR40->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D4BUF>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D4BUF>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR39_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR39_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR39[7:7];
        ERR39->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D4BUF>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D4BUF>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR38_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR38_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR38[6:6];
        ERR38->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D3BUF>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D3BUF>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR37_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR37_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR37[5:5];
        ERR37->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D3BUF>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D3BUF>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR36_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR36_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR36[4:4];
        ERR36->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D2BUF>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D2BUF>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR35_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR35_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR35[3:3];
        ERR35->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D2BUF>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D2BUF>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR34_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR34_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR34[2:2];
        ERR34->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D1BUF>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D1BUF>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR33_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR33_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR33[1:1];
        ERR33->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D1BUF>
////1'b0 -> Disable Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D1BUF>
";
        enum ERRSLICE1_MISSIONERR_ENABLE_ERR32_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ENABLE_ERR32_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR32[0:0];
        ERR32->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D0BUF>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D0BUF>
";
    }ERRSLICE1_MISSIONERR_ENABLE @0x60;
    reg {
        name = "ERRSLICE1_MISSIONERR_FORCE";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR63_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR63_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR63[31:31];
        ERR63->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<IMEM>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR62_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR62_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR62[30:30];
        ERR62->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_B>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR61_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR61_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR61[29:29];
        ERR61->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_B>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR60_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR60_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR60[28:28];
        ERR60->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_A>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR59_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR59_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR59[27:27];
        ERR59->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_A>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR58_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR58_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR58[26:26];
        ERR58->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CDP>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR57_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR57_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR57[25:25];
        ERR57->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CDP>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR56_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR56_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR56[24:24];
        ERR56->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<PDP>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR55_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR55_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR55[23:23];
        ERR55->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<PDP>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR54_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR54_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR54[22:22];
        ERR54->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<E2>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR53_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR53_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR53[21:21];
        ERR53->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<E2>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR52_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR52_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR52[20:20];
        ERR52->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<N2>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR51_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR51_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR51[19:19];
        ERR51->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<N2>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR50_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR50_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR50[18:18];
        ERR50->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<B2>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR49_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR49_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR49[17:17];
        ERR49->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<B2>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR48_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR48_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR48[16:16];
        ERR48->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR47_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR47_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR47[15:15];
        ERR47->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR46_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR46_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR46[14:14];
        ERR46->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D7BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR45_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR45_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR45[13:13];
        ERR45->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D7BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR44_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR44_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR44[12:12];
        ERR44->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D6BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR43_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR43_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR43[11:11];
        ERR43->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D6BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR42_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR42_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR42[10:10];
        ERR42->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D5BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR41_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR41_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR41[9:9];
        ERR41->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D5BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR40_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR40_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR40[8:8];
        ERR40->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D4BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR39_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR39_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR39[7:7];
        ERR39->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D4BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR38_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR38_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR38[6:6];
        ERR38->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D3BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR37_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR37_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR37[5:5];
        ERR37->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D3BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR36_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR36_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR36[4:4];
        ERR36->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D2BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR35_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR35_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR35[3:3];
        ERR35->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D2BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR34_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR34_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR34[2:2];
        ERR34->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D1BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR33_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR33_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR33[1:1];
        ERR33->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D1BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_MISSIONERR_FORCE_ERR32_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_FORCE_ERR32_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR32[0:0];
        ERR32->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D0BUF>
////1'b0 -> Do Nothing
";
    }ERRSLICE1_MISSIONERR_FORCE @0x64;
    reg {
        name = "ERRSLICE1_MISSIONERR_STATUS";
        desc = "
////SW must write 1 to clear the fields of this register.
////Bits in this register continue to be logged independent of the value of MissionError_Enable register, to avoid silent dropping of errors.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR63[31:31];
        ERR63->desc="
////1'b1 -> Error_63_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<IMEM> was equal to 2'b10.
////1'b0 -> Error_63_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<IMEM> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR62[30:30];
        ERR62->desc="
////1'b1 -> Error_62_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_B> was equal to 2'b10.
////1'b0 -> Error_62_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_B> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR61[29:29];
        ERR61->desc="
////1'b1 -> Error_61_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_B> was equal to 2'b10.
////1'b0 -> Error_61_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_B> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR60[28:28];
        ERR60->desc="
////1'b1 -> Error_60_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_A> was equal to 2'b10.
////1'b0 -> Error_60_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_A> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR59[27:27];
        ERR59->desc="
////1'b1 -> Error_59_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_A> was equal to 2'b10.
////1'b0 -> Error_59_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_A> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR58[26:26];
        ERR58->desc="
////1'b1 -> Error_58_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CDP> was equal to 2'b10.
////1'b0 -> Error_58_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CDP> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR57[25:25];
        ERR57->desc="
////1'b1 -> Error_57_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CDP> was equal to 2'b10.
////1'b0 -> Error_57_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CDP> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR56[24:24];
        ERR56->desc="
////1'b1 -> Error_56_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<PDP> was equal to 2'b10.
////1'b0 -> Error_56_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<PDP> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR55[23:23];
        ERR55->desc="
////1'b1 -> Error_55_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<PDP> was equal to 2'b10.
////1'b0 -> Error_55_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<PDP> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR54[22:22];
        ERR54->desc="
////1'b1 -> Error_54_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<E2> was equal to 2'b10.
////1'b0 -> Error_54_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<E2> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR53[21:21];
        ERR53->desc="
////1'b1 -> Error_53_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<E2> was equal to 2'b10.
////1'b0 -> Error_53_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<E2> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR52[20:20];
        ERR52->desc="
////1'b1 -> Error_52_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<N2> was equal to 2'b10.
////1'b0 -> Error_52_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<N2> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR51[19:19];
        ERR51->desc="
////1'b1 -> Error_51_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<N2> was equal to 2'b10.
////1'b0 -> Error_51_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<N2> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR50[18:18];
        ERR50->desc="
////1'b1 -> Error_50_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<B2> was equal to 2'b10.
////1'b0 -> Error_50_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<B2> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR49[17:17];
        ERR49->desc="
////1'b1 -> Error_49_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<B2> was equal to 2'b10.
////1'b0 -> Error_49_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<B2> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR48[16:16];
        ERR48->desc="
////1'b1 -> Error_48_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP> was equal to 2'b10.
////1'b0 -> Error_48_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR47[15:15];
        ERR47->desc="
////1'b1 -> Error_47_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP> was equal to 2'b10.
////1'b0 -> Error_47_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR46[14:14];
        ERR46->desc="
////1'b1 -> Error_46_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D7BUF> was equal to 2'b10.
////1'b0 -> Error_46_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D7BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR45[13:13];
        ERR45->desc="
////1'b1 -> Error_45_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D7BUF> was equal to 2'b10.
////1'b0 -> Error_45_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D7BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR44[12:12];
        ERR44->desc="
////1'b1 -> Error_44_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D6BUF> was equal to 2'b10.
////1'b0 -> Error_44_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D6BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR43[11:11];
        ERR43->desc="
////1'b1 -> Error_43_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D6BUF> was equal to 2'b10.
////1'b0 -> Error_43_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D6BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR42[10:10];
        ERR42->desc="
////1'b1 -> Error_42_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D5BUF> was equal to 2'b10.
////1'b0 -> Error_42_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D5BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR41[9:9];
        ERR41->desc="
////1'b1 -> Error_41_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D5BUF> was equal to 2'b10.
////1'b0 -> Error_41_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D5BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR40[8:8];
        ERR40->desc="
////1'b1 -> Error_40_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D4BUF> was equal to 2'b10.
////1'b0 -> Error_40_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D4BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR39[7:7];
        ERR39->desc="
////1'b1 -> Error_39_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D4BUF> was equal to 2'b10.
////1'b0 -> Error_39_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D4BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR38[6:6];
        ERR38->desc="
////1'b1 -> Error_38_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D3BUF> was equal to 2'b10.
////1'b0 -> Error_38_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D3BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR37[5:5];
        ERR37->desc="
////1'b1 -> Error_37_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D3BUF> was equal to 2'b10.
////1'b0 -> Error_37_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D3BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR36[4:4];
        ERR36->desc="
////1'b1 -> Error_36_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D2BUF> was equal to 2'b10.
////1'b0 -> Error_36_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D2BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR35[3:3];
        ERR35->desc="
////1'b1 -> Error_35_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D2BUF> was equal to 2'b10.
////1'b0 -> Error_35_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D2BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR34[2:2];
        ERR34->desc="
////1'b1 -> Error_34_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D1BUF> was equal to 2'b10.
////1'b0 -> Error_34_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D1BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR33[1:1];
        ERR33->desc="
////1'b1 -> Error_33_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D1BUF> was equal to 2'b10.
////1'b0 -> Error_33_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D1BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR32[0:0];
        ERR32->desc="
////1'b1 -> Error_32_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D0BUF> was equal to 2'b10.
////1'b0 -> Error_32_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D0BUF> was equal to 2'b01.
";
    }ERRSLICE1_MISSIONERR_STATUS @0x68;
    reg {
        name = "ERRSLICE1_MISSIONERR_INJECT";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR63_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR63_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR63[31:31];
        ERR63->desc="
////1'b1 -> Assert the inject_error_63 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<FALCON>.<IMEM> to allow for error injection.
////1'b0 -> De-Asseert inject_error_63 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR62_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR62_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR62[30:30];
        ERR62->desc="
////1'b1 -> Assert the inject_error_62 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<RUBIK>.<FIFO_B> to allow for error injection.
////1'b0 -> De-Asseert inject_error_62 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR61_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR61_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR61[29:29];
        ERR61->desc="
////1'b1 -> Assert the inject_error_61 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<RUBIK>.<FIFO_B> to allow for error injection.
////1'b0 -> De-Asseert inject_error_61 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR60_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR60_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR60[28:28];
        ERR60->desc="
////1'b1 -> Assert the inject_error_60 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<RUBIK>.<FIFO_A> to allow for error injection.
////1'b0 -> De-Asseert inject_error_60 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR59_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR59_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR59[27:27];
        ERR59->desc="
////1'b1 -> Assert the inject_error_59 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<RUBIK>.<FIFO_A> to allow for error injection.
////1'b0 -> De-Asseert inject_error_59 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR58_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR58_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR58[26:26];
        ERR58->desc="
////1'b1 -> Assert the inject_error_58 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<CDP> to allow for error injection.
////1'b0 -> De-Asseert inject_error_58 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR57_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR57_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR57[25:25];
        ERR57->desc="
////1'b1 -> Assert the inject_error_57 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<CDP> to allow for error injection.
////1'b0 -> De-Asseert inject_error_57 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR56_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR56_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR56[24:24];
        ERR56->desc="
////1'b1 -> Assert the inject_error_56 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<PDP> to allow for error injection.
////1'b0 -> De-Asseert inject_error_56 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR55_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR55_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR55[23:23];
        ERR55->desc="
////1'b1 -> Assert the inject_error_55 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<PDP> to allow for error injection.
////1'b0 -> De-Asseert inject_error_55 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR54_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR54_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR54[22:22];
        ERR54->desc="
////1'b1 -> Assert the inject_error_54 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<SDP>.<E2> to allow for error injection.
////1'b0 -> De-Asseert inject_error_54 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR53_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR53_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR53[21:21];
        ERR53->desc="
////1'b1 -> Assert the inject_error_53 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<SDP>.<E2> to allow for error injection.
////1'b0 -> De-Asseert inject_error_53 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR52_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR52_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR52[20:20];
        ERR52->desc="
////1'b1 -> Assert the inject_error_52 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<SDP>.<N2> to allow for error injection.
////1'b0 -> De-Asseert inject_error_52 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR51_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR51_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR51[19:19];
        ERR51->desc="
////1'b1 -> Assert the inject_error_51 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<SDP>.<N2> to allow for error injection.
////1'b0 -> De-Asseert inject_error_51 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR50_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR50_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR50[18:18];
        ERR50->desc="
////1'b1 -> Assert the inject_error_50 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<SDP>.<B2> to allow for error injection.
////1'b0 -> De-Asseert inject_error_50 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR49_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR49_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR49[17:17];
        ERR49->desc="
////1'b1 -> Assert the inject_error_49 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<SDP>.<B2> to allow for error injection.
////1'b0 -> De-Asseert inject_error_49 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR48_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR48_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR48[16:16];
        ERR48->desc="
////1'b1 -> Assert the inject_error_48 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<SDP> to allow for error injection.
////1'b0 -> De-Asseert inject_error_48 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR47_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR47_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR47[15:15];
        ERR47->desc="
////1'b1 -> Assert the inject_error_47 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<SDP> to allow for error injection.
////1'b0 -> De-Asseert inject_error_47 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR46_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR46_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR46[14:14];
        ERR46->desc="
////1'b1 -> Assert the inject_error_46 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<D7BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_46 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR45_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR45_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR45[13:13];
        ERR45->desc="
////1'b1 -> Assert the inject_error_45 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<D7BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_45 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR44_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR44_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR44[12:12];
        ERR44->desc="
////1'b1 -> Assert the inject_error_44 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<D6BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_44 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR43_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR43_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR43[11:11];
        ERR43->desc="
////1'b1 -> Assert the inject_error_43 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<D6BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_43 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR42_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR42_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR42[10:10];
        ERR42->desc="
////1'b1 -> Assert the inject_error_42 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<D5BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_42 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR41_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR41_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR41[9:9];
        ERR41->desc="
////1'b1 -> Assert the inject_error_41 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<D5BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_41 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR40_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR40_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR40[8:8];
        ERR40->desc="
////1'b1 -> Assert the inject_error_40 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<D4BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_40 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR39_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR39_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR39[7:7];
        ERR39->desc="
////1'b1 -> Assert the inject_error_39 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<D4BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_39 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR38_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR38_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR38[6:6];
        ERR38->desc="
////1'b1 -> Assert the inject_error_38 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<D3BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_38 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR37_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR37_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR37[5:5];
        ERR37->desc="
////1'b1 -> Assert the inject_error_37 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<D3BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_37 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR36_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR36_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR36[4:4];
        ERR36->desc="
////1'b1 -> Assert the inject_error_36 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<D2BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_36 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR35_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR35_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR35[3:3];
        ERR35->desc="
////1'b1 -> Assert the inject_error_35 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<D2BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_35 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR34_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR34_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR34[2:2];
        ERR34->desc="
////1'b1 -> Assert the inject_error_34 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<D1BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_34 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR33_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR33_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR33[1:1];
        ERR33->desc="
////1'b1 -> Assert the inject_error_33 output for ECC SEC Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<D1BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_33 output.
";
        enum ERRSLICE1_MISSIONERR_INJECT_ERR32_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_INJECT_ERR32_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR32[0:0];
        ERR32->desc="
////1'b1 -> Assert the inject_error_32 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<CACC>.<D0BUF> to allow for error injection.
////1'b0 -> De-Asseert inject_error_32 output.
";
    }ERRSLICE1_MISSIONERR_INJECT @0x6c;
    reg {
        name = "ERRSLICE1_LATENTERR_ENABLE";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR63_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR63_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR63[31:31];
        ERR63->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<IMEM>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<IMEM>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR62_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR62_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR62[30:30];
        ERR62->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_B>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_B>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR61_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR61_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR61[29:29];
        ERR61->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_B>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_B>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR60_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR60_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR60[28:28];
        ERR60->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_A>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_A>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR59_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR59_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR59[27:27];
        ERR59->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_A>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_A>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR58_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR58_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR58[26:26];
        ERR58->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CDP>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CDP>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR57_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR57_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR57[25:25];
        ERR57->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CDP>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CDP>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR56_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR56_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR56[24:24];
        ERR56->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<PDP>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<PDP>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR55_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR55_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR55[23:23];
        ERR55->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<PDP>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<PDP>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR54_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR54_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR54[22:22];
        ERR54->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<E2>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<E2>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR53_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR53_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR53[21:21];
        ERR53->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<E2>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<E2>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR52_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR52_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR52[20:20];
        ERR52->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<N2>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<N2>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR51_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR51_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR51[19:19];
        ERR51->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<N2>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<N2>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR50_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR50_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR50[18:18];
        ERR50->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<B2>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<B2>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR49_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR49_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR49[17:17];
        ERR49->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<B2>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<B2>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR48_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR48_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR48[16:16];
        ERR48->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR47_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR47_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR47[15:15];
        ERR47->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR46_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR46_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR46[14:14];
        ERR46->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D7BUF>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D7BUF>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR45_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR45_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR45[13:13];
        ERR45->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D7BUF>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D7BUF>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR44_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR44_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR44[12:12];
        ERR44->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D6BUF>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D6BUF>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR43_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR43_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR43[11:11];
        ERR43->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D6BUF>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D6BUF>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR42_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR42_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR42[10:10];
        ERR42->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D5BUF>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D5BUF>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR41_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR41_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR41[9:9];
        ERR41->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D5BUF>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D5BUF>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR40_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR40_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR40[8:8];
        ERR40->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D4BUF>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D4BUF>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR39_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR39_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR39[7:7];
        ERR39->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D4BUF>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D4BUF>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR38_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR38_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR38[6:6];
        ERR38->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D3BUF>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D3BUF>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR37_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR37_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR37[5:5];
        ERR37->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D3BUF>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D3BUF>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR36_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR36_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR36[4:4];
        ERR36->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D2BUF>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D2BUF>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR35_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR35_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR35[3:3];
        ERR35->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D2BUF>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D2BUF>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR34_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR34_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR34[2:2];
        ERR34->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D1BUF>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D1BUF>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR33_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR33_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR33[1:1];
        ERR33->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D1BUF>
////1'b0 -> Disable Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D1BUF>
";
        enum ERRSLICE1_LATENTERR_ENABLE_ERR32_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_ENABLE_ERR32_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR32[0:0];
        ERR32->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D0BUF>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D0BUF>
";
    }ERRSLICE1_LATENTERR_ENABLE @0x70;
    reg {
        name = "ERRSLICE1_LATENTERR_FORCE";
        enum ERRSLICE1_LATENTERR_FORCE_ERR63_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR63_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR63[31:31];
        ERR63->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<IMEM>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR62_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR62_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR62[30:30];
        ERR62->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_B>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR61_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR61_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR61[29:29];
        ERR61->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_B>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR60_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR60_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR60[28:28];
        ERR60->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_A>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR59_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR59_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR59[27:27];
        ERR59->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_A>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR58_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR58_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR58[26:26];
        ERR58->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CDP>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR57_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR57_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR57[25:25];
        ERR57->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CDP>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR56_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR56_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR56[24:24];
        ERR56->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<PDP>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR55_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR55_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR55[23:23];
        ERR55->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<PDP>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR54_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR54_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR54[22:22];
        ERR54->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<E2>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR53_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR53_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR53[21:21];
        ERR53->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<E2>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR52_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR52_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR52[20:20];
        ERR52->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<N2>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR51_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR51_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR51[19:19];
        ERR51->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<N2>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR50_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR50_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR50[18:18];
        ERR50->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<B2>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR49_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR49_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR49[17:17];
        ERR49->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<B2>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR48_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR48_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR48[16:16];
        ERR48->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR47_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR47_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR47[15:15];
        ERR47->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR46_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR46_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR46[14:14];
        ERR46->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D7BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR45_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR45_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR45[13:13];
        ERR45->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D7BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR44_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR44_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR44[12:12];
        ERR44->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D6BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR43_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR43_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR43[11:11];
        ERR43->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D6BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR42_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR42_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR42[10:10];
        ERR42->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D5BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR41_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR41_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR41[9:9];
        ERR41->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D5BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR40_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR40_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR40[8:8];
        ERR40->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D4BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR39_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR39_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR39[7:7];
        ERR39->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D4BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR38_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR38_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR38[6:6];
        ERR38->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D3BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR37_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR37_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR37[5:5];
        ERR37->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D3BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR36_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR36_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR36[4:4];
        ERR36->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D2BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR35_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR35_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR35[3:3];
        ERR35->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D2BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR34_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR34_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR34[2:2];
        ERR34->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D1BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR33_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR33_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR33[1:1];
        ERR33->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D1BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_LATENTERR_FORCE_ERR32_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_LATENTERR_FORCE_ERR32_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR32[0:0];
        ERR32->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D0BUF>
////1'b0 -> Do Nothing
";
    }ERRSLICE1_LATENTERR_FORCE @0x74;
    reg {
        name = "ERRSLICE1_LATENTERR_STATUS";
        desc = "
////SW must write 1 to clear the fields of this register.
////Bits in this register continue to be logged independent of the value of LatentError_Enable register, to avoid silent dropping of errors.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR63[31:31];
        ERR63->desc="
////1'b1 -> Error_63_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<IMEM> was equal to 2'b10.
////1'b0 -> Error_63_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<IMEM> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR62[30:30];
        ERR62->desc="
////1'b1 -> Error_62_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_B> was equal to 2'b10.
////1'b0 -> Error_62_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_B> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR61[29:29];
        ERR61->desc="
////1'b1 -> Error_61_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_B> was equal to 2'b10.
////1'b0 -> Error_61_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_B> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR60[28:28];
        ERR60->desc="
////1'b1 -> Error_60_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_A> was equal to 2'b10.
////1'b0 -> Error_60_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_A> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR59[27:27];
        ERR59->desc="
////1'b1 -> Error_59_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_A> was equal to 2'b10.
////1'b0 -> Error_59_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_A> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR58[26:26];
        ERR58->desc="
////1'b1 -> Error_58_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CDP> was equal to 2'b10.
////1'b0 -> Error_58_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CDP> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR57[25:25];
        ERR57->desc="
////1'b1 -> Error_57_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CDP> was equal to 2'b10.
////1'b0 -> Error_57_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CDP> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR56[24:24];
        ERR56->desc="
////1'b1 -> Error_56_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<PDP> was equal to 2'b10.
////1'b0 -> Error_56_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<PDP> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR55[23:23];
        ERR55->desc="
////1'b1 -> Error_55_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<PDP> was equal to 2'b10.
////1'b0 -> Error_55_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<PDP> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR54[22:22];
        ERR54->desc="
////1'b1 -> Error_54_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<E2> was equal to 2'b10.
////1'b0 -> Error_54_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<E2> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR53[21:21];
        ERR53->desc="
////1'b1 -> Error_53_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<E2> was equal to 2'b10.
////1'b0 -> Error_53_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<E2> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR52[20:20];
        ERR52->desc="
////1'b1 -> Error_52_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<N2> was equal to 2'b10.
////1'b0 -> Error_52_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<N2> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR51[19:19];
        ERR51->desc="
////1'b1 -> Error_51_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<N2> was equal to 2'b10.
////1'b0 -> Error_51_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<N2> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR50[18:18];
        ERR50->desc="
////1'b1 -> Error_50_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<B2> was equal to 2'b10.
////1'b0 -> Error_50_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<B2> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR49[17:17];
        ERR49->desc="
////1'b1 -> Error_49_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<B2> was equal to 2'b10.
////1'b0 -> Error_49_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<B2> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR48[16:16];
        ERR48->desc="
////1'b1 -> Error_48_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP> was equal to 2'b10.
////1'b0 -> Error_48_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR47[15:15];
        ERR47->desc="
////1'b1 -> Error_47_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP> was equal to 2'b10.
////1'b0 -> Error_47_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR46[14:14];
        ERR46->desc="
////1'b1 -> Error_46_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D7BUF> was equal to 2'b10.
////1'b0 -> Error_46_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D7BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR45[13:13];
        ERR45->desc="
////1'b1 -> Error_45_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D7BUF> was equal to 2'b10.
////1'b0 -> Error_45_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D7BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR44[12:12];
        ERR44->desc="
////1'b1 -> Error_44_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D6BUF> was equal to 2'b10.
////1'b0 -> Error_44_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D6BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR43[11:11];
        ERR43->desc="
////1'b1 -> Error_43_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D6BUF> was equal to 2'b10.
////1'b0 -> Error_43_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D6BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR42[10:10];
        ERR42->desc="
////1'b1 -> Error_42_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D5BUF> was equal to 2'b10.
////1'b0 -> Error_42_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D5BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR41[9:9];
        ERR41->desc="
////1'b1 -> Error_41_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D5BUF> was equal to 2'b10.
////1'b0 -> Error_41_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D5BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR40[8:8];
        ERR40->desc="
////1'b1 -> Error_40_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D4BUF> was equal to 2'b10.
////1'b0 -> Error_40_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D4BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR39[7:7];
        ERR39->desc="
////1'b1 -> Error_39_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D4BUF> was equal to 2'b10.
////1'b0 -> Error_39_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D4BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR38[6:6];
        ERR38->desc="
////1'b1 -> Error_38_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D3BUF> was equal to 2'b10.
////1'b0 -> Error_38_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D3BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR37[5:5];
        ERR37->desc="
////1'b1 -> Error_37_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D3BUF> was equal to 2'b10.
////1'b0 -> Error_37_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D3BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR36[4:4];
        ERR36->desc="
////1'b1 -> Error_36_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D2BUF> was equal to 2'b10.
////1'b0 -> Error_36_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D2BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR35[3:3];
        ERR35->desc="
////1'b1 -> Error_35_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D2BUF> was equal to 2'b10.
////1'b0 -> Error_35_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D2BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR34[2:2];
        ERR34->desc="
////1'b1 -> Error_34_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D1BUF> was equal to 2'b10.
////1'b0 -> Error_34_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D1BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR33[1:1];
        ERR33->desc="
////1'b1 -> Error_33_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D1BUF> was equal to 2'b10.
////1'b0 -> Error_33_pulse[1:0] for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D1BUF> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR32[0:0];
        ERR32->desc="
////1'b1 -> Error_32_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D0BUF> was equal to 2'b10.
////1'b0 -> Error_32_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D0BUF> was equal to 2'b01.
";
    }ERRSLICE1_LATENTERR_STATUS @0x78;
    reg {
        name = "ERRSLICE1_COUNTER_RELOAD";
        enum ERRSLICE1_COUNTER_RELOAD_ERR63_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR63_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR63[31:31];
        ERR63->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<IMEM>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR62_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR62_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR62[30:30];
        ERR62->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_B>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR61_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR61_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR61[29:29];
        ERR61->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_B>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR60_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR60_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR60[28:28];
        ERR60->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_A>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR59_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR59_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR59[27:27];
        ERR59->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<RUBIK>.<FIFO_A>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR58_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR58_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR58[26:26];
        ERR58->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CDP>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR57_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR57_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR57[25:25];
        ERR57->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CDP>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR56_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR56_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR56[24:24];
        ERR56->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<PDP>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR55_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR55_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR55[23:23];
        ERR55->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<PDP>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR54_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR54_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR54[22:22];
        ERR54->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<E2>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR53_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR53_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR53[21:21];
        ERR53->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<E2>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR52_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR52_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR52[20:20];
        ERR52->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<N2>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR51_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR51_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR51[19:19];
        ERR51->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<N2>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR50_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR50_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR50[18:18];
        ERR50->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<B2>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR49_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR49_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR49[17:17];
        ERR49->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>.<B2>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR48_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR48_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR48[16:16];
        ERR48->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR47_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR47_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR47[15:15];
        ERR47->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<SDP>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR46_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR46_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR46[14:14];
        ERR46->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D7BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR45_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR45_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR45[13:13];
        ERR45->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D7BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR44_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR44_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR44[12:12];
        ERR44->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D6BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR43_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR43_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR43[11:11];
        ERR43->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D6BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR42_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR42_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR42[10:10];
        ERR42->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D5BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR41_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR41_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR41[9:9];
        ERR41->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D5BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR40_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR40_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR40[8:8];
        ERR40->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D4BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR39_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR39_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR39[7:7];
        ERR39->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D4BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR38_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR38_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR38[6:6];
        ERR38->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D3BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR37_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR37_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR37[5:5];
        ERR37->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D3BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR36_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR36_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR36[4:4];
        ERR36->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D2BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR35_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR35_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR35[3:3];
        ERR35->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D2BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR34_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR34_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR34[2:2];
        ERR34->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D1BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR33_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR33_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR33[1:1];
        ERR33->desc="
////1'b1 -> Reload Error Counter for ECC SEC Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D1BUF>
////1'b0 -> Do Nothing
";
        enum ERRSLICE1_COUNTER_RELOAD_ERR32_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE1_COUNTER_RELOAD_ERR32_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR32[0:0];
        ERR32->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<CACC>.<D0BUF>
////1'b0 -> Do Nothing
";
    }ERRSLICE1_COUNTER_RELOAD @0x80;
    reg {
        name = "ERRSLICE1_MISSIONERR_ECC_CORRECTION_DIS";
        enum ERRSLICE1_MISSIONERR_ECC_CORRECTION_DIS_ERR63_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE1_MISSIONERR_ECC_CORRECTION_DIS_ERR63_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR63[31:31];
        ERR63->desc="
////1'b1 -> Disables ECC correction in ECC Terminate plugins for <NV_DLA>.<FALCON>.<IMEM> and shall report single bit errors over the ded_err_pulse[1:0] to only allow detection and no correction.
////1'b0 -> ECC correction is enabled in ECC terminate plugins for <NV_DLA>.<FALCON>.<IMEM> and shall correct single bit errors and report them over sec_err_pulse[1:0]
";
    }ERRSLICE1_MISSIONERR_ECC_CORRECTION_DIS @0x84;
    reg {
        name = "ERRSLICE2_MISSIONERR_ENABLE";
        desc = "
//// 0x28 to 0x30 = Reserved for future use.
////==================================
//// ERROR SLICE - 2
////==================================
";
        enum ERRSLICE2_MISSIONERR_ENABLE_ERR67_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE2_MISSIONERR_ENABLE_ERR67_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR67[3:3];
        ERR67->desc="
////1'b1 -> Enable  Mission Error Reporting for SW Uncorrectabel Error from <NV_DLA>.<FALCON>.<ERB>
////1'b0 -> Disable Mission Error Reporting for SW Uncorrectabel Error from <NV_DLA>.<FALCON>.<ERB>
";
        enum ERRSLICE2_MISSIONERR_ENABLE_ERR66_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE2_MISSIONERR_ENABLE_ERR66_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR66[2:2];
        ERR66->desc="
////1'b1 -> Enable  Mission Error Reporting for SW Correctable Error from <NV_DLA>.<FALCON>.<ERB>
////1'b0 -> Disable Mission Error Reporting for SW Correctable Error from <NV_DLA>.<FALCON>.<ERB>
";
        enum ERRSLICE2_MISSIONERR_ENABLE_ERR65_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE2_MISSIONERR_ENABLE_ERR65_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR65[1:1];
        ERR65->desc="
////1'b1 -> Enable  Mission Error Reporting for Parity Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<DMEM>
////1'b0 -> Disable Mission Error Reporting for Parity Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<DMEM>
";
        enum ERRSLICE2_MISSIONERR_ENABLE_ERR64_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE2_MISSIONERR_ENABLE_ERR64_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR64[0:0];
        ERR64->desc="
////1'b1 -> Enable  Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<IMEM>
////1'b0 -> Disable Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<IMEM>
";
    }ERRSLICE2_MISSIONERR_ENABLE @0x90;
    reg {
        name = "ERRSLICE2_MISSIONERR_FORCE";
        enum ERRSLICE2_MISSIONERR_FORCE_ERR67_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE2_MISSIONERR_FORCE_ERR67_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR67[3:3];
        ERR67->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for SW Uncorrectabel Error from <NV_DLA>.<FALCON>.<ERB>
////1'b0 -> Do Nothing
";
        enum ERRSLICE2_MISSIONERR_FORCE_ERR66_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE2_MISSIONERR_FORCE_ERR66_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR66[2:2];
        ERR66->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for SW Correctable Error from <NV_DLA>.<FALCON>.<ERB>
////1'b0 -> Do Nothing
";
        enum ERRSLICE2_MISSIONERR_FORCE_ERR65_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE2_MISSIONERR_FORCE_ERR65_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR65[1:1];
        ERR65->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for Parity Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<DMEM>
////1'b0 -> Do Nothing
";
        enum ERRSLICE2_MISSIONERR_FORCE_ERR64_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE2_MISSIONERR_FORCE_ERR64_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR64[0:0];
        ERR64->desc="
////1'b1 -> Force Assertion of Mission Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<IMEM>
////1'b0 -> Do Nothing
";
    }ERRSLICE2_MISSIONERR_FORCE @0x94;
    reg {
        name = "ERRSLICE2_MISSIONERR_STATUS";
        desc = "
////SW must write 1 to clear the fields of this register.
////Bits in this register continue to be logged independent of the value of MissionError_Enable register, to avoid silent dropping of errors.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR67[3:3];
        ERR67->desc="
////1'b1 -> Error_67_pulse[1:0] for SW Uncorrectabel Error from <NV_DLA>.<FALCON>.<ERB> was equal to 2'b10.
////1'b0 -> Error_67_pulse[1:0] for SW Uncorrectabel Error from <NV_DLA>.<FALCON>.<ERB> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR66[2:2];
        ERR66->desc="
////1'b1 -> Error_66_pulse[1:0] for SW Correctable Error from <NV_DLA>.<FALCON>.<ERB> was equal to 2'b10.
////1'b0 -> Error_66_pulse[1:0] for SW Correctable Error from <NV_DLA>.<FALCON>.<ERB> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR65[1:1];
        ERR65->desc="
////1'b1 -> Error_65_pulse[1:0] for Parity Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<DMEM> was equal to 2'b10.
////1'b0 -> Error_65_pulse[1:0] for Parity Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<DMEM> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR64[0:0];
        ERR64->desc="
////1'b1 -> Error_64_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<IMEM> was equal to 2'b10.
////1'b0 -> Error_64_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<IMEM> was equal to 2'b01.
";
    }ERRSLICE2_MISSIONERR_STATUS @0x98;
    reg {
        name = "ERRSLICE2_MISSIONERR_INJECT";
        enum ERRSLICE2_MISSIONERR_INJECT_ERR65_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE2_MISSIONERR_INJECT_ERR65_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR65[1:1];
        ERR65->desc="
////1'b1 -> Assert the inject_error_65 output for Parity Error from on-chip SRAM/Fifo to <NV_DLA>.<FALCON>.<DMEM> to allow for error injection.
////1'b0 -> De-Asseert inject_error_65 output.
";
        enum ERRSLICE2_MISSIONERR_INJECT_ERR64_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE2_MISSIONERR_INJECT_ERR64_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR64[0:0];
        ERR64->desc="
////1'b1 -> Assert the inject_error_64 output for ECC DED Error from on-chip SRAM/Fifo to <NV_DLA>.<FALCON>.<IMEM> to allow for error injection.
////1'b0 -> De-Asseert inject_error_64 output.
";
    }ERRSLICE2_MISSIONERR_INJECT @0x9c;
    reg {
        name = "ERRSLICE2_LATENTERR_ENABLE";
        enum ERRSLICE2_LATENTERR_ENABLE_ERR67_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE2_LATENTERR_ENABLE_ERR67_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR67[3:3];
        ERR67->desc="
////1'b1 -> Enable  Latent Error Reporting for SW Uncorrectabel Error from <NV_DLA>.<FALCON>.<ERB>
////1'b0 -> Disable Latent Error Reporting for SW Uncorrectabel Error from <NV_DLA>.<FALCON>.<ERB>
";
        enum ERRSLICE2_LATENTERR_ENABLE_ERR66_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE2_LATENTERR_ENABLE_ERR66_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR66[2:2];
        ERR66->desc="
////1'b1 -> Enable  Latent Error Reporting for SW Correctable Error from <NV_DLA>.<FALCON>.<ERB>
////1'b0 -> Disable Latent Error Reporting for SW Correctable Error from <NV_DLA>.<FALCON>.<ERB>
";
        enum ERRSLICE2_LATENTERR_ENABLE_ERR65_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE2_LATENTERR_ENABLE_ERR65_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR65[1:1];
        ERR65->desc="
////1'b1 -> Enable  Latent Error Reporting for Parity Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<DMEM>
////1'b0 -> Disable Latent Error Reporting for Parity Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<DMEM>
";
        enum ERRSLICE2_LATENTERR_ENABLE_ERR64_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = ERRSLICE2_LATENTERR_ENABLE_ERR64_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR64[0:0];
        ERR64->desc="
////1'b1 -> Enable  Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<IMEM>
////1'b0 -> Disable Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<IMEM>
";
    }ERRSLICE2_LATENTERR_ENABLE @0xa0;
    reg {
        name = "ERRSLICE2_LATENTERR_FORCE";
        enum ERRSLICE2_LATENTERR_FORCE_ERR67_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE2_LATENTERR_FORCE_ERR67_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR67[3:3];
        ERR67->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for SW Uncorrectabel Error from <NV_DLA>.<FALCON>.<ERB>
////1'b0 -> Do Nothing
";
        enum ERRSLICE2_LATENTERR_FORCE_ERR66_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE2_LATENTERR_FORCE_ERR66_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR66[2:2];
        ERR66->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for SW Correctable Error from <NV_DLA>.<FALCON>.<ERB>
////1'b0 -> Do Nothing
";
        enum ERRSLICE2_LATENTERR_FORCE_ERR65_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE2_LATENTERR_FORCE_ERR65_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR65[1:1];
        ERR65->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for Parity Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<DMEM>
////1'b0 -> Do Nothing
";
        enum ERRSLICE2_LATENTERR_FORCE_ERR64_enum {
            NOFORCE = 1'd0;
            FORCE = 1'd1;
        };
        field {
            encode          = ERRSLICE2_LATENTERR_FORCE_ERR64_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR64[0:0];
        ERR64->desc="
////1'b1 -> Force Assertion of Latent Error Reporting for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<IMEM>
////1'b0 -> Do Nothing
";
    }ERRSLICE2_LATENTERR_FORCE @0xa4;
    reg {
        name = "ERRSLICE2_LATENTERR_STATUS";
        desc = "
////SW must write 1 to clear the fields of this register.
////Bits in this register continue to be logged independent of the value of LatentError_Enable register, to avoid silent dropping of errors.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR67[3:3];
        ERR67->desc="
////1'b1 -> Error_67_pulse[1:0] for SW Uncorrectabel Error from <NV_DLA>.<FALCON>.<ERB> was equal to 2'b10.
////1'b0 -> Error_67_pulse[1:0] for SW Uncorrectabel Error from <NV_DLA>.<FALCON>.<ERB> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR66[2:2];
        ERR66->desc="
////1'b1 -> Error_66_pulse[1:0] for SW Correctable Error from <NV_DLA>.<FALCON>.<ERB> was equal to 2'b10.
////1'b0 -> Error_66_pulse[1:0] for SW Correctable Error from <NV_DLA>.<FALCON>.<ERB> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR65[1:1];
        ERR65->desc="
////1'b1 -> Error_65_pulse[1:0] for Parity Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<DMEM> was equal to 2'b10.
////1'b0 -> Error_65_pulse[1:0] for Parity Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<DMEM> was equal to 2'b01.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR64[0:0];
        ERR64->desc="
////1'b1 -> Error_64_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<IMEM> was equal to 2'b10.
////1'b0 -> Error_64_pulse[1:0] for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<IMEM> was equal to 2'b01.
";
    }ERRSLICE2_LATENTERR_STATUS @0xa8;
    reg {
        name = "ERRSLICE2_COUNTER_RELOAD";
        enum ERRSLICE2_COUNTER_RELOAD_ERR67_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE2_COUNTER_RELOAD_ERR67_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR67[3:3];
        ERR67->desc="
////1'b1 -> Reload Error Counter for SW Uncorrectabel Error from <NV_DLA>.<FALCON>.<ERB>
////1'b0 -> Do Nothing
";
        enum ERRSLICE2_COUNTER_RELOAD_ERR66_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE2_COUNTER_RELOAD_ERR66_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR66[2:2];
        ERR66->desc="
////1'b1 -> Reload Error Counter for SW Correctable Error from <NV_DLA>.<FALCON>.<ERB>
////1'b0 -> Do Nothing
";
        enum ERRSLICE2_COUNTER_RELOAD_ERR65_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE2_COUNTER_RELOAD_ERR65_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR65[1:1];
        ERR65->desc="
////1'b1 -> Reload Error Counter for Parity Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<DMEM>
////1'b0 -> Do Nothing
";
        enum ERRSLICE2_COUNTER_RELOAD_ERR64_enum {
            NORELOAD = 1'd0;
            RELOAD = 1'd1;
        };
        field {
            encode          = ERRSLICE2_COUNTER_RELOAD_ERR64_enum;
            sw              = w;
            hw              = r;
            spec_access     = w;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } ERR64[0:0];
        ERR64->desc="
////1'b1 -> Reload Error Counter for ECC DED Error from on-chip SRAM/Fifo from <NV_DLA>.<FALCON>.<IMEM>
////1'b0 -> Do Nothing
";
    }ERRSLICE2_COUNTER_RELOAD @0xb0;
};
regfile regs_NVDLA_CVIF{
    default regwidth=32;
    reg {
        name = "CFG_RD_WEIGHT_0";
        desc = "
////CVIF Regiseters
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_WEIGHT_BDMA[7:0];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_WEIGHT_SDP[15:8];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_WEIGHT_PDP[23:16];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_WEIGHT_CDP[31:24];
    }CFG_RD_WEIGHT_0 @0x0;
    reg {
        name = "CFG_RD_WEIGHT_1";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_WEIGHT_SDP_B[7:0];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_WEIGHT_SDP_N[15:8];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_WEIGHT_SDP_E[23:16];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_WEIGHT_CDMA_DAT[31:24];
    }CFG_RD_WEIGHT_1 @0x4;
    reg {
        name = "CFG_RD_WEIGHT_2";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_WEIGHT_CDMA_WT[7:0];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_WEIGHT_RBK[15:8];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_WEIGHT_RSV_1[23:16];
        RD_WEIGHT_RSV_1->desc="
//// reserved
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_WEIGHT_RSV_0[31:24];
        RD_WEIGHT_RSV_0->desc="
//// reserved
";
    }CFG_RD_WEIGHT_2 @0x8;
    reg {
        name = "CFG_WR_WEIGHT_0";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WR_WEIGHT_BDMA[7:0];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WR_WEIGHT_SDP[15:8];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WR_WEIGHT_PDP[23:16];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WR_WEIGHT_CDP[31:24];
    }CFG_WR_WEIGHT_0 @0xc;
    reg {
        name = "CFG_WR_WEIGHT_1";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WR_WEIGHT_RBK[7:0];
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WR_WEIGHT_RSV_2[15:8];
        WR_WEIGHT_RSV_2->desc="
//// reserved
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WR_WEIGHT_RSV_1[23:16];
        WR_WEIGHT_RSV_1->desc="
//// reserved
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WR_WEIGHT_RSV_0[31:24];
        WR_WEIGHT_RSV_0->desc="
//// reserved
";
    }CFG_WR_WEIGHT_1 @0x10;
    reg {
        name = "CFG_OUTSTANDING_CNT";
        desc = "
//// outstanding AXI transactions in unit of 64Byte, less than 256
//// +1: NOTE: as CVIF will send up to 256B stransaction, so OS_CNT need be at least 3.
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0xff;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_OS_CNT[7:0];
        RD_OS_CNT->desc="
//// reserved
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0xff;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WR_OS_CNT[15:8];
        WR_OS_CNT->desc="
//// reserved
";
    }CFG_OUTSTANDING_CNT @0x14;
    reg {
        name = "STATUS";
        enum STATUS_IDLE_enum {
            NO = 1'd0 {desc = "
//// module is not idle, means there are oustanding AXI trans from/to CVNAS
";};
            YES = 1'd1 {desc = "
//// module is idle, no outstanding AXI trnas from/to CVNAS
";};
        };
        field {
            encode          = STATUS_IDLE_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } IDLE[8:8];
    }STATUS @0x18;
};
regfile regs_NVDLA_BDMA{
    default regwidth=32;
    reg {
        name = "CFG_SRC_ADDR_LOW";
        desc = "
////Bridge DMA Registers
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7ffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } V32[31:5];
        V32->desc="
//// catenate with CFG_SRC_ADDR_HIGH to form a 40bit addr
";
    }CFG_SRC_ADDR_LOW @0x0;
    reg {
        name = "CFG_SRC_ADDR_HIGH";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } V8[31:0];
        V8->desc="
//// catenate with CFG_SRC_ADDR_LOW to form a 40bit addr
";
    }CFG_SRC_ADDR_HIGH @0x4;
    reg {
        name = "CFG_DST_ADDR_LOW";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7ffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } V32[31:5];
        V32->desc="
//// catenate with CFG_SRC_ADDR_HIGH to form a 40bit addr
";
    }CFG_DST_ADDR_LOW @0x8;
    reg {
        name = "CFG_DST_ADDR_HIGH";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } V8[31:0];
        V8->desc="
//// catenate with CFG_SRC_ADDR_LOW to form a 40bit addr
";
    }CFG_DST_ADDR_HIGH @0xc;
    reg {
        name = "CFG_LINE";
        desc = "
////+1
////in unit of 32B
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SIZE[12:0];
    }CFG_LINE @0x10;
    reg {
        name = "CFG_CMD";
        enum CFG_CMD_SRC_RAM_TYPE_enum {
            CVSRAM = 1'd0 {desc = "
//// memory copy src from CVSRAM
";};
            MC = 1'd1 {desc = "
//// memory copy src from MC
";};
        };
        field {
            encode          = CFG_CMD_SRC_RAM_TYPE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } SRC_RAM_TYPE[0:0];
        enum CFG_CMD_DST_RAM_TYPE_enum {
            CVSRAM = 1'd0 {desc = "
//// memory copy dst to CVSRAM
";};
            MC = 1'd1 {desc = "
//// memory copy dst to CVSRAM
";};
        };
        field {
            encode          = CFG_CMD_DST_RAM_TYPE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DST_RAM_TYPE[1:1];
    }CFG_CMD @0x14;
    reg {
        name = "CFG_LINE_REPEAT";
        desc = "
////+1: 
////NUMBER is from 0 to 0x1fff
////NUMBER[23:13] need be set as 0, which is reserved
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } NUMBER[23:0];
        NUMBER->desc="
//// 
";
    }CFG_LINE_REPEAT @0x18;
    reg {
        name = "CFG_SRC_LINE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7ffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STRIDE[31:5];
        STRIDE->desc="
//// 
";
    }CFG_SRC_LINE @0x1c;
    reg {
        name = "CFG_DST_LINE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7ffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STRIDE[31:5];
        STRIDE->desc="
//// 
";
    }CFG_DST_LINE @0x20;
    reg {
        name = "CFG_SURF_REPEAT";
        desc = "
////+1
////NUMBER is from 0 to 0x1fff
////NUMBER[23:13] need be set as 0, which is reserved
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } NUMBER[23:0];
        NUMBER->desc="
//// 
";
    }CFG_SURF_REPEAT @0x24;
    reg {
        name = "CFG_SRC_SURF";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7ffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STRIDE[31:5];
        STRIDE->desc="
//// 
";
    }CFG_SRC_SURF @0x28;
    reg {
        name = "CFG_DST_SURF";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7ffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STRIDE[31:5];
        STRIDE->desc="
//// 
";
    }CFG_DST_SURF @0x2c;
    reg {
        name = "CFG_OP";
        enum CFG_OP_EN_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = CFG_OP_EN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rwt;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } EN[0:0];
        EN->desc="
//// 
";
    }CFG_OP @0x30;
    reg {
        name = "CFG_LAUNCH0";
        enum CFG_LAUNCH0_GRP0_LAUNCH_enum {
            NO = 1'd0 {desc = "
//// no action
";};
            YES = 1'd1 {desc = "
//// launch the previously enabled cmd
";};
        };
        field {
            encode          = CFG_LAUNCH0_GRP0_LAUNCH_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rwt;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } GRP0_LAUNCH[0:0];
    }CFG_LAUNCH0 @0x34;
    reg {
        name = "CFG_LAUNCH1";
        enum CFG_LAUNCH1_GRP1_LAUNCH_enum {
            NO = 1'd0 {desc = "
//// no action
";};
            YES = 1'd1 {desc = "
//// launch the previously enabled cmd
";};
        };
        field {
            encode          = CFG_LAUNCH1_GRP1_LAUNCH_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rwt;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } GRP1_LAUNCH[0:0];
    }CFG_LAUNCH1 @0x38;
    reg {
        name = "CFG_STATUS";
        enum CFG_STATUS_STALL_COUNT_EN_enum {
            NO = 1'd0 {desc = "
//// disable stall counting
";};
            YES = 1'd1 {desc = "
//// enable stall counting
";};
        };
        field {
            encode          = CFG_STATUS_STALL_COUNT_EN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STALL_COUNT_EN[0:0];
    }CFG_STATUS @0x3c;
    reg {
        name = "STATUS";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x14;
            reset_mask      = 0xff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } FREE_SLOT[7:0];
        enum STATUS_IDLE_enum {
            NO = 1'd0 {desc = "
//// module is not idle, means memory copy is in process
";};
            YES = 1'd1 {desc = "
//// module is idle, means no pending command
";};
        };
        field {
            encode          = STATUS_IDLE_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x1;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } IDLE[8:8];
        enum STATUS_GRP0_BUSY_enum {
            NO = 1'd0 {desc = "
//// GRP0 has no outstanding interrupt
";};
            YES = 1'd1 {desc = "
//// GRP0 has outstanding interrupt not returned
";};
        };
        field {
            encode          = STATUS_GRP0_BUSY_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } GRP0_BUSY[9:9];
        enum STATUS_GRP1_BUSY_enum {
            NO = 1'd0 {desc = "
//// GRP1 has no outstanding interrupt
";};
            YES = 1'd1 {desc = "
//// GRP1 has outstanding interrupt not returned
";};
        };
        field {
            encode          = STATUS_GRP1_BUSY_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } GRP1_BUSY[10:10];
    }STATUS @0x40;
    reg {
        name = "STATUS_GRP0_READ_STALL";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } COUNT[31:0];
    }STATUS_GRP0_READ_STALL @0x44;
    reg {
        name = "STATUS_GRP0_WRITE_STALL";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } COUNT[31:0];
    }STATUS_GRP0_WRITE_STALL @0x48;
    reg {
        name = "STATUS_GRP1_READ_STALL";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } COUNT[31:0];
    }STATUS_GRP1_READ_STALL @0x4c;
    reg {
        name = "STATUS_GRP1_WRITE_STALL";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } COUNT[31:0];
    }STATUS_GRP1_WRITE_STALL @0x50;
};
regfile regs_NVDLA_RBK{
    default regwidth=32;
    reg {
        name = "S_STATUS";
        desc = "
////Rubik Engine Registers
";
        enum S_STATUS_STATUS_0_enum {
            IDLE = 2'd0;
            RUNNING = 2'd1;
            PENDING = 2'd2;
        };
        field {
            encode          = S_STATUS_STATUS_0_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_0[1:0];
        STATUS_0->desc="
//// Status of configuration register group 0
";
        enum S_STATUS_STATUS_1_enum {
            IDLE = 2'd0;
            RUNNING = 2'd1;
            PENDING = 2'd2;
        };
        field {
            encode          = S_STATUS_STATUS_1_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } STATUS_1[17:16];
        STATUS_1->desc="
//// Status of configuration register group 1
";
    }S_STATUS @0x0;
    reg {
        name = "S_POINTER";
        enum S_POINTER_PRODUCER_enum {
            GROUP_0 = 1'd0;
            GROUP_1 = 1'd1;
        };
        field {
            encode          = S_POINTER_PRODUCER_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PRODUCER[0:0];
        PRODUCER->desc="
////Pointer for CSB master to access groups
";
        enum S_POINTER_CONSUMER_enum {
            GROUP_0 = 1'd0;
            GROUP_1 = 1'd1;
        };
        field {
            encode          = S_POINTER_CONSUMER_enum;
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CONSUMER[16:16];
        CONSUMER->desc="
////Pointer for datapath to access groups
";
    }S_POINTER @0x4;
    reg {
        name = "D_OP_ENABLE";
        desc = "
//////////////////////////////////////////////////////////////////////////////////
////                                                                            //
////                    Define single group registers here                      //
////                    Register name should shart with prefix D_               //
////                                                                            //
//////////////////////////////////////////////////////////////////////////////////
//// 
";
        enum D_OP_ENABLE_OP_EN_enum {
            DISABLE = 1'd0;
            ENABLE = 1'd1;
        };
        field {
            encode          = D_OP_ENABLE_OP_EN_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rwto;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } OP_EN[0:0];
    }D_OP_ENABLE @0x8;
    reg {
        name = "D_MISC_CFG";
        enum D_MISC_CFG_RUBIK_MODE_enum {
            CONTRACT = 2'd0;
            SPLIT = 2'd1;
            MERGE = 2'd2;
        };
        field {
            encode          = D_MISC_CFG_RUBIK_MODE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RUBIK_MODE[1:0];
        enum D_MISC_CFG_IN_PRECISION_enum {
            INT8 = 2'd0;
            INT16 = 2'd1;
            FP16 = 2'd2;
        };
        field {
            encode          = D_MISC_CFG_IN_PRECISION_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x1;
            reset_mask      = 0x3;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } IN_PRECISION[9:8];
    }D_MISC_CFG @0xc;
    reg {
        name = "D_DAIN_RAM_TYPE";
        enum D_DAIN_RAM_TYPE_DATAIN_RAM_TYPE_enum {
            CVIF = 1'd0;
            MCIF = 1'd1;
        };
        field {
            encode          = D_DAIN_RAM_TYPE_DATAIN_RAM_TYPE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAIN_RAM_TYPE[0:0];
        DATAIN_RAM_TYPE->desc="
////indicate the source ram (CV or MC)
";
    }D_DAIN_RAM_TYPE @0x10;
    reg {
        name = "D_DATAIN_SIZE_0";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAIN_WIDTH[12:0];
        DATAIN_WIDTH->desc="
////Input data cube width - 1
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAIN_HEIGHT[28:16];
        DATAIN_HEIGHT->desc="
////Input data cube height - 1
";
    }D_DATAIN_SIZE_0 @0x14;
    reg {
        name = "D_DATAIN_SIZE_1";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAIN_CHANNEL[12:0];
        DATAIN_CHANNEL->desc="
////Input data cube channel - 1
";
    }D_DATAIN_SIZE_1 @0x18;
    reg {
        name = "D_DAIN_ADDR_HIGH";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DAIN_ADDR_HIGH[31:0];
        DAIN_ADDR_HIGH->desc="
////Input data address, high 8 bits
";
    }D_DAIN_ADDR_HIGH @0x1c;
    reg {
        name = "D_DAIN_ADDR_LOW";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7ffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DAIN_ADDR_LOW[31:5];
        DAIN_ADDR_LOW->desc="
////Input data address, low 32 bits
";
    }D_DAIN_ADDR_LOW @0x20;
    reg {
        name = "D_DAIN_LINE_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7ffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DAIN_LINE_STRIDE[31:5];
        DAIN_LINE_STRIDE->desc="
////Input data line stride, bytes
";
    }D_DAIN_LINE_STRIDE @0x24;
    reg {
        name = "D_DAIN_SURF_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7ffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DAIN_SURF_STRIDE[31:5];
        DAIN_SURF_STRIDE->desc="
////Input data surface stride, bytes
";
    }D_DAIN_SURF_STRIDE @0x28;
    reg {
        name = "D_DAIN_PLANAR_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7ffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DAIN_PLANAR_STRIDE[31:5];
        DAIN_PLANAR_STRIDE->desc="
////Input data planar stride, for merge mode only, bytes
";
    }D_DAIN_PLANAR_STRIDE @0x2c;
    reg {
        name = "D_DAOUT_RAM_TYPE";
        enum D_DAOUT_RAM_TYPE_DATAOUT_RAM_TYPE_enum {
            CVIF = 1'd0;
            MCIF = 1'd1;
        };
        field {
            encode          = D_DAOUT_RAM_TYPE_DATAOUT_RAM_TYPE_enum;
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAOUT_RAM_TYPE[0:0];
        DATAOUT_RAM_TYPE->desc="
////indicate the source ram (CV or MC)
";
    }D_DAOUT_RAM_TYPE @0x30;
    reg {
        name = "D_DATAOUT_SIZE_1";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1fff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DATAOUT_CHANNEL[12:0];
        DATAOUT_CHANNEL->desc="
////Output data cube channel - 1
";
    }D_DATAOUT_SIZE_1 @0x34;
    reg {
        name = "D_DAOUT_ADDR_HIGH";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DAOUT_ADDR_HIGH[31:0];
        DAOUT_ADDR_HIGH->desc="
////Output data address, high 8 bits
";
    }D_DAOUT_ADDR_HIGH @0x38;
    reg {
        name = "D_DAOUT_ADDR_LOW";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7ffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DAOUT_ADDR_LOW[31:5];
        DAOUT_ADDR_LOW->desc="
////Output data address, low 32 bits
";
    }D_DAOUT_ADDR_LOW @0x3c;
    reg {
        name = "D_DAOUT_LINE_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7ffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DAOUT_LINE_STRIDE[31:5];
        DAOUT_LINE_STRIDE->desc="
////Output data line stride, bytes
";
    }D_DAOUT_LINE_STRIDE @0x40;
    reg {
        name = "D_CONTRACT_STRIDE_0";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7ffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CONTRACT_STRIDE_0[31:5];
        CONTRACT_STRIDE_0->desc="
////(DATAOUT_CHANNEL+1) * BPE / 32 * DAIN_SURF_STRIDE 
";
    }D_CONTRACT_STRIDE_0 @0x44;
    reg {
        name = "D_CONTRACT_STRIDE_1";
        desc = "
////BPE = (IN_PRECISION == INT8) ? 1 : 2;
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7ffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } CONTRACT_STRIDE_1[31:5];
        CONTRACT_STRIDE_1->desc="
////(DECONV_Y_STRIDE+1) * DAOUT_LINE_STRIDE
";
    }D_CONTRACT_STRIDE_1 @0x48;
    reg {
        name = "D_DAOUT_SURF_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7ffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DAOUT_SURF_STRIDE[31:5];
        DAOUT_SURF_STRIDE->desc="
////Output data surface stride, bytes
";
    }D_DAOUT_SURF_STRIDE @0x4c;
    reg {
        name = "D_DAOUT_PLANAR_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x7ffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DAOUT_PLANAR_STRIDE[31:5];
        DAOUT_PLANAR_STRIDE->desc="
////Output data planar stride, for split mode only, bytes
";
    }D_DAOUT_PLANAR_STRIDE @0x50;
    reg {
        name = "D_DECONV_STRIDE";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DECONV_X_STRIDE[4:0];
        DECONV_X_STRIDE->desc="
////deconvolution x stride - 1
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1f;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } DECONV_Y_STRIDE[20:16];
        DECONV_Y_STRIDE->desc="
////deconvolution y stride - 1
";
    }D_DECONV_STRIDE @0x54;
    reg {
        name = "D_PERF_ENABLE";
        desc = "
////performance register
";
        field {
            sw              = rw;
            hw              = r;
            spec_access     = rw;
            reset           = 0x0;
            reset_mask      = 0x1;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } PERF_EN[0:0];
        PERF_EN->desc="
////Control register to enable/disable perf Counter 
";
    }D_PERF_ENABLE @0x58;
    reg {
        name = "D_PERF_READ_STALL";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } RD_STALL_CNT[31:0];
        RD_STALL_CNT->desc="
////RD_STALL Count stall cycles of read DMA for one layer 
";
    }D_PERF_READ_STALL @0x5c;
    reg {
        name = "D_PERF_WRITE_STALL";
        field {
            sw              = r;
            hw              = w;
            spec_access     = r;
            reset           = 0x0;
            reset_mask      = 0xffffffff;
            spec_sw_default = 0x0;
            sw_default_mask = 0x0;
        } WR_STALL_CNT[31:0];
        WR_STALL_CNT->desc="
////WR_STALL Count stall cycles of wirte DMA for one layer 
";
    }D_PERF_WRITE_STALL @0x60;
};
addrmap  {
    regs_NVDLA_CFGROM NVDLA_CFGROM @0x0;
    regs_NVDLA_GLB NVDLA_GLB @0x1000;
    regs_NVDLA_MCIF NVDLA_MCIF @0x2000;
    regs_NVDLA_CDMA NVDLA_CDMA @0x3000;
    regs_NVDLA_CSC NVDLA_CSC @0x4000;
    regs_NVDLA_CMAC_A NVDLA_CMAC_A @0x5000;
    regs_NVDLA_CMAC_B NVDLA_CMAC_B @0x6000;
    regs_NVDLA_CACC NVDLA_CACC @0x7000;
    regs_NVDLA_SDP_RDMA NVDLA_SDP_RDMA @0x8000;
    regs_NVDLA_SDP NVDLA_SDP @0x9000;
    regs_NVDLA_PDP_RDMA NVDLA_PDP_RDMA @0xa000;
    regs_NVDLA_PDP NVDLA_PDP @0xb000;
    regs_NVDLA_CDP_RDMA NVDLA_CDP_RDMA @0xc000;
    regs_NVDLA_CDP NVDLA_CDP @0xd000;
    regs_NVDLA_GEC NVDLA_GEC @0xe000;
    regs_NVDLA_CVIF NVDLA_CVIF @0xf000;
    regs_NVDLA_BDMA NVDLA_BDMA @0x10000;
    regs_NVDLA_RBK NVDLA_RBK @0x11000;
}addrmap_NVDLA;