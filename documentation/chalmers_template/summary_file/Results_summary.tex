% CREATED BY DAVID FRISK, 2016
\chapter{Results}
Every domain and application could have different evaluation metrics. In the following the overall metrics are evaluated.
\begin{itemize}
\item Utilization factor, for integer 8 and 16 the trend is similar. It is a 1 to 1 mapping between the PEs and the DSPs. As soon as the DSP are used the utilization of LUT and FF is linear in the sizes of Matrix Multiplication unit, while the DSP utilization is quadratic. At a full utilization of DSP entities the PEs start to be implemented in logic there is a sudden rise in the LUT utilization. Increasing the clock frequency, the FPGA's utilization is reduced since with an increase of the Matrix Multiplication Unit sizes the design is not able anymore to meet the timing requirements.
\item Energy and Power Consumption, the power consumption of the processing system and the static power consumption have a less impact on the total power consumption with an increase of the Matrix Multiplication Unit and the frequency. On the other hand, the dynamic power consumption, as expected, grows with a growing Matrix Multiplication Unit and the design frequency.
\item Throughput, it results to be equal to the number of rows into the Matrix Multiplication Unit. Enough data needs to be provided to the accelerator in order to have all the Processing Elements working with useful data, if not, the throughput goes down.
\item Latency, the execution of the models is done with different clock frequencies and data type, and as consequence a different overall latency (and power consumption). The reason about the increase in the latency, since the main goal was to reduce the latency, is that introducing the accelerator and its library comes with several overheads, mainly due to runtime transformations of matrices in a suitable format for the accelerator.
\item Accuracy, it is measured for different data width and model with reference to the actual value (inference without the accelerator). In general, models have a wrong prediction. One of the reason may reside in the input data feed to the model, they are totally random. Another improvement should be to accumulate on the different bit width precision, for example compute multiplication on 8 bits integer and accumulate values on 16-bit integer. Moreover, as in every software product, bugs have not been detected but this does not mean that the written software is bug-free.
\end{itemize}